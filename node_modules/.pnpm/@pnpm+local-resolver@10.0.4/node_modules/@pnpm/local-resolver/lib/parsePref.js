"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePref = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const error_1 = require("@pnpm/error");
const normalize_path_1 = __importDefault(require("normalize-path"));
// @ts-expect-error
const isWindows = process.platform === 'win32' || global['FAKE_WINDOWS'];
const isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
const isFilename = /[.](?:tgz|tar.gz|tar)$/i;
const isAbsolutePath = /^[/]|^[A-Za-z]:/;
function parsePref(wd, projectDir, lockfileDir) {
    if (wd.pref.startsWith('link:') || wd.pref.startsWith('workspace:')) {
        return fromLocal(wd, projectDir, lockfileDir, 'directory');
    }
    if (wd.pref.endsWith('.tgz') ||
        wd.pref.endsWith('.tar.gz') ||
        wd.pref.endsWith('.tar') ||
        wd.pref.includes(path_1.default.sep) ||
        wd.pref.startsWith('file:') ||
        isFilespec.test(wd.pref)) {
        const type = isFilename.test(wd.pref) ? 'file' : 'directory';
        return fromLocal(wd, projectDir, lockfileDir, type);
    }
    if (wd.pref.startsWith('path:')) {
        const err = new error_1.PnpmError('PATH_IS_UNSUPPORTED_PROTOCOL', 'Local dependencies via `path:` protocol are not supported. ' +
            'Use the `link:` protocol for folder dependencies and `file:` for local tarballs');
        // @ts-expect-error
        err['pref'] = wd.pref;
        // @ts-expect-error
        err['protocol'] = 'path:';
        /* eslint-enable @typescript-eslint/dot-notation */
        throw err;
    }
    return null;
}
exports.parsePref = parsePref;
function fromLocal({ pref, injected }, projectDir, lockfileDir, type) {
    const spec = pref.replace(/\\/g, '/')
        .replace(/^(file|link|workspace):[/]*([A-Za-z]:)/, '$2') // drive name paths on windows
        .replace(/^(file|link|workspace):(?:[/]*([~./]))?/, '$2');
    let protocol;
    if (pref.startsWith('file:')) {
        protocol = 'file:';
    }
    else if (pref.startsWith('link:')) {
        protocol = 'link:';
    }
    else {
        protocol = type === 'directory' && !injected ? 'link:' : 'file:';
    }
    let fetchSpec;
    let normalizedPref;
    if (/^~[/]/.test(spec)) {
        // this is needed for windows and for file:~/foo/bar
        fetchSpec = resolvePath(os_1.default.homedir(), spec.slice(2));
        normalizedPref = `${protocol}${spec}`;
    }
    else {
        fetchSpec = resolvePath(projectDir, spec);
        if (isAbsolute(spec)) {
            normalizedPref = `${protocol}${spec}`;
        }
        else {
            normalizedPref = `${protocol}${path_1.default.relative(projectDir, fetchSpec)}`;
        }
    }
    injected = protocol === 'file:';
    const dependencyPath = injected
        ? (0, normalize_path_1.default)(path_1.default.relative(lockfileDir, fetchSpec))
        : (0, normalize_path_1.default)(path_1.default.resolve(fetchSpec));
    const id = !injected && (type === 'directory' || projectDir === lockfileDir)
        ? `${protocol}${(0, normalize_path_1.default)(path_1.default.relative(projectDir, fetchSpec))}`
        : `${protocol}${(0, normalize_path_1.default)(path_1.default.relative(lockfileDir, fetchSpec))}`;
    return {
        dependencyPath,
        fetchSpec,
        id,
        normalizedPref,
        type,
    };
}
function resolvePath(where, spec) {
    if (isAbsolutePath.test(spec))
        return spec;
    return path_1.default.resolve(where, spec);
}
function isAbsolute(dir) {
    if (dir[0] === '/')
        return true;
    if (/^[A-Za-z]:/.test(dir))
        return true;
    return false;
}
//# sourceMappingURL=parsePref.js.map