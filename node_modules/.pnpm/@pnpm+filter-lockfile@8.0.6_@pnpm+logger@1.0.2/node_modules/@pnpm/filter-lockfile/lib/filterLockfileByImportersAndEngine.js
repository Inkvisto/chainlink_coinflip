"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterLockfileByImportersAndEngine = void 0;
const constants_1 = require("@pnpm/constants");
const error_1 = require("@pnpm/error");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = require("@pnpm/logger");
const package_is_installable_1 = require("@pnpm/package-is-installable");
const dp = __importStar(require("@pnpm/dependency-path"));
const map_1 = __importDefault(require("ramda/src/map"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const unnest_1 = __importDefault(require("ramda/src/unnest"));
const filterImporter_1 = require("./filterImporter");
const lockfileLogger = (0, logger_1.logger)('lockfile');
function filterLockfileByImportersAndEngine(lockfile, importerIds, opts) {
    const importerIdSet = new Set(importerIds);
    const directDepPaths = toImporterDepPaths(lockfile, importerIds, {
        include: opts.include,
        importerIdSet,
    });
    const packages = lockfile.packages != null
        ? pickPkgsWithAllDeps(lockfile, directDepPaths, importerIdSet, {
            currentEngine: opts.currentEngine,
            engineStrict: opts.engineStrict,
            failOnMissingDependencies: opts.failOnMissingDependencies,
            include: opts.include,
            includeIncompatiblePackages: opts.includeIncompatiblePackages === true,
            lockfileDir: opts.lockfileDir,
            skipped: opts.skipped,
        })
        : {};
    const importers = (0, map_1.default)((importer) => {
        const newImporter = (0, filterImporter_1.filterImporter)(importer, opts.include);
        if (newImporter.optionalDependencies != null) {
            newImporter.optionalDependencies = (0, pickBy_1.default)((ref, depName) => {
                const depPath = dp.refToRelative(ref, depName);
                return !depPath || packages[depPath] != null;
            }, newImporter.optionalDependencies);
        }
        return newImporter;
    }, lockfile.importers);
    return {
        lockfile: {
            ...lockfile,
            importers,
            packages,
        },
        selectedImporterIds: Array.from(importerIdSet),
    };
}
exports.filterLockfileByImportersAndEngine = filterLockfileByImportersAndEngine;
function pickPkgsWithAllDeps(lockfile, depPaths, importerIdSet, opts) {
    const pickedPackages = {};
    pkgAllDeps({ lockfile, pickedPackages, importerIdSet }, depPaths, true, opts);
    return pickedPackages;
}
function pkgAllDeps(ctx, depPaths, parentIsInstallable, opts) {
    for (const depPath of depPaths) {
        if (ctx.pickedPackages[depPath])
            continue;
        const pkgSnapshot = ctx.lockfile.packages[depPath];
        if (!pkgSnapshot && !depPath.startsWith('link:')) {
            if (opts.failOnMissingDependencies) {
                throw new error_1.LockfileMissingDependencyError(depPath);
            }
            lockfileLogger.debug(`No entry for "${depPath}" in ${constants_1.WANTED_LOCKFILE}`);
            continue;
        }
        let installable;
        if (!parentIsInstallable) {
            installable = false;
            if (!ctx.pickedPackages[depPath] && pkgSnapshot.optional === true) {
                opts.skipped.add(depPath);
            }
        }
        else {
            const pkg = {
                ...(0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, pkgSnapshot),
                cpu: pkgSnapshot.cpu,
                engines: pkgSnapshot.engines,
                os: pkgSnapshot.os,
                libc: pkgSnapshot.libc,
            };
            // TODO: depPath is not the package ID. Should be fixed
            installable =
                opts.includeIncompatiblePackages ||
                    (0, package_is_installable_1.packageIsInstallable)(pkgSnapshot.id ?? depPath, pkg, {
                        engineStrict: opts.engineStrict,
                        lockfileDir: opts.lockfileDir,
                        nodeVersion: opts.currentEngine.nodeVersion,
                        optional: pkgSnapshot.optional === true,
                        pnpmVersion: opts.currentEngine.pnpmVersion,
                    }) !== false;
            if (!installable) {
                if (!ctx.pickedPackages[depPath] && pkgSnapshot.optional === true) {
                    opts.skipped.add(depPath);
                }
            }
            else {
                opts.skipped.delete(depPath);
            }
        }
        ctx.pickedPackages[depPath] = pkgSnapshot;
        const { depPaths: nextRelDepPaths, importerIds: additionalImporterIds } = parseDepRefs(Object.entries({
            ...pkgSnapshot.dependencies,
            ...(opts.include.optionalDependencies
                ? pkgSnapshot.optionalDependencies
                : {}),
        }), ctx.lockfile);
        additionalImporterIds.forEach((importerId) => ctx.importerIdSet.add(importerId));
        nextRelDepPaths.push(...toImporterDepPaths(ctx.lockfile, additionalImporterIds, {
            include: opts.include,
            importerIdSet: ctx.importerIdSet,
        }));
        pkgAllDeps(ctx, nextRelDepPaths, installable, opts);
    }
}
function toImporterDepPaths(lockfile, importerIds, opts) {
    const importerDeps = importerIds
        .map(importerId => lockfile.importers[importerId])
        .map(importer => ({
        ...(opts.include.dependencies ? importer.dependencies : {}),
        ...(opts.include.devDependencies ? importer.devDependencies : {}),
        ...(opts.include.optionalDependencies
            ? importer.optionalDependencies
            : {}),
    }))
        .map(Object.entries);
    const { depPaths, importerIds: nextImporterIds } = parseDepRefs((0, unnest_1.default)(importerDeps), lockfile);
    if (!nextImporterIds.length) {
        return depPaths;
    }
    nextImporterIds.forEach((importerId) => {
        opts.importerIdSet.add(importerId);
    });
    return [
        ...depPaths,
        ...toImporterDepPaths(lockfile, nextImporterIds, opts),
    ];
}
function parseDepRefs(refsByPkgNames, lockfile) {
    return refsByPkgNames
        .reduce((acc, [pkgName, ref]) => {
        if (ref.startsWith('link:')) {
            const importerId = ref.substring(5);
            if (lockfile.importers[importerId]) {
                acc.importerIds.push(importerId);
            }
            return acc;
        }
        const depPath = dp.refToRelative(ref, pkgName);
        if (depPath == null)
            return acc;
        acc.depPaths.push(depPath);
        return acc;
    }, { depPaths: [], importerIds: [] });
}
//# sourceMappingURL=filterLockfileByImportersAndEngine.js.map