"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryManager = exports.derive = exports.MetricName = void 0;
const tslib_1 = require("tslib");
const fslib_1 = require("@yarnpkg/fslib");
const YarnVersion_1 = require("./YarnVersion");
const hashUtils = tslib_1.__importStar(require("./hashUtils"));
const httpUtils = tslib_1.__importStar(require("./httpUtils"));
const miscUtils = tslib_1.__importStar(require("./miscUtils"));
const semverUtils = tslib_1.__importStar(require("./semverUtils"));
var MetricName;
(function (MetricName) {
    MetricName["VERSION"] = "version";
    MetricName["COMMAND_NAME"] = "commandName";
    MetricName["PLUGIN_NAME"] = "pluginName";
    MetricName["INSTALL_COUNT"] = "installCount";
    MetricName["PROJECT_COUNT"] = "projectCount";
    MetricName["WORKSPACE_COUNT"] = "workspaceCount";
    MetricName["DEPENDENCY_COUNT"] = "dependencyCount";
    MetricName["EXTENSION"] = "packageExtension";
})(MetricName || (exports.MetricName = MetricName = {}));
function derive(params) {
    var _a, _b;
    const hour = 60 * 60 * 1000;
    const day = 24 * hour;
    const nowDay = Math.floor(params.timeNow / day);
    const updateIntervalMs = params.updateInterval * day;
    const lastUpdate = (_a = params.state.lastUpdate) !== null && _a !== void 0 ? _a : params.timeNow + updateIntervalMs + Math.floor(updateIntervalMs * params.randomInitialInterval);
    const nextUpdate = lastUpdate + updateIntervalMs;
    // We reset the motd each day at 8am
    const lastMotd = (_b = params.state.lastMotd) !== null && _b !== void 0 ? _b : nowDay * day;
    const nextMotd = lastMotd + day + 8 * hour - params.timeZone;
    const triggerUpdate = nextUpdate <= params.timeNow;
    const triggerMotd = nextMotd <= params.timeNow;
    let nextState = null;
    if (triggerUpdate || triggerMotd || !params.state.lastUpdate || !params.state.lastMotd) {
        nextState = {};
        nextState.lastUpdate = triggerUpdate ? params.timeNow : lastUpdate;
        nextState.lastMotd = lastMotd;
        nextState.blocks = triggerUpdate ? {} : params.state.blocks;
        nextState.displayedMotd = params.state.displayedMotd;
    }
    return { nextState, triggerUpdate, triggerMotd, nextMotd: triggerMotd ? nowDay * day : lastMotd };
}
exports.derive = derive;
class TelemetryManager {
    constructor(configuration, accountId) {
        this.values = new Map();
        this.hits = new Map();
        this.enumerators = new Map();
        this.nextMotd = 0;
        this.displayedMotd = [];
        this.shouldCommitMotd = false;
        this.configuration = configuration;
        const registryFile = this.getRegistryPath();
        this.isNew = !fslib_1.xfs.existsSync(registryFile);
        this.isMotd = false;
        this.sendReport(accountId);
        this.startBuffer();
    }
    /**
     * Prevent the motd to be displayed today, but doesn't actually display it.
     * We use it when we replaced the motd by something else (like an upgrade prompt).
     */
    commitMotd() {
        if (this.isMotd) {
            this.shouldCommitMotd = true;
        }
    }
    selectMotd(allMotds) {
        const displayedMotd = new Set(this.displayedMotd);
        const checkVersion = (selector) => {
            if (selector && YarnVersion_1.YarnVersion) {
                return semverUtils.satisfiesWithPrereleases(YarnVersion_1.YarnVersion, selector);
            }
            else {
                return false;
            }
        };
        // Get all possible non-null messages
        const activeMotds = allMotds
            .map((_, index) => index)
            .filter(index => { var _a; return allMotds[index] && checkVersion((_a = allMotds[index]) === null || _a === void 0 ? void 0 : _a.selector); });
        if (activeMotds.length === 0)
            return null;
        // Filter out the ones that have already been displayed
        let availableMotds = activeMotds
            .filter(index => !displayedMotd.has(index));
        // If we've seen all motd, we can reset the list. We still
        // keep the last few items there, just to make sure we don't
        // immediately re-display the same motd as the last past days.
        if (availableMotds.length === 0) {
            const sliceLength = Math.floor(activeMotds.length * .2);
            this.displayedMotd = sliceLength > 0
                ? this.displayedMotd.slice(-sliceLength)
                : [];
            availableMotds = activeMotds
                .filter(index => !displayedMotd.has(index));
        }
        const selectedMotd = availableMotds[Math.floor(Math.random() * availableMotds.length)];
        this.displayedMotd.push(selectedMotd);
        this.commitMotd();
        return allMotds[selectedMotd];
    }
    reportVersion(value) {
        // We don't really care about the exact commit they're using
        this.reportValue(MetricName.VERSION, value.replace(/-git\..*/, `-git`));
    }
    reportCommandName(value) {
        this.reportValue(MetricName.COMMAND_NAME, value || `<none>`);
    }
    reportPluginName(value) {
        this.reportValue(MetricName.PLUGIN_NAME, value);
    }
    reportProject(cwd) {
        this.reportEnumerator(MetricName.PROJECT_COUNT, cwd);
    }
    reportInstall(nodeLinker) {
        this.reportHit(MetricName.INSTALL_COUNT, nodeLinker);
    }
    reportPackageExtension(value) {
        this.reportValue(MetricName.EXTENSION, value);
    }
    reportWorkspaceCount(count) {
        this.reportValue(MetricName.WORKSPACE_COUNT, String(count));
    }
    reportDependencyCount(count) {
        this.reportValue(MetricName.DEPENDENCY_COUNT, String(count));
    }
    reportValue(metric, value) {
        miscUtils.getSetWithDefault(this.values, metric).add(value);
    }
    reportEnumerator(metric, value) {
        miscUtils.getSetWithDefault(this.enumerators, metric).add(hashUtils.makeHash(value));
    }
    reportHit(metric, extra = `*`) {
        const ns = miscUtils.getMapWithDefault(this.hits, metric);
        const current = miscUtils.getFactoryWithDefault(ns, extra, () => 0);
        ns.set(extra, current + 1);
    }
    getRegistryPath() {
        const registryFile = this.configuration.get(`globalFolder`);
        return fslib_1.ppath.join(registryFile, `telemetry.json`);
    }
    sendReport(accountId) {
        var _a, _b, _c, _d;
        const registryFile = this.getRegistryPath();
        let state;
        try {
            state = fslib_1.xfs.readJsonSync(registryFile);
        }
        catch {
            state = {};
        }
        const { nextState, triggerUpdate, triggerMotd, nextMotd, } = derive({
            state,
            timeNow: Date.now(),
            timeZone: new Date().getTimezoneOffset() * 60 * 1000,
            randomInitialInterval: Math.random(),
            updateInterval: this.configuration.get(`telemetryInterval`),
        });
        this.nextMotd = nextMotd;
        this.displayedMotd = (_a = state.displayedMotd) !== null && _a !== void 0 ? _a : [];
        if (nextState !== null) {
            try {
                fslib_1.xfs.mkdirSync(fslib_1.ppath.dirname(registryFile), { recursive: true });
                fslib_1.xfs.writeJsonSync(registryFile, nextState);
            }
            catch {
                // In some cases this location is read-only. Too bad ðŸ¤·â€â™€ï¸
                return false;
            }
        }
        if (triggerMotd && this.configuration.get(`enableMotd`))
            this.isMotd = true;
        if (triggerUpdate) {
            const blocks = (_b = state.blocks) !== null && _b !== void 0 ? _b : {};
            if (Object.keys(blocks).length === 0) {
                const rawUrl = `https://browser-http-intake.logs.datadoghq.eu/v1/input/${accountId}?ddsource=yarn`;
                const sendPayload = (payload) => httpUtils.post(rawUrl, payload, {
                    configuration: this.configuration,
                }).catch(() => {
                    // Nothing we can do
                });
                for (const [userId, block] of Object.entries((_c = state.blocks) !== null && _c !== void 0 ? _c : {})) {
                    if (Object.keys(block).length === 0)
                        continue;
                    const upload = block;
                    upload.userId = userId;
                    upload.reportType = `primary`;
                    for (const key of Object.keys((_d = upload.enumerators) !== null && _d !== void 0 ? _d : {}))
                        upload.enumerators[key] = upload.enumerators[key].length;
                    sendPayload(upload);
                    // Datadog doesn't support well sending multiple tags in a single
                    // payload, so we instead send them separately, at most one value
                    // per query (we still aggregate different tags together).
                    const toSend = new Map();
                    // Also the max amount of queries (at worst once a week, remember)
                    const maxValues = 20;
                    for (const [metricName, values] of Object.entries(upload.values))
                        if (values.length > 0)
                            toSend.set(metricName, values.slice(0, maxValues));
                    while (toSend.size > 0) {
                        const upload = {};
                        upload.userId = userId;
                        upload.reportType = `secondary`;
                        upload.metrics = {};
                        for (const [metricName, values] of toSend) {
                            upload.metrics[metricName] = values.shift();
                            if (values.length === 0) {
                                toSend.delete(metricName);
                            }
                        }
                        sendPayload(upload);
                    }
                }
            }
        }
        return true;
    }
    applyChanges() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const registryFile = this.getRegistryPath();
        let state;
        try {
            state = fslib_1.xfs.readJsonSync(registryFile);
        }
        catch {
            state = {};
        }
        const userId = (_a = this.configuration.get(`telemetryUserId`)) !== null && _a !== void 0 ? _a : `*`;
        const blocks = state.blocks = (_b = state.blocks) !== null && _b !== void 0 ? _b : {};
        const block = blocks[userId] = (_c = blocks[userId]) !== null && _c !== void 0 ? _c : {};
        for (const key of this.hits.keys()) {
            const store = block.hits = (_d = block.hits) !== null && _d !== void 0 ? _d : {};
            const ns = store[key] = (_e = store[key]) !== null && _e !== void 0 ? _e : {};
            for (const [extra, value] of this.hits.get(key)) {
                ns[extra] = ((_f = ns[extra]) !== null && _f !== void 0 ? _f : 0) + value;
            }
        }
        for (const field of [`values`, `enumerators`]) {
            for (const key of this[field].keys()) {
                const store = block[field] = (_g = block[field]) !== null && _g !== void 0 ? _g : {};
                store[key] = [...new Set([
                        ...(_h = store[key]) !== null && _h !== void 0 ? _h : [],
                        ...(_j = this[field].get(key)) !== null && _j !== void 0 ? _j : [],
                    ])];
            }
        }
        if (this.shouldCommitMotd) {
            state.lastMotd = this.nextMotd;
            state.displayedMotd = this.displayedMotd;
        }
        fslib_1.xfs.mkdirSync(fslib_1.ppath.dirname(registryFile), { recursive: true });
        fslib_1.xfs.writeJsonSync(registryFile, state);
    }
    startBuffer() {
        process.on(`exit`, () => {
            try {
                this.applyChanges();
            }
            catch {
                // Explicitly ignore errors
            }
        });
    }
}
exports.TelemetryManager = TelemetryManager;
