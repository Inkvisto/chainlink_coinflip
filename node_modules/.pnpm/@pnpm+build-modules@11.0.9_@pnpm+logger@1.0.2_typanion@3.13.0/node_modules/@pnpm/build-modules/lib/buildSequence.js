"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSequence = void 0;
const graph_sequencer_1 = __importDefault(require("@pnpm/graph-sequencer"));
const filter_1 = __importDefault(require("ramda/src/filter"));
function buildSequence(depGraph, rootDepPaths) {
    const nodesToBuild = new Set();
    getSubgraphToBuild(depGraph, rootDepPaths, nodesToBuild, new Set());
    const onlyFromBuildGraph = (0, filter_1.default)((depPath) => nodesToBuild.has(depPath));
    const nodesToBuildArray = Array.from(nodesToBuild);
    const graph = new Map(nodesToBuildArray
        .map((depPath) => [depPath, onlyFromBuildGraph(Object.values(depGraph[depPath].children))]));
    const graphSequencerResult = (0, graph_sequencer_1.default)({
        graph,
        groups: [nodesToBuildArray],
    });
    const chunks = graphSequencerResult.chunks;
    return chunks;
}
exports.buildSequence = buildSequence;
function getSubgraphToBuild(graph, entryNodes, nodesToBuild, walked) {
    let currentShouldBeBuilt = false;
    for (const depPath of entryNodes) {
        const node = graph[depPath];
        if (!node)
            continue; // packages that are already in node_modules are skipped
        if (walked.has(depPath))
            continue;
        walked.add(depPath);
        const childShouldBeBuilt = getSubgraphToBuild(graph, Object.values(node.children), nodesToBuild, walked) ||
            node.requiresBuild ||
            node.patchFile != null;
        if (childShouldBeBuilt) {
            nodesToBuild.add(depPath);
            currentShouldBeBuilt = true;
        }
    }
    return currentShouldBeBuilt;
}
//# sourceMappingURL=buildSequence.js.map