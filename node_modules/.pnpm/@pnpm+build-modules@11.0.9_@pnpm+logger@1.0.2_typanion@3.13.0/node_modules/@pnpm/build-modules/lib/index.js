"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkBinsOfDependencies = exports.buildModules = void 0;
const path_1 = __importDefault(require("path"));
const calc_dep_state_1 = require("@pnpm/calc-dep-state");
const core_loggers_1 = require("@pnpm/core-loggers");
const lifecycle_1 = require("@pnpm/lifecycle");
const link_bins_1 = require("@pnpm/link-bins");
const logger_1 = require("@pnpm/logger");
const fs_hard_link_dir_1 = require("@pnpm/fs.hard-link-dir");
const read_package_json_1 = require("@pnpm/read-package-json");
const patching_apply_patch_1 = require("@pnpm/patching.apply-patch");
const p_defer_1 = __importDefault(require("p-defer"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const run_groups_1 = __importDefault(require("run-groups"));
const buildSequence_1 = require("./buildSequence");
async function buildModules(depGraph, rootDepPaths, opts) {
    const warn = (message) => {
        logger_1.logger.warn({ message, prefix: opts.lockfileDir });
    };
    // postinstall hooks
    const buildDepOpts = {
        ...opts,
        builtHoistedDeps: opts.hoistedLocations ? {} : undefined,
        warn,
    };
    const chunks = (0, buildSequence_1.buildSequence)(depGraph, rootDepPaths);
    const groups = chunks.map((chunk) => {
        chunk = chunk.filter((depPath) => {
            const node = depGraph[depPath];
            return (node.requiresBuild || node.patchFile != null) && !node.isBuilt;
        });
        if (opts.depsToBuild != null) {
            chunk = chunk.filter((depPath) => opts.depsToBuild.has(depPath));
        }
        return chunk.map((depPath) => async () => buildDependency(depPath, depGraph, buildDepOpts));
    });
    await (0, run_groups_1.default)(opts.childConcurrency ?? 4, groups);
}
exports.buildModules = buildModules;
async function buildDependency(depPath, depGraph, opts) {
    const depNode = depGraph[depPath];
    if (opts.builtHoistedDeps) {
        if (opts.builtHoistedDeps[depNode.depPath]) {
            await opts.builtHoistedDeps[depNode.depPath].promise;
            return;
        }
        opts.builtHoistedDeps[depNode.depPath] = (0, p_defer_1.default)();
    }
    try {
        await linkBinsOfDependencies(depNode, depGraph, opts);
        const isPatched = depNode.patchFile?.path != null;
        if (isPatched) {
            (0, patching_apply_patch_1.applyPatchToDir)({ patchedDir: depNode.dir, patchFilePath: depNode.patchFile.path });
        }
        const hasSideEffects = !opts.ignoreScripts && await (0, lifecycle_1.runPostinstallHooks)({
            depPath,
            extraBinPaths: opts.extraBinPaths,
            extraEnv: opts.extraEnv,
            initCwd: opts.lockfileDir,
            optional: depNode.optional,
            pkgRoot: depNode.dir,
            rawConfig: opts.rawConfig,
            rootModulesDir: opts.rootModulesDir,
            scriptsPrependNodePath: opts.scriptsPrependNodePath,
            scriptShell: opts.scriptShell,
            shellEmulator: opts.shellEmulator,
            unsafePerm: opts.unsafePerm || false,
        });
        if ((isPatched || hasSideEffects) && opts.sideEffectsCacheWrite) {
            try {
                const sideEffectsCacheKey = (0, calc_dep_state_1.calcDepState)(depGraph, opts.depsStateCache, depPath, {
                    patchFileHash: depNode.patchFile?.hash,
                    isBuilt: hasSideEffects,
                });
                await opts.storeController.upload(depNode.dir, {
                    sideEffectsCacheKey,
                    filesIndexFile: depNode.filesIndexFile,
                });
            }
            catch (err) { // eslint-disable-line
                if (err.statusCode === 403) {
                    logger_1.logger.warn({
                        message: `The store server disabled upload requests, could not upload ${depNode.dir}`,
                        prefix: opts.lockfileDir,
                    });
                }
                else {
                    logger_1.logger.warn({
                        error: err,
                        message: `An error occurred while uploading ${depNode.dir}`,
                        prefix: opts.lockfileDir,
                    });
                }
            }
        }
    }
    catch (err) { // eslint-disable-line
        if (depNode.optional) {
            // TODO: add parents field to the log
            const pkg = await (0, read_package_json_1.readPackageJsonFromDir)(path_1.default.join(depNode.dir));
            core_loggers_1.skippedOptionalDependencyLogger.debug({
                details: err.toString(),
                package: {
                    id: depNode.dir,
                    name: pkg.name,
                    version: pkg.version,
                },
                prefix: opts.lockfileDir,
                reason: 'build_failure',
            });
            return;
        }
        throw err;
    }
    finally {
        const hoistedLocationsOfDep = opts.hoistedLocations?.[depNode.depPath];
        if (hoistedLocationsOfDep) {
            // There is no need to build the same package in every location.
            // We just copy the built package to every location where it is present.
            const currentHoistedLocation = path_1.default.relative(opts.lockfileDir, depNode.dir);
            const nonBuiltHoistedDeps = hoistedLocationsOfDep?.filter((hoistedLocation) => hoistedLocation !== currentHoistedLocation);
            await (0, fs_hard_link_dir_1.hardLinkDir)(depNode.dir, nonBuiltHoistedDeps);
        }
        if (opts.builtHoistedDeps) {
            opts.builtHoistedDeps[depNode.depPath].resolve();
        }
    }
}
async function linkBinsOfDependencies(depNode, depGraph, opts) {
    const childrenToLink = opts.optional
        ? depNode.children
        : (0, pickBy_1.default)((child, childAlias) => !depNode.optionalDependencies.has(childAlias), depNode.children);
    const binPath = path_1.default.join(depNode.dir, 'node_modules/.bin');
    const pkgNodes = [
        ...Object.entries(childrenToLink)
            .map(([alias, childDepPath]) => ({ alias, dep: depGraph[childDepPath] }))
            .filter(({ alias, dep }) => {
            if (!dep) {
                // TODO: Try to reproduce this issue with a test in @pnpm/core
                logger_1.logger.debug({ message: `Failed to link bins of "${alias}" to "${binPath}". This is probably not an issue.` });
                return false;
            }
            return dep.hasBin && dep.installable !== false;
        })
            .map(({ dep }) => dep),
        depNode,
    ];
    const pkgs = await Promise.all(pkgNodes
        .map(async (dep) => ({
        location: dep.dir,
        manifest: await dep.fetchingBundledManifest?.() ?? await (0, read_package_json_1.safeReadPackageJsonFromDir)(dep.dir) ?? {},
    })));
    await (0, link_bins_1.linkBinsOfPackages)(pkgs, binPath, {
        extraNodePaths: opts.extraNodePaths,
        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
    });
    // link also the bundled dependencies` bins
    if (depNode.hasBundledDependencies) {
        const bundledModules = path_1.default.join(depNode.dir, 'node_modules');
        await (0, link_bins_1.linkBins)(bundledModules, binPath, {
            extraNodePaths: opts.extraNodePaths,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            warn: opts.warn,
        });
    }
}
exports.linkBinsOfDependencies = linkBinsOfDependencies;
//# sourceMappingURL=index.js.map