"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneLockfile = exports.pruneSharedLockfile = void 0;
const constants_1 = require("@pnpm/constants");
const dependency_path_1 = require("@pnpm/dependency-path");
const difference_1 = __importDefault(require("ramda/src/difference"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const unnest_1 = __importDefault(require("ramda/src/unnest"));
__exportStar(require("@pnpm/lockfile-types"), exports);
function pruneSharedLockfile(lockfile, opts) {
    const copiedPackages = (lockfile.packages == null)
        ? {}
        : copyPackageSnapshots(lockfile.packages, {
            devDepPaths: (0, unnest_1.default)(Object.values(lockfile.importers).map((deps) => resolvedDepsToDepPaths(deps.devDependencies ?? {}))),
            optionalDepPaths: (0, unnest_1.default)(Object.values(lockfile.importers).map((deps) => resolvedDepsToDepPaths(deps.optionalDependencies ?? {}))),
            prodDepPaths: (0, unnest_1.default)(Object.values(lockfile.importers).map((deps) => resolvedDepsToDepPaths(deps.dependencies ?? {}))),
            warn: opts?.warn ?? ((msg) => undefined),
        });
    const prunedLockfile = {
        ...lockfile,
        packages: copiedPackages,
    };
    if ((0, isEmpty_1.default)(prunedLockfile.packages)) {
        delete prunedLockfile.packages;
    }
    return prunedLockfile;
}
exports.pruneSharedLockfile = pruneSharedLockfile;
function pruneLockfile(lockfile, pkg, importerId, opts) {
    const packages = {};
    const importer = lockfile.importers[importerId];
    const lockfileSpecs = importer.specifiers ?? {};
    const optionalDependencies = Object.keys(pkg.optionalDependencies ?? {});
    const dependencies = (0, difference_1.default)(Object.keys(pkg.dependencies ?? {}), optionalDependencies);
    const devDependencies = (0, difference_1.default)((0, difference_1.default)(Object.keys(pkg.devDependencies ?? {}), optionalDependencies), dependencies);
    const allDeps = new Set([
        ...optionalDependencies,
        ...devDependencies,
        ...dependencies,
    ]);
    const specifiers = {};
    const lockfileDependencies = {};
    const lockfileOptionalDependencies = {};
    const lockfileDevDependencies = {};
    Object.entries(lockfileSpecs).forEach(([depName, spec]) => {
        if (!allDeps.has(depName))
            return;
        specifiers[depName] = spec;
        if (importer.dependencies?.[depName]) {
            lockfileDependencies[depName] = importer.dependencies[depName];
        }
        else if (importer.optionalDependencies?.[depName]) {
            lockfileOptionalDependencies[depName] = importer.optionalDependencies[depName];
        }
        else if (importer.devDependencies?.[depName]) {
            lockfileDevDependencies[depName] = importer.devDependencies[depName];
        }
    });
    if (importer.dependencies != null) {
        for (const [alias, dep] of Object.entries(importer.dependencies)) {
            if (!lockfileDependencies[alias] && dep.startsWith('link:') &&
                // If the linked dependency was removed from package.json
                // then it is removed from pnpm-lock.yaml as well
                !(lockfileSpecs[alias] && !allDeps.has(alias))) {
                lockfileDependencies[alias] = dep;
            }
        }
    }
    const updatedImporter = {
        specifiers,
    };
    const prunnedLockfile = {
        importers: {
            ...lockfile.importers,
            [importerId]: updatedImporter,
        },
        lockfileVersion: lockfile.lockfileVersion || constants_1.LOCKFILE_VERSION,
        packages: lockfile.packages,
    };
    if (!(0, isEmpty_1.default)(packages)) {
        prunnedLockfile.packages = packages;
    }
    if (!(0, isEmpty_1.default)(lockfileDependencies)) {
        updatedImporter.dependencies = lockfileDependencies;
    }
    if (!(0, isEmpty_1.default)(lockfileOptionalDependencies)) {
        updatedImporter.optionalDependencies = lockfileOptionalDependencies;
    }
    if (!(0, isEmpty_1.default)(lockfileDevDependencies)) {
        updatedImporter.devDependencies = lockfileDevDependencies;
    }
    return pruneSharedLockfile(prunnedLockfile, opts);
}
exports.pruneLockfile = pruneLockfile;
function copyPackageSnapshots(originalPackages, opts) {
    const copiedSnapshots = {};
    const ctx = {
        copiedSnapshots,
        nonOptional: new Set(),
        notProdOnly: new Set(),
        originalPackages,
        walked: new Set(),
        warn: opts.warn,
    };
    copyDependencySubGraph(ctx, opts.devDepPaths, {
        dev: true,
        optional: false,
    });
    copyDependencySubGraph(ctx, opts.optionalDepPaths, {
        dev: false,
        optional: true,
    });
    copyDependencySubGraph(ctx, opts.prodDepPaths, {
        dev: false,
        optional: false,
    });
    return copiedSnapshots;
}
function resolvedDepsToDepPaths(deps) {
    return Object.entries(deps)
        .map(([alias, ref]) => (0, dependency_path_1.refToRelative)(ref, alias))
        .filter((depPath) => depPath !== null);
}
function copyDependencySubGraph(ctx, depPaths, opts) {
    for (const depPath of depPaths) {
        const key = `${depPath}:${opts.optional.toString()}:${opts.dev.toString()}`;
        if (ctx.walked.has(key))
            continue;
        ctx.walked.add(key);
        if (!ctx.originalPackages[depPath]) {
            // local dependencies don't need to be resolved in pnpm-lock.yaml
            // except local tarball dependencies
            if (depPath.startsWith('link:') || depPath.startsWith('file:') && !depPath.endsWith('.tar.gz'))
                continue;
            ctx.warn(`Cannot find resolution of ${depPath} in lockfile`);
            continue;
        }
        const depLockfile = ctx.originalPackages[depPath];
        ctx.copiedSnapshots[depPath] = depLockfile;
        if (opts.optional && !ctx.nonOptional.has(depPath)) {
            depLockfile.optional = true;
        }
        else {
            ctx.nonOptional.add(depPath);
            delete depLockfile.optional;
        }
        if (opts.dev) {
            ctx.notProdOnly.add(depPath);
            depLockfile.dev = true;
        }
        else if (depLockfile.dev === true) { // keeping if dev is explicitly false
            delete depLockfile.dev;
        }
        else if (depLockfile.dev === undefined && !ctx.notProdOnly.has(depPath)) {
            depLockfile.dev = false;
        }
        const newDependencies = resolvedDepsToDepPaths(depLockfile.dependencies ?? {});
        copyDependencySubGraph(ctx, newDependencies, opts);
        const newOptionalDependencies = resolvedDepsToDepPaths(depLockfile.optionalDependencies ?? {});
        copyDependencySubGraph(ctx, newOptionalDependencies, { dev: opts.dev, optional: true });
    }
}
//# sourceMappingURL=index.js.map