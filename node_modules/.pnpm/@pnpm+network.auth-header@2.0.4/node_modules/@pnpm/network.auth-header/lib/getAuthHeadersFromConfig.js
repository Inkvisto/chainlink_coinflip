"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuthHeadersFromConfig = void 0;
const error_1 = require("@pnpm/error");
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const nerf_dart_1 = __importDefault(require("nerf-dart"));
function getAuthHeadersFromConfig({ allSettings, userSettings }) {
    const authHeaderValueByURI = {};
    for (const [key, value] of Object.entries(allSettings)) {
        const [uri, authType] = splitKey(key);
        switch (authType) {
            case '_authToken': {
                authHeaderValueByURI[uri] = `Bearer ${value}`;
                continue;
            }
            case '_auth': {
                authHeaderValueByURI[uri] = `Basic ${value}`;
                continue;
            }
            case 'username': {
                if (`${uri}:_password` in allSettings) {
                    const password = Buffer.from(allSettings[`${uri}:_password`], 'base64').toString('utf8');
                    authHeaderValueByURI[uri] = `Basic ${Buffer.from(`${value}:${password}`).toString('base64')}`;
                }
            }
        }
    }
    for (const [key, value] of Object.entries(userSettings)) {
        const [uri, authType] = splitKey(key);
        if (authType === 'tokenHelper') {
            authHeaderValueByURI[uri] = loadToken(value, key);
        }
    }
    const registry = allSettings['registry'] ? (0, nerf_dart_1.default)(allSettings['registry']) : '//registry.npmjs.org/';
    if (userSettings['tokenHelper']) {
        authHeaderValueByURI[registry] = loadToken(userSettings['tokenHelper'], 'tokenHelper');
    }
    else if (allSettings['_authToken']) {
        authHeaderValueByURI[registry] = `Bearer ${allSettings['_authToken']}`;
    }
    else if (allSettings['_auth']) {
        authHeaderValueByURI[registry] = `Basic ${allSettings['_auth']}`;
    }
    else if (allSettings['_password'] && allSettings['username']) {
        authHeaderValueByURI[registry] = `Basic ${Buffer.from(`${allSettings['username']}:${allSettings['_password']}`).toString('base64')}`;
    }
    return authHeaderValueByURI;
}
exports.getAuthHeadersFromConfig = getAuthHeadersFromConfig;
function splitKey(key) {
    const index = key.lastIndexOf(':');
    if (index === -1) {
        return [key, ''];
    }
    return [key.slice(0, index), key.slice(index + 1)];
}
function loadToken(helperPath, settingName) {
    if (!path_1.default.isAbsolute(helperPath) || !fs_1.default.existsSync(helperPath)) {
        throw new error_1.PnpmError('BAD_TOKEN_HELPER_PATH', `${settingName} must be an absolute path, without arguments`);
    }
    const spawnResult = (0, child_process_1.spawnSync)(helperPath, { shell: true });
    if (spawnResult.status !== 0) {
        throw new error_1.PnpmError('TOKEN_HELPER_ERROR_STATUS', `Error running "${helperPath}" as a token helper, configured as ${settingName}. Exit code ${spawnResult.status?.toString() ?? ''}`);
    }
    return spawnResult.stdout.toString('utf8').trimEnd();
}
//# sourceMappingURL=getAuthHeadersFromConfig.js.map