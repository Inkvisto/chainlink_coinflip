"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerDependencyIssuesError = exports.reportPeerDependencyIssues = void 0;
const error_1 = require("@pnpm/error");
const core_loggers_1 = require("@pnpm/core-loggers");
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
function reportPeerDependencyIssues(peerDependencyIssuesByProjects, opts) {
    if (Object.values(peerDependencyIssuesByProjects).every((peerIssuesOfProject) => (0, isEmpty_1.default)(peerIssuesOfProject.bad) && ((0, isEmpty_1.default)(peerIssuesOfProject.missing) ||
        peerIssuesOfProject.conflicts.length === 0 && Object.keys(peerIssuesOfProject.intersections).length === 0)))
        return;
    if (opts.strictPeerDependencies) {
        throw new PeerDependencyIssuesError(peerDependencyIssuesByProjects);
    }
    core_loggers_1.peerDependencyIssuesLogger.debug({
        issuesByProjects: peerDependencyIssuesByProjects,
    });
}
exports.reportPeerDependencyIssues = reportPeerDependencyIssues;
class PeerDependencyIssuesError extends error_1.PnpmError {
    constructor(issues) {
        super('PEER_DEP_ISSUES', 'Unmet peer dependencies');
        this.issuesByProjects = issues;
    }
}
exports.PeerDependencyIssuesError = PeerDependencyIssuesError;
//# sourceMappingURL=reportPeerDependencyIssues.js.map