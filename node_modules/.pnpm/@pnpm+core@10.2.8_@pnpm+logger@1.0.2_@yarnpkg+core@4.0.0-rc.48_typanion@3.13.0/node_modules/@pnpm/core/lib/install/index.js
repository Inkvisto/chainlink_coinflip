"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDependenciesToPackage = exports.createObjectChecksum = exports.mutateModules = exports.mutateModulesInSingleProject = exports.install = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = __importDefault(require("path"));
const build_modules_1 = require("@pnpm/build-modules");
const constants_1 = require("@pnpm/constants");
const core_loggers_1 = require("@pnpm/core-loggers");
const crypto_base32_hash_1 = require("@pnpm/crypto.base32-hash");
const error_1 = require("@pnpm/error");
const get_context_1 = require("@pnpm/get-context");
const headless_1 = require("@pnpm/headless");
const lifecycle_1 = require("@pnpm/lifecycle");
const link_bins_1 = require("@pnpm/link-bins");
const lockfile_file_1 = require("@pnpm/lockfile-file");
const lockfile_to_pnp_1 = require("@pnpm/lockfile-to-pnp");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = require("@pnpm/logger");
const manifest_utils_1 = require("@pnpm/manifest-utils");
const modules_yaml_1 = require("@pnpm/modules-yaml");
const read_modules_dir_1 = require("@pnpm/read-modules-dir");
const read_project_manifest_1 = require("@pnpm/read-project-manifest");
const remove_bins_1 = require("@pnpm/remove-bins");
const resolve_dependencies_1 = require("@pnpm/resolve-dependencies");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const is_inner_link_1 = __importDefault(require("is-inner-link"));
const p_filter_1 = __importDefault(require("p-filter"));
const p_limit_1 = __importDefault(require("p-limit"));
const p_map_values_1 = __importDefault(require("p-map-values"));
const flatten_1 = __importDefault(require("ramda/src/flatten"));
const map_1 = __importDefault(require("ramda/src/map"));
const clone_1 = __importDefault(require("ramda/src/clone"));
const equals_1 = __importDefault(require("ramda/src/equals"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const pipeWith_1 = __importDefault(require("ramda/src/pipeWith"));
const props_1 = __importDefault(require("ramda/src/props"));
const unnest_1 = __importDefault(require("ramda/src/unnest"));
const parseWantedDependencies_1 = require("../parseWantedDependencies");
const removeDeps_1 = require("../uninstall/removeDeps");
const allProjectsAreUpToDate_1 = require("./allProjectsAreUpToDate");
const extendInstallOptions_1 = require("./extendInstallOptions");
const getPreferredVersions_1 = require("./getPreferredVersions");
const link_1 = require("./link");
const reportPeerDependencyIssues_1 = require("./reportPeerDependencyIssues");
class LockfileConfigMismatchError extends error_1.PnpmError {
    constructor(outdatedLockfileSettingName) {
        super('LOCKFILE_CONFIG_MISMATCH', `Cannot proceed with the frozen installation. The current "${outdatedLockfileSettingName}" configuration doesn't match the value found in the lockfile`, {
            hint: 'Update your lockfile using "pnpm install --no-frozen-lockfile"',
        });
    }
}
const BROKEN_LOCKFILE_INTEGRITY_ERRORS = new Set([
    'ERR_PNPM_UNEXPECTED_PKG_CONTENT_IN_STORE',
    'ERR_PNPM_TARBALL_INTEGRITY',
]);
const DEV_PREINSTALL = 'pnpm:devPreinstall';
async function install(manifest, opts) {
    const rootDir = opts.dir ?? process.cwd();
    const { updatedProjects: projects } = await mutateModules([
        {
            mutation: 'install',
            pruneDirectDependencies: opts.pruneDirectDependencies,
            rootDir,
            update: opts.update,
            updateMatching: opts.updateMatching,
            updatePackageManifest: opts.updatePackageManifest,
        },
    ], {
        ...opts,
        allProjects: [{
                buildIndex: 0,
                manifest,
                rootDir,
            }],
    });
    return projects[0].manifest;
}
exports.install = install;
async function mutateModulesInSingleProject(project, maybeOpts) {
    const result = await mutateModules([
        {
            ...project,
            update: maybeOpts.update,
            updateMatching: maybeOpts.updateMatching,
            updatePackageManifest: maybeOpts.updatePackageManifest,
        },
    ], {
        ...maybeOpts,
        allProjects: [{
                buildIndex: 0,
                ...project,
            }],
    });
    return result.updatedProjects[0];
}
exports.mutateModulesInSingleProject = mutateModulesInSingleProject;
async function mutateModules(projects, maybeOpts) {
    const reporter = maybeOpts?.reporter;
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const opts = await (0, extendInstallOptions_1.extendOptions)(maybeOpts);
    if (!opts.include.dependencies && opts.include.optionalDependencies) {
        throw new error_1.PnpmError('OPTIONAL_DEPS_REQUIRE_PROD_DEPS', 'Optional dependencies cannot be installed without production dependencies');
    }
    const installsOnly = projects.every((project) => project.mutation === 'install' && !project.update && !project.updateMatching);
    if (!installsOnly)
        opts.strictPeerDependencies = false;
    // @ts-expect-error
    opts['forceNewModules'] = installsOnly;
    const rootProjectManifest = opts.allProjects.find(({ rootDir }) => rootDir === opts.lockfileDir)?.manifest ??
        // When running install/update on a subset of projects, the root project might not be included,
        // so reading its manifest explicitly here.
        await (0, read_project_manifest_1.safeReadProjectManifestOnly)(opts.lockfileDir);
    const ctx = await (0, get_context_1.getContext)(opts);
    if (opts.hooks.preResolution) {
        await opts.hooks.preResolution({
            currentLockfile: ctx.currentLockfile,
            wantedLockfile: ctx.wantedLockfile,
            existsCurrentLockfile: ctx.existsCurrentLockfile,
            existsNonEmptyWantedLockfile: ctx.existsNonEmptyWantedLockfile,
            lockfileDir: ctx.lockfileDir,
            storeDir: ctx.storeDir,
            registries: ctx.registries,
        });
    }
    const pruneVirtualStore = ctx.modulesFile?.prunedAt && opts.modulesCacheMaxAge > 0
        ? cacheExpired(ctx.modulesFile.prunedAt, opts.modulesCacheMaxAge)
        : true;
    if (!maybeOpts.ignorePackageManifest) {
        for (const { manifest, rootDir } of Object.values(ctx.projects)) {
            if (!manifest) {
                throw new Error(`No package.json found in "${rootDir}"`);
            }
        }
    }
    const result = await _install();
    // @ts-expect-error
    if (global['verifiedFileIntegrity'] > 1000) {
        // @ts-expect-error
        (0, logger_1.globalInfo)(`The integrity of ${global['verifiedFileIntegrity']} files was checked. This might have caused installation to take longer.`); // eslint-disable-line
    }
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    if (opts.mergeGitBranchLockfiles) {
        await (0, lockfile_file_1.cleanGitBranchLockfiles)(ctx.lockfileDir);
    }
    return {
        updatedProjects: result.updatedProjects,
        stats: result.stats ?? { added: 0, removed: 0, linkedToRoot: 0 },
    };
    async function _install() {
        const scriptsOpts = {
            extraBinPaths: opts.extraBinPaths,
            extraNodePaths: ctx.extraNodePaths,
            extraEnv: opts.extraEnv,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            rawConfig: opts.rawConfig,
            resolveSymlinksInInjectedDirs: opts.resolveSymlinksInInjectedDirs,
            scriptsPrependNodePath: opts.scriptsPrependNodePath,
            scriptShell: opts.scriptShell,
            shellEmulator: opts.shellEmulator,
            stdio: opts.ownLifecycleHooksStdio,
            storeController: opts.storeController,
            unsafePerm: opts.unsafePerm || false,
        };
        if (!opts.ignoreScripts && !opts.ignorePackageManifest && rootProjectManifest?.scripts?.[DEV_PREINSTALL]) {
            await (0, lifecycle_1.runLifecycleHook)(DEV_PREINSTALL, rootProjectManifest, {
                ...scriptsOpts,
                depPath: opts.lockfileDir,
                pkgRoot: opts.lockfileDir,
                rootModulesDir: ctx.rootModulesDir,
            });
        }
        const packageExtensionsChecksum = (0, isEmpty_1.default)(opts.packageExtensions ?? {}) ? undefined : createObjectChecksum(opts.packageExtensions);
        const patchedDependencies = opts.ignorePackageManifest
            ? ctx.wantedLockfile.patchedDependencies
            : (opts.patchedDependencies ? await calcPatchHashes(opts.patchedDependencies, opts.lockfileDir) : {});
        const patchedDependenciesWithResolvedPath = patchedDependencies
            ? (0, map_1.default)((patchFile) => ({
                hash: patchFile.hash,
                path: path_1.default.join(opts.lockfileDir, patchFile.path),
            }), patchedDependencies)
            : undefined;
        const frozenLockfile = opts.frozenLockfile ||
            opts.frozenLockfileIfExists && ctx.existsNonEmptyWantedLockfile;
        let outdatedLockfileSettings = false;
        if (!opts.ignorePackageManifest) {
            const outdatedLockfileSettingName = getOutdatedLockfileSetting(ctx.wantedLockfile, {
                autoInstallPeers: opts.autoInstallPeers,
                excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
                overrides: opts.overrides,
                neverBuiltDependencies: opts.neverBuiltDependencies,
                onlyBuiltDependencies: opts.onlyBuiltDependencies,
                packageExtensionsChecksum,
                patchedDependencies,
            });
            outdatedLockfileSettings = outdatedLockfileSettingName != null;
            if (frozenLockfile && outdatedLockfileSettings) {
                throw new LockfileConfigMismatchError(outdatedLockfileSettingName);
            }
        }
        let needsFullResolution = outdatedLockfileSettings ||
            opts.fixLockfile ||
            !ctx.wantedLockfile.lockfileVersion.toString().startsWith('6.') ||
            opts.forceFullResolution;
        if (needsFullResolution) {
            ctx.wantedLockfile.settings = {
                autoInstallPeers: opts.autoInstallPeers,
                excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
            };
            ctx.wantedLockfile.overrides = opts.overrides;
            ctx.wantedLockfile.neverBuiltDependencies = opts.neverBuiltDependencies;
            ctx.wantedLockfile.onlyBuiltDependencies = opts.onlyBuiltDependencies;
            ctx.wantedLockfile.packageExtensionsChecksum = packageExtensionsChecksum;
            ctx.wantedLockfile.patchedDependencies = patchedDependencies;
        }
        else if (!frozenLockfile) {
            ctx.wantedLockfile.settings = {
                autoInstallPeers: opts.autoInstallPeers,
                excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
            };
        }
        if (!ctx.lockfileHadConflicts &&
            !opts.fixLockfile &&
            !opts.dedupe &&
            installsOnly &&
            (frozenLockfile && !opts.lockfileOnly ||
                opts.ignorePackageManifest ||
                !needsFullResolution &&
                    opts.preferFrozenLockfile &&
                    (!opts.pruneLockfileImporters || Object.keys(ctx.wantedLockfile.importers).length === Object.keys(ctx.projects).length) &&
                    ctx.existsNonEmptyWantedLockfile &&
                    (ctx.wantedLockfile.lockfileVersion === constants_1.LOCKFILE_VERSION ||
                        ctx.wantedLockfile.lockfileVersion === constants_1.LOCKFILE_VERSION_V6 ||
                        ctx.wantedLockfile.lockfileVersion === '6.1') &&
                    await (0, allProjectsAreUpToDate_1.allProjectsAreUpToDate)(Object.values(ctx.projects), {
                        autoInstallPeers: opts.autoInstallPeers,
                        excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
                        linkWorkspacePackages: opts.linkWorkspacePackagesDepth >= 0,
                        wantedLockfile: ctx.wantedLockfile,
                        workspacePackages: opts.workspacePackages,
                        lockfileDir: opts.lockfileDir,
                    }))) {
            if (needsFullResolution) {
                throw new error_1.PnpmError('FROZEN_LOCKFILE_WITH_OUTDATED_LOCKFILE', 'Cannot perform a frozen installation because the version of the lockfile is incompatible with this version of pnpm', {
                    hint: `Try either:
1. Aligning the version of pnpm that generated the lockfile with the version that installs from it, or
2. Migrating the lockfile so that it is compatible with the newer version of pnpm, or
3. Using "pnpm install --no-frozen-lockfile".
Note that in CI environments, this setting is enabled by default.`,
                });
            }
            if (!opts.ignorePackageManifest) {
                const _satisfiesPackageManifest = lockfile_utils_1.satisfiesPackageManifest.bind(null, {
                    autoInstallPeers: opts.autoInstallPeers,
                    excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
                });
                for (const { id, manifest, rootDir } of Object.values(ctx.projects)) {
                    const { satisfies, detailedReason } = _satisfiesPackageManifest(ctx.wantedLockfile.importers[id], manifest);
                    if (!satisfies) {
                        if (!ctx.existsWantedLockfile) {
                            throw new error_1.PnpmError('NO_LOCKFILE', `Cannot install with "frozen-lockfile" because ${constants_1.WANTED_LOCKFILE} is present`, {
                                hint: 'Note that in CI environments this setting is true by default. If you still need to run install in such cases, use "pnpm install --no-frozen-lockfile"',
                            });
                        }
                        /* eslint-disable @typescript-eslint/restrict-template-expressions */
                        throw new error_1.PnpmError('OUTDATED_LOCKFILE', `Cannot install with "frozen-lockfile" because ${constants_1.WANTED_LOCKFILE} is not up to date with ` +
                            path_1.default.relative(opts.lockfileDir, path_1.default.join(rootDir, 'package.json')), {
                            hint: `Note that in CI environments this setting is true by default. If you still need to run install in such cases, use "pnpm install --no-frozen-lockfile"

    Failure reason:
    ${detailedReason ?? ''}`,
                        });
                        /* eslint-enable @typescript-eslint/restrict-template-expressions */
                    }
                }
            }
            if (opts.lockfileOnly) {
                // The lockfile will only be changed if the workspace will have new projects with no dependencies.
                await (0, lockfile_file_1.writeWantedLockfile)(ctx.lockfileDir, ctx.wantedLockfile);
                return {
                    updatedProjects: projects.map((mutatedProject) => ctx.projects[mutatedProject.rootDir]),
                };
            }
            if (!ctx.existsNonEmptyWantedLockfile) {
                if (Object.values(ctx.projects).some((project) => pkgHasDependencies(project.manifest))) {
                    throw new Error(`Headless installation requires a ${constants_1.WANTED_LOCKFILE} file`);
                }
            }
            else {
                if (maybeOpts.ignorePackageManifest) {
                    logger_1.logger.info({ message: 'Importing packages to virtual store', prefix: opts.lockfileDir });
                }
                else {
                    logger_1.logger.info({ message: 'Lockfile is up to date, resolution step is skipped', prefix: opts.lockfileDir });
                }
                try {
                    const { stats } = await (0, headless_1.headlessInstall)({
                        ...ctx,
                        ...opts,
                        currentEngine: {
                            nodeVersion: opts.nodeVersion,
                            pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
                        },
                        currentHoistedLocations: ctx.modulesFile?.hoistedLocations,
                        patchedDependencies: patchedDependenciesWithResolvedPath,
                        selectedProjectDirs: projects.map((project) => project.rootDir),
                        allProjects: ctx.projects,
                        prunedAt: ctx.modulesFile?.prunedAt,
                        pruneVirtualStore,
                        wantedLockfile: maybeOpts.ignorePackageManifest ? undefined : ctx.wantedLockfile,
                        useLockfile: opts.useLockfile && ctx.wantedLockfileIsModified,
                    });
                    if (opts.useLockfile && opts.saveLockfile && opts.mergeGitBranchLockfiles) {
                        await (0, lockfile_file_1.writeLockfiles)({
                            currentLockfile: ctx.currentLockfile,
                            currentLockfileDir: ctx.virtualStoreDir,
                            wantedLockfile: ctx.wantedLockfile,
                            wantedLockfileDir: ctx.lockfileDir,
                            forceSharedFormat: opts.forceSharedLockfile,
                            useGitBranchLockfile: opts.useGitBranchLockfile,
                            mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles,
                        });
                    }
                    return {
                        updatedProjects: projects.map((mutatedProject) => {
                            const project = ctx.projects[mutatedProject.rootDir];
                            return {
                                ...project,
                                manifest: project.originalManifest ?? project.manifest,
                            };
                        }),
                        stats,
                    };
                }
                catch (error) { // eslint-disable-line
                    if (frozenLockfile ||
                        (error.code !== 'ERR_PNPM_LOCKFILE_MISSING_DEPENDENCY' &&
                            !BROKEN_LOCKFILE_INTEGRITY_ERRORS.has(error.code)) ||
                        (!ctx.existsNonEmptyWantedLockfile && !ctx.existsCurrentLockfile))
                        throw error;
                    if (BROKEN_LOCKFILE_INTEGRITY_ERRORS.has(error.code)) {
                        needsFullResolution = true;
                        // Ideally, we would not update but currently there is no other way to redownload the integrity of the package
                        for (const project of projects) {
                            project.update = true;
                        }
                    }
                    // A broken lockfile may be caused by a badly resolved Git conflict
                    logger_1.logger.warn({
                        error,
                        message: error.message,
                        prefix: ctx.lockfileDir,
                    });
                    logger_1.logger.error(new error_1.PnpmError(error.code, 'The lockfile is broken! Resolution step will be performed to fix it.'));
                }
            }
        }
        const projectsToInstall = [];
        let preferredSpecs = null;
        // TODO: make it concurrent
        /* eslint-disable no-await-in-loop */
        for (const project of projects) {
            const projectOpts = {
                ...project,
                ...ctx.projects[project.rootDir],
            };
            switch (project.mutation) {
                case 'uninstallSome':
                    projectsToInstall.push({
                        pruneDirectDependencies: false,
                        ...projectOpts,
                        removePackages: project.dependencyNames,
                        updatePackageManifest: true,
                        wantedDependencies: [],
                    });
                    break;
                case 'install': {
                    await installCase({
                        ...projectOpts,
                        updatePackageManifest: projectOpts.updatePackageManifest ?? projectOpts.update,
                    });
                    break;
                }
                case 'installSome': {
                    await installSome({
                        ...projectOpts,
                        updatePackageManifest: projectOpts.updatePackageManifest !== false,
                    });
                    break;
                }
                case 'unlink': {
                    const packageDirs = await (0, read_modules_dir_1.readModulesDir)(projectOpts.modulesDir);
                    const externalPackages = await (0, p_filter_1.default)(packageDirs, async (packageDir) => isExternalLink(ctx.storeDir, projectOpts.modulesDir, packageDir));
                    const allDeps = (0, manifest_utils_1.getAllDependenciesFromManifest)(projectOpts.manifest);
                    const packagesToInstall = [];
                    for (const pkgName of externalPackages) {
                        await (0, rimraf_1.default)(path_1.default.join(projectOpts.modulesDir, pkgName));
                        if (allDeps[pkgName]) {
                            packagesToInstall.push(pkgName);
                        }
                    }
                    if (packagesToInstall.length === 0) {
                        return {
                            updatedProjects: projects.map((mutatedProject) => ctx.projects[mutatedProject.rootDir]),
                        };
                    }
                    // TODO: install only those that were unlinked
                    // but don't update their version specs in package.json
                    await installCase({ ...projectOpts, mutation: 'install' });
                    break;
                }
                case 'unlinkSome': {
                    if (projectOpts.manifest?.name && opts.globalBin) {
                        await (0, remove_bins_1.removeBin)(path_1.default.join(opts.globalBin, projectOpts.manifest?.name));
                    }
                    const packagesToInstall = [];
                    const allDeps = (0, manifest_utils_1.getAllDependenciesFromManifest)(projectOpts.manifest);
                    for (const depName of project.dependencyNames) {
                        try {
                            if (!await isExternalLink(ctx.storeDir, projectOpts.modulesDir, depName)) {
                                logger_1.logger.warn({
                                    message: `${depName} is not an external link`,
                                    prefix: project.rootDir,
                                });
                                continue;
                            }
                        }
                        catch (err) { // eslint-disable-line
                            if (err['code'] !== 'ENOENT')
                                throw err;
                        }
                        await (0, rimraf_1.default)(path_1.default.join(projectOpts.modulesDir, depName));
                        if (allDeps[depName]) {
                            packagesToInstall.push(depName);
                        }
                    }
                    if (packagesToInstall.length === 0) {
                        return {
                            updatedProjects: projects.map((mutatedProject) => ctx.projects[mutatedProject.rootDir]),
                        };
                    }
                    // TODO: install only those that were unlinked
                    // but don't update their version specs in package.json
                    await installSome({
                        ...projectOpts,
                        dependencySelectors: packagesToInstall,
                        mutation: 'installSome',
                        updatePackageManifest: false,
                    });
                    break;
                }
            }
        }
        /* eslint-enable no-await-in-loop */
        async function installCase(project) {
            const wantedDependencies = (0, resolve_dependencies_1.getWantedDependencies)(project.manifest, {
                autoInstallPeers: opts.autoInstallPeers,
                includeDirect: opts.includeDirect,
                updateWorkspaceDependencies: project.update,
                nodeExecPath: opts.nodeExecPath,
            })
                .map((wantedDependency) => ({ ...wantedDependency, updateSpec: true, preserveNonSemverVersionSpec: true }));
            if (ctx.wantedLockfile?.importers) {
                forgetResolutionsOfPrevWantedDeps(ctx.wantedLockfile.importers[project.id], wantedDependencies);
            }
            if (opts.ignoreScripts && project.manifest?.scripts &&
                (project.manifest.scripts.preinstall ||
                    project.manifest.scripts.install ||
                    project.manifest.scripts.postinstall ||
                    project.manifest.scripts.prepare)) {
                ctx.pendingBuilds.push(project.id);
            }
            projectsToInstall.push({
                pruneDirectDependencies: false,
                ...project,
                wantedDependencies,
            });
        }
        async function installSome(project) {
            const currentPrefs = opts.ignoreCurrentPrefs ? {} : (0, manifest_utils_1.getAllDependenciesFromManifest)(project.manifest);
            const optionalDependencies = project.targetDependenciesField ? {} : project.manifest.optionalDependencies || {};
            const devDependencies = project.targetDependenciesField ? {} : project.manifest.devDependencies || {};
            if (preferredSpecs == null) {
                preferredSpecs = (0, getPreferredVersions_1.getAllUniqueSpecs)((0, flatten_1.default)(Object.values(opts.workspacePackages).map(obj => Object.values(obj))).map(({ manifest }) => manifest));
            }
            const wantedDeps = (0, parseWantedDependencies_1.parseWantedDependencies)(project.dependencySelectors, {
                allowNew: project.allowNew !== false,
                currentPrefs,
                defaultTag: opts.tag,
                dev: project.targetDependenciesField === 'devDependencies',
                devDependencies,
                optional: project.targetDependenciesField === 'optionalDependencies',
                optionalDependencies,
                updateWorkspaceDependencies: project.update,
                preferredSpecs,
                overrides: opts.overrides,
            });
            projectsToInstall.push({
                pruneDirectDependencies: false,
                ...project,
                wantedDependencies: wantedDeps.map(wantedDep => ({ ...wantedDep, isNew: !currentPrefs[wantedDep.alias], updateSpec: true, nodeExecPath: opts.nodeExecPath })),
            });
        }
        // Unfortunately, the private lockfile may differ from the public one.
        // A user might run named installations on a project that has a pnpm-lock.yaml file before running a noop install
        const makePartialCurrentLockfile = !installsOnly && (ctx.existsNonEmptyWantedLockfile && !ctx.existsCurrentLockfile ||
            !ctx.currentLockfileIsUpToDate);
        const result = await installInContext(projectsToInstall, ctx, {
            ...opts,
            currentLockfileIsUpToDate: !ctx.existsNonEmptyWantedLockfile || ctx.currentLockfileIsUpToDate,
            makePartialCurrentLockfile,
            needsFullResolution,
            pruneVirtualStore,
            scriptsOpts,
            updateLockfileMinorVersion: true,
            patchedDependencies: patchedDependenciesWithResolvedPath,
        });
        return {
            updatedProjects: result.projects,
            stats: result.stats,
        };
    }
}
exports.mutateModules = mutateModules;
async function calcPatchHashes(patches, lockfileDir) {
    return (0, p_map_values_1.default)(async (patchFileRelativePath) => {
        const patchFilePath = path_1.default.join(lockfileDir, patchFileRelativePath);
        return {
            hash: await (0, crypto_base32_hash_1.createBase32HashFromFile)(patchFilePath),
            path: patchFileRelativePath,
        };
    }, patches);
}
function getOutdatedLockfileSetting(lockfile, { neverBuiltDependencies, onlyBuiltDependencies, overrides, packageExtensionsChecksum, patchedDependencies, autoInstallPeers, excludeLinksFromLockfile, }) {
    if (!(0, equals_1.default)(lockfile.overrides ?? {}, overrides ?? {})) {
        return 'overrides';
    }
    if (!(0, equals_1.default)((lockfile.neverBuiltDependencies ?? []).sort(), (neverBuiltDependencies ?? []).sort())) {
        return 'neverBuiltDependencies';
    }
    if (!(0, equals_1.default)(onlyBuiltDependencies?.sort(), lockfile.onlyBuiltDependencies)) {
        return 'onlyBuiltDependencies';
    }
    if (lockfile.packageExtensionsChecksum !== packageExtensionsChecksum) {
        return 'packageExtensionsChecksum';
    }
    if (!(0, equals_1.default)(lockfile.patchedDependencies ?? {}, patchedDependencies ?? {})) {
        return 'patchedDependencies';
    }
    if ((lockfile.settings?.autoInstallPeers != null && lockfile.settings.autoInstallPeers !== autoInstallPeers)) {
        return 'settings.autoInstallPeers';
    }
    if (lockfile.settings?.excludeLinksFromLockfile != null && lockfile.settings.excludeLinksFromLockfile !== excludeLinksFromLockfile) {
        return 'settings.excludeLinksFromLockfile';
    }
    return null;
}
function createObjectChecksum(obj) {
    const s = JSON.stringify(obj);
    return crypto_1.default.createHash('md5').update(s).digest('hex');
}
exports.createObjectChecksum = createObjectChecksum;
function cacheExpired(prunedAt, maxAgeInMinutes) {
    return ((Date.now() - new Date(prunedAt).valueOf()) / (1000 * 60)) > maxAgeInMinutes;
}
async function isExternalLink(storeDir, modules, pkgName) {
    const link = await (0, is_inner_link_1.default)(modules, pkgName);
    return !link.isInner;
}
function pkgHasDependencies(manifest) {
    return Boolean((Object.keys(manifest.dependencies ?? {}).length > 0) ||
        Object.keys(manifest.devDependencies ?? {}).length ||
        Object.keys(manifest.optionalDependencies ?? {}).length);
}
// If the specifier is new, the old resolution probably does not satisfy it anymore.
// By removing these resolutions we ensure that they are resolved again using the new specs.
function forgetResolutionsOfPrevWantedDeps(importer, wantedDeps) {
    if (!importer.specifiers)
        return;
    importer.dependencies = importer.dependencies ?? {};
    importer.devDependencies = importer.devDependencies ?? {};
    importer.optionalDependencies = importer.optionalDependencies ?? {};
    for (const { alias, pref } of wantedDeps) {
        if (alias && importer.specifiers[alias] !== pref) {
            if (!importer.dependencies[alias]?.startsWith('link:')) {
                delete importer.dependencies[alias];
            }
            delete importer.devDependencies[alias];
            delete importer.optionalDependencies[alias];
        }
    }
}
function forgetResolutionsOfAllPrevWantedDeps(wantedLockfile) {
    // Similar to the forgetResolutionsOfPrevWantedDeps function above, we can
    // delete existing resolutions in importers to make sure they're resolved
    // again.
    if ((wantedLockfile.importers != null) && !(0, isEmpty_1.default)(wantedLockfile.importers)) {
        wantedLockfile.importers = (0, map_1.default)(({ dependencies, devDependencies, optionalDependencies, ...rest }) => rest, wantedLockfile.importers);
    }
    // The resolveDependencies function looks at previous PackageSnapshot
    // dependencies/optionalDependencies blocks and merges them with new resolved
    // deps. Clear the previous PackageSnapshot fields so the newly resolved deps
    // are always used.
    if ((wantedLockfile.packages != null) && !(0, isEmpty_1.default)(wantedLockfile.packages)) {
        wantedLockfile.packages = (0, map_1.default)(({ dependencies, optionalDependencies, ...rest }) => rest, wantedLockfile.packages);
    }
}
async function addDependenciesToPackage(manifest, dependencySelectors, opts) {
    const rootDir = opts.dir ?? process.cwd();
    const { updatedProjects: projects } = await mutateModules([
        {
            allowNew: opts.allowNew,
            dependencySelectors,
            mutation: 'installSome',
            peer: opts.peer,
            pinnedVersion: opts.pinnedVersion,
            rootDir,
            targetDependenciesField: opts.targetDependenciesField,
            update: opts.update,
            updateMatching: opts.updateMatching,
            updatePackageManifest: opts.updatePackageManifest,
        },
    ], {
        ...opts,
        lockfileDir: opts.lockfileDir ?? opts.dir,
        allProjects: [
            {
                buildIndex: 0,
                binsDir: opts.bin,
                manifest,
                rootDir,
            },
        ],
    });
    return projects[0].manifest;
}
exports.addDependenciesToPackage = addDependenciesToPackage;
const _installInContext = async (projects, ctx, opts) => {
    if (opts.lockfileOnly && ctx.existsCurrentLockfile) {
        logger_1.logger.warn({
            message: '`node_modules` is present. Lockfile only installation will make it out-of-date',
            prefix: ctx.lockfileDir,
        });
    }
    // The wanted lockfile is mutated during installation. To compare changes, a
    // deep copy before installation is needed. This copy should represent the
    // original wanted lockfile on disk as close as possible.
    //
    // This object can be quite large. Intentionally avoiding an expensive copy
    // if no lockfileCheck option was passed in.
    const originalLockfileForCheck = opts.lockfileCheck != null
        ? (0, clone_1.default)(ctx.wantedLockfile)
        : null;
    // Aliasing for clarity in boolean expressions below.
    const isInstallationOnlyForLockfileCheck = opts.lockfileCheck != null;
    ctx.wantedLockfile.importers = ctx.wantedLockfile.importers || {};
    for (const { id } of projects) {
        if (!ctx.wantedLockfile.importers[id]) {
            ctx.wantedLockfile.importers[id] = { specifiers: {} };
        }
    }
    if (opts.pruneLockfileImporters) {
        const projectIds = new Set(projects.map(({ id }) => id));
        for (const wantedImporter of Object.keys(ctx.wantedLockfile.importers)) {
            if (!projectIds.has(wantedImporter)) {
                delete ctx.wantedLockfile.importers[wantedImporter];
            }
        }
    }
    await Promise.all(projects
        .map(async (project) => {
        if (project.mutation !== 'uninstallSome')
            return;
        const _removeDeps = async (manifest) => (0, removeDeps_1.removeDeps)(manifest, project.dependencyNames, { prefix: project.rootDir, saveType: project.targetDependenciesField });
        project.manifest = await _removeDeps(project.manifest);
        if (project.originalManifest != null) {
            project.originalManifest = await _removeDeps(project.originalManifest);
        }
    }));
    core_loggers_1.stageLogger.debug({
        prefix: ctx.lockfileDir,
        stage: 'resolution_started',
    });
    const update = projects.some((project) => project.update);
    const preferredVersions = opts.preferredVersions ?? (!update
        ? (0, getPreferredVersions_1.getPreferredVersionsFromLockfileAndManifests)(ctx.wantedLockfile.packages, Object.values(ctx.projects).map(({ manifest }) => manifest))
        : undefined);
    const forceFullResolution = ctx.wantedLockfile.lockfileVersion !== constants_1.LOCKFILE_VERSION ||
        !opts.currentLockfileIsUpToDate ||
        opts.force ||
        opts.needsFullResolution ||
        ctx.lockfileHadConflicts ||
        opts.dedupePeerDependents;
    // Ignore some fields when fixing lockfile, so these fields can be regenerated
    // and make sure it's up to date
    if (opts.fixLockfile &&
        (ctx.wantedLockfile.packages != null) &&
        !(0, isEmpty_1.default)(ctx.wantedLockfile.packages)) {
        ctx.wantedLockfile.packages = (0, map_1.default)(({ dependencies, optionalDependencies, resolution }) => ({
            // These fields are needed to avoid losing information of the locked dependencies if these fields are not broken
            // If these fields are broken, they will also be regenerated
            dependencies,
            optionalDependencies,
            resolution,
        }), ctx.wantedLockfile.packages);
    }
    if (opts.dedupe) {
        // Deleting recorded version resolutions from importers and packages. These
        // fields will be regenerated using the preferred versions computed above.
        //
        // This is a bit different from a "full resolution", which completely
        // ignores preferred versions from the lockfile.
        forgetResolutionsOfAllPrevWantedDeps(ctx.wantedLockfile);
    }
    let { dependenciesGraph, dependenciesByProjectId, finishLockfileUpdates, linkedDependenciesByProjectId, newLockfile, outdatedDependencies, peerDependencyIssuesByProjects, wantedToBeSkippedPackageIds, waitTillAllFetchingsFinish, } = await (0, resolve_dependencies_1.resolveDependencies)(projects, {
        allowBuild: createAllowBuildFunction(opts),
        allowedDeprecatedVersions: opts.allowedDeprecatedVersions,
        allowNonAppliedPatches: opts.allowNonAppliedPatches,
        autoInstallPeers: opts.autoInstallPeers,
        currentLockfile: ctx.currentLockfile,
        defaultUpdateDepth: opts.depth,
        dedupePeerDependents: opts.dedupePeerDependents,
        dryRun: opts.lockfileOnly,
        engineStrict: opts.engineStrict,
        excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
        force: opts.force,
        forceFullResolution,
        ignoreScripts: opts.ignoreScripts,
        hooks: {
            readPackage: opts.readPackageHook,
        },
        linkWorkspacePackagesDepth: opts.linkWorkspacePackagesDepth ?? (opts.saveWorkspaceProtocol ? 0 : -1),
        lockfileDir: opts.lockfileDir,
        nodeVersion: opts.nodeVersion,
        pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
        preferWorkspacePackages: opts.preferWorkspacePackages,
        preferredVersions,
        preserveWorkspaceProtocol: opts.preserveWorkspaceProtocol,
        registries: ctx.registries,
        resolutionMode: opts.resolutionMode,
        saveWorkspaceProtocol: opts.saveWorkspaceProtocol,
        storeController: opts.storeController,
        tag: opts.tag,
        virtualStoreDir: ctx.virtualStoreDir,
        wantedLockfile: ctx.wantedLockfile,
        workspacePackages: opts.workspacePackages,
        patchedDependencies: opts.patchedDependencies,
        lockfileIncludeTarballUrl: opts.lockfileIncludeTarballUrl,
        resolvePeersFromWorkspaceRoot: opts.resolvePeersFromWorkspaceRoot,
    });
    if (!opts.include.optionalDependencies || !opts.include.devDependencies || !opts.include.dependencies) {
        linkedDependenciesByProjectId = (0, map_1.default)((linkedDeps) => linkedDeps.filter((linkedDep) => !(linkedDep.dev && !opts.include.devDependencies ||
            linkedDep.optional && !opts.include.optionalDependencies ||
            !linkedDep.dev && !linkedDep.optional && !opts.include.dependencies)), linkedDependenciesByProjectId ?? {});
        for (const { id, manifest } of projects) {
            dependenciesByProjectId[id] = (0, pickBy_1.default)((depPath) => {
                const dep = dependenciesGraph[depPath];
                if (!dep)
                    return false;
                const isDev = Boolean(manifest.devDependencies?.[dep.name]);
                const isOptional = Boolean(manifest.optionalDependencies?.[dep.name]);
                return !(isDev && !opts.include.devDependencies ||
                    isOptional && !opts.include.optionalDependencies ||
                    !isDev && !isOptional && !opts.include.dependencies);
            }, dependenciesByProjectId[id]);
        }
    }
    core_loggers_1.stageLogger.debug({
        prefix: ctx.lockfileDir,
        stage: 'resolution_done',
    });
    newLockfile = ((opts.hooks?.afterAllResolved) != null)
        ? await (0, pipeWith_1.default)(async (f, res) => f(await res), opts.hooks.afterAllResolved)(newLockfile) // eslint-disable-line
        : newLockfile;
    if (opts.updateLockfileMinorVersion) {
        newLockfile.lockfileVersion = constants_1.LOCKFILE_VERSION_V6;
    }
    const depsStateCache = {};
    const lockfileOpts = {
        forceSharedFormat: opts.forceSharedLockfile,
        useInlineSpecifiersFormat: true,
        useGitBranchLockfile: opts.useGitBranchLockfile,
        mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles,
    };
    let stats;
    if (!opts.lockfileOnly && !isInstallationOnlyForLockfileCheck && opts.enableModulesDir) {
        const result = await (0, link_1.linkPackages)(projects, dependenciesGraph, {
            currentLockfile: ctx.currentLockfile,
            dedupeDirectDeps: opts.dedupeDirectDeps,
            dependenciesByProjectId,
            depsStateCache,
            extraNodePaths: ctx.extraNodePaths,
            force: opts.force,
            hoistedDependencies: ctx.hoistedDependencies,
            hoistedModulesDir: ctx.hoistedModulesDir,
            hoistPattern: ctx.hoistPattern,
            ignoreScripts: opts.ignoreScripts,
            include: opts.include,
            linkedDependenciesByProjectId,
            lockfileDir: opts.lockfileDir,
            makePartialCurrentLockfile: opts.makePartialCurrentLockfile,
            outdatedDependencies,
            pruneStore: opts.pruneStore,
            pruneVirtualStore: opts.pruneVirtualStore,
            publicHoistPattern: ctx.publicHoistPattern,
            registries: ctx.registries,
            rootModulesDir: ctx.rootModulesDir,
            sideEffectsCacheRead: opts.sideEffectsCacheRead,
            symlink: opts.symlink,
            skipped: ctx.skipped,
            storeController: opts.storeController,
            virtualStoreDir: ctx.virtualStoreDir,
            wantedLockfile: newLockfile,
            wantedToBeSkippedPackageIds,
        });
        stats = result.stats;
        await finishLockfileUpdates();
        if (opts.enablePnp) {
            const importerNames = Object.fromEntries(projects.map(({ manifest, id }) => [id, manifest.name ?? id]));
            await (0, lockfile_to_pnp_1.writePnpFile)(result.currentLockfile, {
                importerNames,
                lockfileDir: ctx.lockfileDir,
                virtualStoreDir: ctx.virtualStoreDir,
                registries: ctx.registries,
            });
        }
        ctx.pendingBuilds = ctx.pendingBuilds
            .filter((relDepPath) => !result.removedDepPaths.has(relDepPath));
        if (result.newDepPaths?.length) {
            if (opts.ignoreScripts) {
                // we can use concat here because we always only append new packages, which are guaranteed to not be there by definition
                ctx.pendingBuilds = ctx.pendingBuilds
                    .concat(await (0, p_filter_1.default)(result.newDepPaths, (depPath) => {
                    const requiresBuild = dependenciesGraph[depPath].requiresBuild;
                    if (typeof requiresBuild === 'function')
                        return requiresBuild();
                    return requiresBuild;
                }));
            }
            if (!opts.ignoreScripts || Object.keys(opts.patchedDependencies ?? {}).length > 0) {
                // postinstall hooks
                const depPaths = Object.keys(dependenciesGraph);
                const rootNodes = depPaths.filter((depPath) => dependenciesGraph[depPath].depth === 0);
                let extraEnv = opts.scriptsOpts.extraEnv;
                if (opts.enablePnp) {
                    extraEnv = {
                        ...extraEnv,
                        ...(0, lifecycle_1.makeNodeRequireOption)(path_1.default.join(opts.lockfileDir, '.pnp.cjs')),
                    };
                }
                await (0, build_modules_1.buildModules)(dependenciesGraph, rootNodes, {
                    childConcurrency: opts.childConcurrency,
                    depsStateCache,
                    depsToBuild: new Set(result.newDepPaths),
                    extraBinPaths: ctx.extraBinPaths,
                    extraNodePaths: ctx.extraNodePaths,
                    extraEnv,
                    ignoreScripts: opts.ignoreScripts || opts.ignoreDepScripts,
                    lockfileDir: ctx.lockfileDir,
                    optional: opts.include.optionalDependencies,
                    preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                    rawConfig: opts.rawConfig,
                    rootModulesDir: ctx.virtualStoreDir,
                    scriptsPrependNodePath: opts.scriptsPrependNodePath,
                    scriptShell: opts.scriptShell,
                    shellEmulator: opts.shellEmulator,
                    sideEffectsCacheWrite: opts.sideEffectsCacheWrite,
                    storeController: opts.storeController,
                    unsafePerm: opts.unsafePerm,
                    userAgent: opts.userAgent,
                });
            }
        }
        const binWarn = (prefix, message) => {
            logger_1.logger.info({ message, prefix });
        };
        if (result.newDepPaths?.length) {
            const newPkgs = (0, props_1.default)(result.newDepPaths, dependenciesGraph);
            await linkAllBins(newPkgs, dependenciesGraph, {
                extraNodePaths: ctx.extraNodePaths,
                optional: opts.include.optionalDependencies,
                warn: binWarn.bind(null, opts.lockfileDir),
            });
        }
        await Promise.all(projects.map(async (project, index) => {
            let linkedPackages;
            if (ctx.publicHoistPattern?.length && path_1.default.relative(project.rootDir, opts.lockfileDir) === '') {
                const nodeExecPathByAlias = Object.entries(project.manifest.dependenciesMeta ?? {})
                    .reduce((prev, [alias, { node }]) => {
                    if (node) {
                        prev[alias] = node;
                    }
                    return prev;
                }, {});
                linkedPackages = await (0, link_bins_1.linkBins)(project.modulesDir, project.binsDir, {
                    allowExoticManifests: true,
                    preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                    projectManifest: project.manifest,
                    nodeExecPathByAlias,
                    extraNodePaths: ctx.extraNodePaths,
                    warn: binWarn.bind(null, project.rootDir),
                });
            }
            else {
                const directPkgs = [
                    ...(0, props_1.default)(Object.values(dependenciesByProjectId[project.id]).filter((depPath) => !ctx.skipped.has(depPath)), dependenciesGraph),
                    ...linkedDependenciesByProjectId[project.id].map(({ pkgId }) => ({
                        dir: path_1.default.join(project.rootDir, pkgId.substring(5)),
                        fetchingBundledManifest: undefined,
                    })),
                ];
                linkedPackages = await (0, link_bins_1.linkBinsOfPackages)((await Promise.all(directPkgs.map(async (dep) => {
                    const manifest = await dep.fetchingBundledManifest?.() ?? await (0, read_project_manifest_1.safeReadProjectManifestOnly)(dep.dir);
                    let nodeExecPath;
                    if (manifest?.name) {
                        nodeExecPath = project.manifest.dependenciesMeta?.[manifest.name]?.node;
                    }
                    return {
                        location: dep.dir,
                        manifest,
                        nodeExecPath,
                    };
                })))
                    .filter(({ manifest }) => manifest != null), project.binsDir, {
                    extraNodePaths: ctx.extraNodePaths,
                    preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                });
            }
            const projectToInstall = projects[index];
            if (opts.global && projectToInstall.mutation.includes('install')) {
                projectToInstall.wantedDependencies.forEach(pkg => {
                    if (!linkedPackages?.includes(pkg.alias)) {
                        logger_1.logger.warn({ message: `${pkg.alias ?? pkg.pref} has no binaries`, prefix: opts.lockfileDir });
                    }
                });
            }
        }));
        const projectsWithTargetDirs = (0, lockfile_utils_1.extendProjectsWithTargetDirs)(projects, newLockfile, ctx);
        await Promise.all([
            opts.useLockfile && opts.saveLockfile
                ? (0, lockfile_file_1.writeLockfiles)({
                    currentLockfile: result.currentLockfile,
                    currentLockfileDir: ctx.virtualStoreDir,
                    wantedLockfile: newLockfile,
                    wantedLockfileDir: ctx.lockfileDir,
                    ...lockfileOpts,
                })
                : (0, lockfile_file_1.writeCurrentLockfile)(ctx.virtualStoreDir, result.currentLockfile, lockfileOpts),
            (async () => {
                if (result.currentLockfile.packages === undefined && result.removedDepPaths.size === 0) {
                    return Promise.resolve();
                }
                const injectedDeps = {};
                for (const project of projectsWithTargetDirs) {
                    if (project.targetDirs.length > 0) {
                        injectedDeps[project.id] = project.targetDirs.map((targetDir) => path_1.default.relative(opts.lockfileDir, targetDir));
                    }
                }
                return (0, modules_yaml_1.writeModulesManifest)(ctx.rootModulesDir, {
                    ...ctx.modulesFile,
                    hoistedDependencies: result.newHoistedDependencies,
                    hoistPattern: ctx.hoistPattern,
                    included: ctx.include,
                    injectedDeps,
                    layoutVersion: constants_1.LAYOUT_VERSION,
                    nodeLinker: opts.nodeLinker,
                    packageManager: `${opts.packageManager.name}@${opts.packageManager.version}`,
                    pendingBuilds: ctx.pendingBuilds,
                    publicHoistPattern: ctx.publicHoistPattern,
                    prunedAt: opts.pruneVirtualStore || ctx.modulesFile == null
                        ? new Date().toUTCString()
                        : ctx.modulesFile.prunedAt,
                    registries: ctx.registries,
                    skipped: Array.from(ctx.skipped),
                    storeDir: ctx.storeDir,
                    virtualStoreDir: ctx.virtualStoreDir,
                }, {
                    makeModulesDir: Object.keys(result.currentLockfile.packages ?? {}).length > 0,
                });
            })(),
        ]);
        if (!opts.ignoreScripts) {
            if (opts.enablePnp) {
                opts.scriptsOpts.extraEnv = {
                    ...opts.scriptsOpts.extraEnv,
                    ...(0, lifecycle_1.makeNodeRequireOption)(path_1.default.join(opts.lockfileDir, '.pnp.cjs')),
                };
            }
            const projectsToBeBuilt = projectsWithTargetDirs.filter(({ mutation }) => mutation === 'install');
            await (0, lifecycle_1.runLifecycleHooksConcurrently)(['preinstall', 'install', 'postinstall', 'prepare'], projectsToBeBuilt, opts.childConcurrency, opts.scriptsOpts);
        }
    }
    else {
        await finishLockfileUpdates();
        if (opts.useLockfile && !isInstallationOnlyForLockfileCheck) {
            await (0, lockfile_file_1.writeWantedLockfile)(ctx.lockfileDir, newLockfile, lockfileOpts);
        }
        if (opts.nodeLinker !== 'hoisted') {
            // This is only needed because otherwise the reporter will hang
            core_loggers_1.stageLogger.debug({
                prefix: opts.lockfileDir,
                stage: 'importing_done',
            });
        }
    }
    await waitTillAllFetchingsFinish();
    core_loggers_1.summaryLogger.debug({ prefix: opts.lockfileDir });
    await opts.storeController.close();
    (0, reportPeerDependencyIssues_1.reportPeerDependencyIssues)(peerDependencyIssuesByProjects, {
        lockfileDir: opts.lockfileDir,
        strictPeerDependencies: opts.strictPeerDependencies,
    });
    // Similar to the sequencing for when the original wanted lockfile is
    // copied, the new lockfile passed here should be as close as possible to
    // what will eventually be written to disk. Ex: peers should be resolved,
    // the afterAllResolved hook has been applied, etc.
    if (originalLockfileForCheck != null) {
        opts.lockfileCheck?.(originalLockfileForCheck, newLockfile);
    }
    return {
        newLockfile,
        projects: projects.map(({ id, manifest, rootDir }) => ({
            manifest,
            peerDependencyIssues: peerDependencyIssuesByProjects[id],
            rootDir,
        })),
        stats,
    };
};
function createAllowBuildFunction(opts) {
    if (opts.neverBuiltDependencies != null && opts.neverBuiltDependencies.length > 0) {
        const neverBuiltDependencies = new Set(opts.neverBuiltDependencies);
        return (pkgName) => !neverBuiltDependencies.has(pkgName);
    }
    else if (opts.onlyBuiltDependencies != null) {
        const onlyBuiltDependencies = new Set(opts.onlyBuiltDependencies);
        return (pkgName) => onlyBuiltDependencies.has(pkgName);
    }
    return undefined;
}
const installInContext = async (projects, ctx, opts) => {
    try {
        if (opts.nodeLinker === 'hoisted' && !opts.lockfileOnly) {
            const result = await _installInContext(projects, ctx, {
                ...opts,
                lockfileOnly: true,
            });
            const { stats } = await (0, headless_1.headlessInstall)({
                ...ctx,
                ...opts,
                currentEngine: {
                    nodeVersion: opts.nodeVersion,
                    pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
                },
                currentHoistedLocations: ctx.modulesFile?.hoistedLocations,
                selectedProjectDirs: projects.map((project) => project.rootDir),
                allProjects: ctx.projects,
                prunedAt: ctx.modulesFile?.prunedAt,
                wantedLockfile: result.newLockfile,
                useLockfile: opts.useLockfile && ctx.wantedLockfileIsModified,
            });
            return {
                ...result,
                stats,
            };
        }
        return await _installInContext(projects, ctx, opts);
    }
    catch (error) { // eslint-disable-line
        if (!BROKEN_LOCKFILE_INTEGRITY_ERRORS.has(error.code) ||
            (!ctx.existsNonEmptyWantedLockfile && !ctx.existsCurrentLockfile))
            throw error;
        opts.needsFullResolution = true;
        // Ideally, we would not update but currently there is no other way to redownload the integrity of the package
        for (const project of projects) {
            project.update = true;
        }
        logger_1.logger.warn({
            error,
            message: error.message,
            prefix: ctx.lockfileDir,
        });
        logger_1.logger.error(new error_1.PnpmError(error.code, 'The lockfile is broken! A full installation will be performed in an attempt to fix it.'));
        return _installInContext(projects, ctx, opts);
    }
};
const limitLinking = (0, p_limit_1.default)(16);
async function linkAllBins(depNodes, depGraph, opts) {
    return (0, unnest_1.default)(await Promise.all(depNodes.map(async (depNode) => limitLinking(async () => (0, build_modules_1.linkBinsOfDependencies)(depNode, depGraph, opts)))));
}
//# sourceMappingURL=index.js.map