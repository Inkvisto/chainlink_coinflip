"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.link = void 0;
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = require("@pnpm/error");
const get_context_1 = require("@pnpm/get-context");
const link_bins_1 = require("@pnpm/link-bins");
const lockfile_file_1 = require("@pnpm/lockfile-file");
const logger_1 = require("@pnpm/logger");
const manifest_utils_1 = require("@pnpm/manifest-utils");
const prune_lockfile_1 = require("@pnpm/prune-lockfile");
const read_project_manifest_1 = require("@pnpm/read-project-manifest");
const symlink_dependency_1 = require("@pnpm/symlink-dependency");
const types_1 = require("@pnpm/types");
const normalize_path_1 = __importDefault(require("normalize-path"));
const options_1 = require("./options");
async function link(linkFromPkgs, destModules, maybeOpts) {
    const reporter = maybeOpts?.reporter;
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const opts = await (0, options_1.extendOptions)(maybeOpts);
    const ctx = await (0, get_context_1.getContextForSingleImporter)(opts.manifest, {
        ...opts,
        extraBinPaths: [], // ctx.extraBinPaths is not needed, so this is fine
    }, true);
    const importerId = (0, lockfile_file_1.getLockfileImporterId)(ctx.lockfileDir, opts.dir);
    const specsToUpsert = [];
    const linkedPkgs = await Promise.all(linkFromPkgs.map(async (linkFrom) => {
        let linkFromPath;
        let linkFromAlias;
        if (typeof linkFrom === 'string') {
            linkFromPath = linkFrom;
        }
        else {
            linkFromPath = linkFrom.path;
            linkFromAlias = linkFrom.alias;
        }
        const { manifest } = await (0, read_project_manifest_1.readProjectManifest)(linkFromPath);
        if (typeof linkFrom === 'string' && manifest.name === undefined) {
            throw new error_1.PnpmError('INVALID_PACKAGE_NAME', `Package in ${linkFromPath} must have a name field to be linked`);
        }
        const targetDependencyType = (0, manifest_utils_1.getDependencyTypeFromManifest)(opts.manifest, manifest.name) ?? opts.targetDependenciesField;
        specsToUpsert.push({
            alias: manifest.name,
            pref: (0, manifest_utils_1.getPref)(manifest.name, manifest.name, manifest.version, {
                pinnedVersion: opts.pinnedVersion,
            }),
            saveType: (targetDependencyType ?? (ctx.manifest && (0, manifest_utils_1.guessDependencyType)(manifest.name, ctx.manifest))),
        });
        const packagePath = (0, normalize_path_1.default)(path_1.default.relative(opts.dir, linkFromPath));
        const addLinkOpts = {
            linkedPkgName: linkFromAlias ?? manifest.name,
            manifest: ctx.manifest,
            packagePath,
        };
        addLinkToLockfile(ctx.currentLockfile.importers[importerId], addLinkOpts);
        addLinkToLockfile(ctx.wantedLockfile.importers[importerId], addLinkOpts);
        return {
            alias: linkFromAlias ?? manifest.name,
            manifest,
            path: linkFromPath,
        };
    }));
    const updatedCurrentLockfile = (0, prune_lockfile_1.pruneSharedLockfile)(ctx.currentLockfile);
    const warn = (message) => {
        logger_1.logger.warn({ message, prefix: opts.dir });
    };
    const updatedWantedLockfile = (0, prune_lockfile_1.pruneSharedLockfile)(ctx.wantedLockfile, { warn });
    // Linking should happen after removing orphans
    // Otherwise would've been removed
    await Promise.all(linkedPkgs.map(async ({ alias, manifest, path }) => {
        // TODO: cover with test that linking reports with correct dependency types
        const stu = specsToUpsert.find((s) => s.alias === manifest.name);
        const targetDependencyType = (0, manifest_utils_1.getDependencyTypeFromManifest)(opts.manifest, manifest.name) ?? opts.targetDependenciesField;
        await (0, symlink_dependency_1.symlinkDirectRootDependency)(path, destModules, alias, {
            fromDependenciesField: stu?.saveType ?? targetDependencyType,
            linkedPackage: manifest,
            prefix: opts.dir,
        });
    }));
    const linkToBin = maybeOpts?.linkToBin ?? path_1.default.join(destModules, '.bin');
    await (0, link_bins_1.linkBinsOfPackages)(linkedPkgs.map((p) => ({ manifest: p.manifest, location: p.path })), linkToBin, {
        extraNodePaths: ctx.extraNodePaths,
        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
    });
    let newPkg;
    if (opts.targetDependenciesField) {
        newPkg = await (0, manifest_utils_1.updateProjectManifestObject)(opts.dir, opts.manifest, specsToUpsert);
        for (const { alias } of specsToUpsert) {
            updatedWantedLockfile.importers[importerId].specifiers[alias] = (0, manifest_utils_1.getSpecFromPackageManifest)(newPkg, alias);
        }
    }
    else {
        newPkg = opts.manifest;
    }
    const lockfileOpts = { forceSharedFormat: opts.forceSharedLockfile, useGitBranchLockfile: opts.useGitBranchLockfile, mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles };
    if (opts.useLockfile) {
        await (0, lockfile_file_1.writeLockfiles)({
            currentLockfile: updatedCurrentLockfile,
            currentLockfileDir: ctx.virtualStoreDir,
            wantedLockfile: updatedWantedLockfile,
            wantedLockfileDir: ctx.lockfileDir,
            ...lockfileOpts,
        });
    }
    else {
        await (0, lockfile_file_1.writeCurrentLockfile)(ctx.virtualStoreDir, updatedCurrentLockfile, lockfileOpts);
    }
    core_loggers_1.summaryLogger.debug({ prefix: opts.dir });
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return newPkg;
}
exports.link = link;
function addLinkToLockfile(projectSnapshot, opts) {
    const id = `link:${opts.packagePath}`;
    let addedTo;
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (!addedTo && opts.manifest?.[depType]?.[opts.linkedPkgName]) {
            addedTo = depType;
            projectSnapshot[depType] = projectSnapshot[depType] ?? {};
            projectSnapshot[depType][opts.linkedPkgName] = id;
        }
        else if (projectSnapshot[depType] != null) {
            delete projectSnapshot[depType][opts.linkedPkgName];
        }
    }
    // package.json might not be available when linking to global
    if (opts.manifest == null)
        return;
    const availableSpec = (0, manifest_utils_1.getSpecFromPackageManifest)(opts.manifest, opts.linkedPkgName);
    if (availableSpec) {
        projectSnapshot.specifiers[opts.linkedPkgName] = availableSpec;
    }
    else {
        delete projectSnapshot.specifiers[opts.linkedPkgName];
    }
}
//# sourceMappingURL=index.js.map