"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackageRequester = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const cafs_1 = require("@pnpm/cafs");
const core_loggers_1 = require("@pnpm/core-loggers");
const pick_fetcher_1 = require("@pnpm/pick-fetcher");
const error_1 = require("@pnpm/error");
const graceful_fs_1 = __importDefault(require("@pnpm/graceful-fs"));
const logger_1 = require("@pnpm/logger");
const package_is_installable_1 = require("@pnpm/package-is-installable");
const read_package_json_1 = require("@pnpm/read-package-json");
const dependency_path_1 = require("@pnpm/dependency-path");
const p_map_values_1 = __importDefault(require("p-map-values"));
const p_queue_1 = __importDefault(require("p-queue"));
const load_json_file_1 = __importDefault(require("load-json-file"));
const p_defer_1 = __importDefault(require("p-defer"));
const path_temp_1 = __importDefault(require("path-temp"));
const promise_share_1 = __importDefault(require("promise-share"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const rename_overwrite_1 = __importDefault(require("rename-overwrite"));
const semver_1 = __importDefault(require("semver"));
const ssri_1 = __importDefault(require("ssri"));
const equalOrSemverEqual_1 = require("./equalOrSemverEqual");
const safe_promise_defer_1 = __importDefault(require("safe-promise-defer"));
const TARBALL_INTEGRITY_FILENAME = 'tarball-integrity';
const packageRequestLogger = (0, logger_1.logger)('package-requester');
const pickBundledManifest = (0, pick_1.default)([
    'bin',
    'bundledDependencies',
    'bundleDependencies',
    'dependencies',
    'directories',
    'engines',
    'name',
    'optionalDependencies',
    'os',
    'peerDependencies',
    'peerDependenciesMeta',
    'scripts',
    'version',
]);
function normalizeBundledManifest(manifest) {
    return {
        ...pickBundledManifest(manifest),
        version: semver_1.default.clean(manifest.version ?? '0.0.0', { loose: true }) ?? manifest.version,
    };
}
function createPackageRequester(opts) {
    opts = opts || {};
    const networkConcurrency = opts.networkConcurrency ?? 16;
    const requestsQueue = new p_queue_1.default({
        concurrency: networkConcurrency,
    });
    const cafsDir = path_1.default.join(opts.storeDir, 'files');
    const getFilePathInCafs = cafs_1.getFilePathInCafs.bind(null, cafsDir);
    const fetch = fetcher.bind(null, opts.fetchers, opts.cafs);
    const fetchPackageToStore = fetchToStore.bind(null, {
        // If verifyStoreIntegrity is false we skip the integrity checks of all files
        // and only read the package manifest.
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-boolean-literal-compare
        checkFilesIntegrity: opts.verifyStoreIntegrity === false
            ? cafs_1.readManifestFromStore.bind(null, cafsDir)
            : cafs_1.checkPkgFilesIntegrity.bind(null, cafsDir),
        fetch,
        fetchingLocker: new Map(),
        getFilePathByModeInCafs: cafs_1.getFilePathByModeInCafs.bind(null, cafsDir),
        getFilePathInCafs,
        requestsQueue: Object.assign(requestsQueue, {
            counter: 0,
            concurrency: networkConcurrency,
        }),
        storeDir: opts.storeDir,
    });
    const requestPackage = resolveAndFetch.bind(null, {
        engineStrict: opts.engineStrict,
        nodeVersion: opts.nodeVersion,
        pnpmVersion: opts.pnpmVersion,
        force: opts.force,
        fetchPackageToStore,
        requestsQueue,
        resolve: opts.resolve,
        storeDir: opts.storeDir,
    });
    return Object.assign(requestPackage, {
        fetchPackageToStore,
        getFilesIndexFilePath: getFilesIndexFilePath.bind(null, {
            getFilePathInCafs,
            storeDir: opts.storeDir,
        }),
        requestPackage,
    });
}
exports.createPackageRequester = createPackageRequester;
async function resolveAndFetch(ctx, wantedDependency, options) {
    let latest;
    let manifest;
    let normalizedPref;
    let resolution = options.currentPkg?.resolution;
    let pkgId = options.currentPkg?.id;
    const skipResolution = resolution && !options.update;
    let forceFetch = false;
    let updated = false;
    let resolvedVia;
    let publishedAt;
    // When fetching is skipped, resolution cannot be skipped.
    // We need the package's manifest when doing `lockfile-only` installs.
    // When we don't fetch, the only way to get the package's manifest is via resolving it.
    //
    // The resolution step is never skipped for local dependencies.
    if (!skipResolution || options.skipFetch === true || Boolean(pkgId?.startsWith('file:')) || wantedDependency.optional === true) {
        const resolveResult = await ctx.requestsQueue.add(async () => ctx.resolve(wantedDependency, {
            alwaysTryWorkspacePackages: options.alwaysTryWorkspacePackages,
            defaultTag: options.defaultTag,
            publishedBy: options.publishedBy,
            pickLowestVersion: options.pickLowestVersion,
            lockfileDir: options.lockfileDir,
            preferredVersions: options.preferredVersions,
            preferWorkspacePackages: options.preferWorkspacePackages,
            projectDir: options.projectDir,
            registry: options.registry,
            workspacePackages: options.workspacePackages,
        }), { priority: options.downloadPriority });
        manifest = resolveResult.manifest;
        latest = resolveResult.latest;
        resolvedVia = resolveResult.resolvedVia;
        publishedAt = resolveResult.publishedAt;
        // If the integrity of a local tarball dependency has changed,
        // the local tarball should be unpacked, so a fetch to the store should be forced
        forceFetch = Boolean(((options.currentPkg?.resolution) != null) &&
            pkgId?.startsWith('file:') &&
            (options.currentPkg?.resolution).integrity !== resolveResult.resolution.integrity);
        updated = pkgId !== resolveResult.id || !resolution || forceFetch;
        resolution = resolveResult.resolution;
        pkgId = resolveResult.id;
        normalizedPref = resolveResult.normalizedPref;
    }
    const id = pkgId;
    if (resolution.type === 'directory' && !id.startsWith('file:')) {
        if (manifest == null) {
            throw new Error(`Couldn't read package.json of local dependency ${wantedDependency.alias ? wantedDependency.alias + '@' : ''}${wantedDependency.pref ?? ''}`);
        }
        return {
            body: {
                id,
                isLocal: true,
                manifest,
                normalizedPref,
                resolution: resolution,
                resolvedVia,
                updated,
            },
        };
    }
    const isInstallable = (ctx.force === true ||
        (manifest == null
            ? undefined
            : (0, package_is_installable_1.packageIsInstallable)(id, manifest, {
                engineStrict: ctx.engineStrict,
                lockfileDir: options.lockfileDir,
                nodeVersion: ctx.nodeVersion,
                optional: wantedDependency.optional === true,
                pnpmVersion: ctx.pnpmVersion,
            })));
    // We can skip fetching the package only if the manifest
    // is present after resolution
    if ((options.skipFetch === true || isInstallable === false) && (manifest != null)) {
        return {
            body: {
                id,
                isLocal: false,
                isInstallable: isInstallable ?? undefined,
                latest,
                manifest,
                normalizedPref,
                resolution,
                resolvedVia,
                updated,
                publishedAt,
            },
        };
    }
    const pkg = (0, pick_1.default)(['name', 'version'], manifest ?? {});
    const fetchResult = ctx.fetchPackageToStore({
        fetchRawManifest: true,
        force: forceFetch,
        ignoreScripts: options.ignoreScripts,
        lockfileDir: options.lockfileDir,
        pkg: {
            ...pkg,
            id,
            resolution,
        },
        expectedPkg: options.expectedPkg?.name != null
            ? (updated ? { name: options.expectedPkg.name, version: pkg.version } : options.expectedPkg)
            : pkg,
    });
    return {
        body: {
            id,
            isLocal: false,
            isInstallable: isInstallable ?? undefined,
            latest,
            manifest,
            normalizedPref,
            resolution,
            resolvedVia,
            updated,
            publishedAt,
        },
        bundledManifest: fetchResult.bundledManifest,
        files: fetchResult.files,
        filesIndexFile: fetchResult.filesIndexFile,
        finishing: fetchResult.finishing,
    };
}
function getFilesIndexFilePath(ctx, opts) {
    const targetRelative = (0, dependency_path_1.depPathToFilename)(opts.pkg.id);
    const target = path_1.default.join(ctx.storeDir, targetRelative);
    const filesIndexFile = opts.pkg.resolution.integrity
        ? ctx.getFilePathInCafs(opts.pkg.resolution.integrity, 'index')
        : path_1.default.join(target, opts.ignoreScripts ? 'integrity-not-built.json' : 'integrity.json');
    return { filesIndexFile, target };
}
function fetchToStore(ctx, opts) {
    if (!opts.pkg.name) {
        opts.fetchRawManifest = true;
    }
    if (!ctx.fetchingLocker.has(opts.pkg.id)) {
        const bundledManifest = (0, p_defer_1.default)();
        const files = (0, p_defer_1.default)();
        const finishing = (0, p_defer_1.default)();
        const { filesIndexFile, target } = getFilesIndexFilePath(ctx, opts);
        doFetchToStore(filesIndexFile, bundledManifest, files, finishing, target); // eslint-disable-line
        if (opts.fetchRawManifest) {
            ctx.fetchingLocker.set(opts.pkg.id, {
                bundledManifest: removeKeyOnFail(bundledManifest.promise),
                files: removeKeyOnFail(files.promise),
                filesIndexFile,
                finishing: removeKeyOnFail(finishing.promise),
            });
        }
        else {
            ctx.fetchingLocker.set(opts.pkg.id, {
                files: removeKeyOnFail(files.promise),
                filesIndexFile,
                finishing: removeKeyOnFail(finishing.promise),
            });
        }
        // When files resolves, the cached result has to set fromStore to true, without
        // affecting previous invocations: so we need to replace the cache.
        //
        // Changing the value of fromStore is needed for correct reporting of `pnpm server`.
        // Otherwise, if a package was not in store when the server started, it will always be
        // reported as "downloaded" instead of "reused".
        files.promise.then((cache) => {
            core_loggers_1.progressLogger.debug({
                packageId: opts.pkg.id,
                requester: opts.lockfileDir,
                status: cache.fromStore
                    ? 'found_in_store'
                    : 'fetched',
            });
            // If it's already in the store, we don't need to update the cache
            if (cache.fromStore) {
                return;
            }
            const tmp = ctx.fetchingLocker.get(opts.pkg.id);
            // If fetching failed then it was removed from the cache.
            // It is OK. In that case there is no need to update it.
            if (tmp == null)
                return;
            ctx.fetchingLocker.set(opts.pkg.id, {
                ...tmp,
                files: Promise.resolve({
                    ...cache,
                    fromStore: true,
                }),
            });
        })
            .catch(() => {
            ctx.fetchingLocker.delete(opts.pkg.id);
        });
    }
    const result = ctx.fetchingLocker.get(opts.pkg.id);
    if (opts.fetchRawManifest && (result.bundledManifest == null)) {
        result.bundledManifest = removeKeyOnFail(result.files.then(async (filesResult) => {
            if (!filesResult.filesIndex['package.json'])
                return undefined;
            if (!filesResult.local) {
                const { integrity, mode } = filesResult.filesIndex['package.json'];
                const manifestPath = ctx.getFilePathByModeInCafs(integrity, mode);
                return readBundledManifest(manifestPath);
            }
            return readBundledManifest(filesResult.filesIndex['package.json']);
        }));
    }
    return {
        bundledManifest: (result.bundledManifest != null) ? (0, promise_share_1.default)(result.bundledManifest) : undefined,
        files: (0, promise_share_1.default)(result.files),
        filesIndexFile: result.filesIndexFile,
        finishing: (0, promise_share_1.default)(result.finishing),
    };
    async function removeKeyOnFail(p) {
        try {
            return await p;
        }
        catch (err) { // eslint-disable-line
            ctx.fetchingLocker.delete(opts.pkg.id);
            throw err;
        }
    }
    async function doFetchToStore(filesIndexFile, bundledManifest, files, finishing, target) {
        try {
            const isLocalTarballDep = opts.pkg.id.startsWith('file:');
            const isLocalPkg = opts.pkg.resolution.type === 'directory';
            if (!opts.force &&
                (!isLocalTarballDep ||
                    await tarballIsUpToDate(opts.pkg.resolution, target, opts.lockfileDir) // eslint-disable-line
                ) &&
                !isLocalPkg) {
                let pkgFilesIndex;
                try {
                    pkgFilesIndex = await (0, load_json_file_1.default)(filesIndexFile);
                }
                catch (err) { // eslint-disable-line
                    // ignoring. It is fine if the integrity file is not present. Just refetch the package
                }
                // if target exists and it wasn't modified, then no need to refetch it
                if ((pkgFilesIndex?.files) != null) {
                    const manifest = opts.fetchRawManifest
                        ? (0, safe_promise_defer_1.default)()
                        : undefined;
                    if ((pkgFilesIndex.name != null &&
                        opts.expectedPkg?.name != null &&
                        pkgFilesIndex.name.toLowerCase() !== opts.expectedPkg.name.toLowerCase()) ||
                        (pkgFilesIndex.version != null &&
                            opts.expectedPkg?.version != null &&
                            // We used to not normalize the package versions before writing them to the lockfile and store.
                            // So it may happen that the version will be in different formats.
                            // For instance, v1.0.0 and 1.0.0
                            // Hence, we need to use semver.eq() to compare them.
                            !(0, equalOrSemverEqual_1.equalOrSemverEqual)(pkgFilesIndex.version, opts.expectedPkg.version))) {
                        /* eslint-disable @typescript-eslint/restrict-template-expressions */
                        throw new error_1.PnpmError('UNEXPECTED_PKG_CONTENT_IN_STORE', `\
Package name mismatch found while reading ${JSON.stringify(opts.pkg.resolution)} from the store. \
This means that the lockfile is broken. Expected package: ${opts.expectedPkg.name}@${opts.expectedPkg.version}. \
Actual package in the store by the given integrity: ${pkgFilesIndex.name}@${pkgFilesIndex.version}.`);
                        /* eslint-enable @typescript-eslint/restrict-template-expressions */
                    }
                    const verified = await ctx.checkFilesIntegrity(pkgFilesIndex, manifest);
                    if (verified) {
                        files.resolve({
                            filesIndex: pkgFilesIndex.files,
                            fromStore: true,
                            sideEffects: pkgFilesIndex.sideEffects,
                        });
                        if (manifest != null) {
                            manifest()
                                .then((manifest) => {
                                bundledManifest.resolve(manifest == null ? manifest : normalizeBundledManifest(manifest));
                            })
                                .catch(bundledManifest.reject);
                        }
                        finishing.resolve(undefined);
                        return;
                    }
                    packageRequestLogger.warn({
                        message: `Refetching ${target} to store. It was either modified or had no integrity checksums`,
                        prefix: opts.lockfileDir,
                    });
                }
            }
            // We fetch into targetStage directory first and then fs.rename() it to the
            // target directory.
            // Tarballs are requested first because they are bigger than metadata files.
            // However, when one line is left available, allow it to be picked up by a metadata request.
            // This is done in order to avoid situations when tarballs are downloaded in chunks
            // As many tarballs should be downloaded simultaneously as possible.
            const priority = (++ctx.requestsQueue.counter % ctx.requestsQueue.concurrency === 0 ? -1 : 1) * 1000;
            const fetchManifest = opts.fetchRawManifest
                ? (0, safe_promise_defer_1.default)()
                : undefined;
            if (fetchManifest != null) {
                fetchManifest()
                    .then((manifest) => {
                    bundledManifest.resolve(manifest == null ? manifest : normalizeBundledManifest(manifest));
                })
                    .catch(bundledManifest.reject);
            }
            const fetchedPackage = await ctx.requestsQueue.add(async () => ctx.fetch(opts.pkg.id, opts.pkg.resolution, {
                lockfileDir: opts.lockfileDir,
                manifest: fetchManifest,
                onProgress: (downloaded) => {
                    core_loggers_1.fetchingProgressLogger.debug({
                        downloaded,
                        packageId: opts.pkg.id,
                        status: 'in_progress',
                    });
                },
                onStart: (size, attempt) => {
                    core_loggers_1.fetchingProgressLogger.debug({
                        attempt,
                        packageId: opts.pkg.id,
                        size,
                        status: 'started',
                    });
                },
            }), { priority });
            let filesResult;
            if (!fetchedPackage.local) {
                // Ideally, files wouldn't care about when integrity is calculated.
                // However, we can only rename the temp folder once we know the package name.
                // And we cannot rename the temp folder till we're calculating integrities.
                const integrity = await (0, p_map_values_1.default)(async ({ writeResult, mode, size }) => {
                    const { checkedAt, integrity } = await writeResult;
                    return {
                        checkedAt,
                        integrity: integrity.toString(),
                        mode,
                        size,
                    };
                }, fetchedPackage.filesIndex);
                if (opts.pkg.name && opts.pkg.version) {
                    await writeFilesIndexFile(filesIndexFile, {
                        pkg: opts.pkg,
                        files: integrity,
                    });
                }
                else {
                    // Even though we could take the package name from the lockfile,
                    // it is not safe because the lockfile may be broken or manually edited.
                    // To be safe, we read the package name from the downloaded package's package.json instead.
                    /* eslint-disable @typescript-eslint/no-floating-promises */
                    bundledManifest.promise
                        .then((manifest) => writeFilesIndexFile(filesIndexFile, {
                        pkg: manifest ?? {},
                        files: integrity,
                    }))
                        .catch();
                    /* eslint-enable @typescript-eslint/no-floating-promises */
                }
                filesResult = {
                    fromStore: false,
                    filesIndex: integrity,
                };
            }
            else {
                filesResult = {
                    local: true,
                    fromStore: false,
                    filesIndex: fetchedPackage.filesIndex,
                    packageImportMethod: fetchedPackage.packageImportMethod,
                };
                if (fetchedPackage.filesIndex['package.json'] != null) {
                    readBundledManifest(fetchedPackage.filesIndex['package.json'])
                        .then(bundledManifest.resolve)
                        .catch(bundledManifest.reject);
                }
            }
            if (isLocalTarballDep && opts.pkg.resolution.integrity) {
                await fs_1.promises.mkdir(target, { recursive: true });
                await graceful_fs_1.default.writeFile(path_1.default.join(target, TARBALL_INTEGRITY_FILENAME), opts.pkg.resolution.integrity, 'utf8');
            }
            files.resolve(filesResult);
            finishing.resolve(undefined);
        }
        catch (err) { // eslint-disable-line
            files.reject(err);
            if (opts.fetchRawManifest) {
                bundledManifest.reject(err);
            }
        }
    }
}
async function writeFilesIndexFile(filesIndexFile, { pkg, files }) {
    await writeJsonFile(filesIndexFile, {
        name: pkg.name,
        version: pkg.version,
        files,
    });
}
async function writeJsonFile(filePath, data) {
    const targetDir = path_1.default.dirname(filePath);
    // TODO: use the API of @pnpm/cafs to write this file
    // There is actually no need to create the directory in 99% of cases.
    // So by using cafs API, we'll improve performance.
    await fs_1.promises.mkdir(targetDir, { recursive: true });
    const temp = (0, path_temp_1.default)(targetDir);
    await graceful_fs_1.default.writeFile(temp, JSON.stringify(data));
    await (0, rename_overwrite_1.default)(temp, filePath);
}
async function readBundledManifest(pkgJsonPath) {
    return pickBundledManifest(await (0, read_package_json_1.readPackageJson)(pkgJsonPath));
}
async function tarballIsUpToDate(resolution, pkgInStoreLocation, lockfileDir) {
    let currentIntegrity;
    try {
        currentIntegrity = (await graceful_fs_1.default.readFile(path_1.default.join(pkgInStoreLocation, TARBALL_INTEGRITY_FILENAME), 'utf8'));
    }
    catch (err) { // eslint-disable-line
        return false;
    }
    if (resolution.integrity && currentIntegrity !== resolution.integrity)
        return false;
    const tarball = path_1.default.join(lockfileDir, resolution.tarball.slice(5));
    const tarballStream = (0, fs_1.createReadStream)(tarball);
    try {
        return Boolean(await ssri_1.default.checkStream(tarballStream, currentIntegrity));
    }
    catch (err) { // eslint-disable-line
        return false;
    }
}
async function fetcher(fetcherByHostingType, cafs, packageId, resolution, opts) {
    const fetch = (0, pick_fetcher_1.pickFetcher)(fetcherByHostingType, resolution);
    try {
        return await fetch(cafs, resolution, opts); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    catch (err) { // eslint-disable-line
        packageRequestLogger.warn({
            message: `Fetching ${packageId} failed!`,
            prefix: opts.lockfileDir,
        });
        throw err;
    }
}
//# sourceMappingURL=packageRequester.js.map