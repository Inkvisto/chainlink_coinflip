"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hoist = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const constants_1 = require("@pnpm/constants");
const link_bins_1 = require("@pnpm/link-bins");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const lockfile_walker_1 = require("@pnpm/lockfile-walker");
const logger_1 = require("@pnpm/logger");
const matcher_1 = require("@pnpm/matcher");
const util_lex_comparator_1 = require("@pnpm/util.lex-comparator");
const dp = __importStar(require("@pnpm/dependency-path"));
const is_subdir_1 = __importDefault(require("is-subdir"));
const mapObjIndexed_1 = __importDefault(require("ramda/src/mapObjIndexed"));
const resolve_link_target_1 = __importDefault(require("resolve-link-target"));
const symlink_dir_1 = __importDefault(require("symlink-dir"));
const hoistLogger = (0, logger_1.logger)('hoist');
async function hoist(opts) {
    if (opts.lockfile.packages == null)
        return {};
    const { directDeps, step } = (0, lockfile_walker_1.lockfileWalker)(opts.lockfile, opts.importerIds ?? Object.keys(opts.lockfile.importers));
    const deps = [
        {
            children: directDeps
                .reduce((acc, { alias, depPath }) => {
                if (!acc[alias]) {
                    acc[alias] = depPath;
                }
                return acc;
            }, {}),
            depPath: '',
            depth: -1,
        },
        ...await getDependencies(step, 0),
    ];
    const getAliasHoistType = createGetAliasHoistType(opts.publicHoistPattern, opts.privateHoistPattern);
    const hoistedDependencies = await hoistGraph(deps, opts.lockfile.importers['.']?.specifiers ?? {}, {
        getAliasHoistType,
    });
    await symlinkHoistedDependencies(hoistedDependencies, {
        lockfile: opts.lockfile,
        privateHoistedModulesDir: opts.privateHoistedModulesDir,
        publicHoistedModulesDir: opts.publicHoistedModulesDir,
        virtualStoreDir: opts.virtualStoreDir,
    });
    // Here we only link the bins of the privately hoisted modules.
    // The bins of the publicly hoisted modules will be linked together with
    // the bins of the project's direct dependencies.
    // This is possible because the publicly hoisted modules
    // are in the same directory as the regular dependencies.
    await linkAllBins(opts.privateHoistedModulesDir, {
        extraNodePaths: opts.extraNodePath,
        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
    });
    return hoistedDependencies;
}
exports.hoist = hoist;
function createGetAliasHoistType(publicHoistPattern, privateHoistPattern) {
    const publicMatcher = (0, matcher_1.createMatcher)(publicHoistPattern);
    const privateMatcher = (0, matcher_1.createMatcher)(privateHoistPattern);
    return (alias) => {
        if (publicMatcher(alias))
            return 'public';
        if (privateMatcher(alias))
            return 'private';
        return false;
    };
}
async function linkAllBins(modulesDir, opts) {
    const bin = path_1.default.join(modulesDir, '.bin');
    const warn = (message, code) => {
        if (code === 'BINARIES_CONFLICT')
            return;
        logger_1.logger.info({ message, prefix: path_1.default.join(modulesDir, '../..') });
    };
    try {
        await (0, link_bins_1.linkBins)(modulesDir, bin, {
            allowExoticManifests: true,
            extraNodePaths: opts.extraNodePaths,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            warn,
        });
    }
    catch (err) { // eslint-disable-line
        // Some packages generate their commands with lifecycle hooks.
        // At this stage, such commands are not generated yet.
        // For now, we don't hoist such generated commands.
        // Related issue: https://github.com/pnpm/pnpm/issues/2071
    }
}
async function getDependencies(step, depth) {
    const deps = [];
    const nextSteps = [];
    for (const { pkgSnapshot, depPath, next } of step.dependencies) {
        const allDeps = {
            ...pkgSnapshot.dependencies,
            ...pkgSnapshot.optionalDependencies,
        };
        deps.push({
            children: (0, mapObjIndexed_1.default)(dp.refToRelative, allDeps),
            depPath,
            depth,
        });
        nextSteps.push(next());
    }
    for (const depPath of step.missing) {
        // It might make sense to fail if the depPath is not in the skipped list from .modules.yaml
        // However, the skipped list currently contains package IDs, not dep paths.
        logger_1.logger.debug({ message: `No entry for "${depPath}" in ${constants_1.WANTED_LOCKFILE}` });
    }
    return (await Promise.all(nextSteps.map(async (nextStep) => getDependencies(nextStep, depth + 1)))).reduce((acc, deps) => [...acc, ...deps], deps);
}
async function hoistGraph(depNodes, currentSpecifiers, opts) {
    const hoistedAliases = new Set(Object.keys(currentSpecifiers));
    const hoistedDependencies = {};
    depNodes
        // sort by depth and then alphabetically
        .sort((a, b) => {
        const depthDiff = a.depth - b.depth;
        return depthDiff === 0 ? (0, util_lex_comparator_1.lexCompare)(a.depPath, b.depPath) : depthDiff;
    })
        // build the alias map and the id map
        .forEach((depNode) => {
        for (const [childAlias, childPath] of Object.entries(depNode.children)) {
            const hoist = opts.getAliasHoistType(childAlias);
            if (!hoist)
                continue;
            const childAliasNormalized = childAlias.toLowerCase();
            // if this alias has already been taken, skip it
            if (hoistedAliases.has(childAliasNormalized)) {
                continue;
            }
            hoistedAliases.add(childAliasNormalized);
            if (!hoistedDependencies[childPath]) {
                hoistedDependencies[childPath] = {};
            }
            hoistedDependencies[childPath][childAlias] = hoist;
        }
    });
    return hoistedDependencies;
}
async function symlinkHoistedDependencies(hoistedDependencies, opts) {
    const symlink = symlinkHoistedDependency.bind(null, opts);
    await Promise.all(Object.entries(hoistedDependencies)
        .map(async ([depPath, pkgAliases]) => {
        const pkgSnapshot = opts.lockfile.packages[depPath];
        if (!pkgSnapshot) {
            // This dependency is probably a skipped optional dependency.
            hoistLogger.debug({ hoistFailedFor: depPath });
            return;
        }
        const pkgName = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, pkgSnapshot).name;
        const modules = path_1.default.join(opts.virtualStoreDir, dp.depPathToFilename(depPath), 'node_modules');
        const depLocation = path_1.default.join(modules, pkgName);
        await Promise.all(Object.entries(pkgAliases).map(async ([pkgAlias, hoistType]) => {
            const targetDir = hoistType === 'public'
                ? opts.publicHoistedModulesDir
                : opts.privateHoistedModulesDir;
            const dest = path_1.default.join(targetDir, pkgAlias);
            return symlink(depLocation, dest);
        }));
    }));
}
async function symlinkHoistedDependency(opts, depLocation, dest) {
    try {
        await (0, symlink_dir_1.default)(depLocation, dest, { overwrite: false });
        core_loggers_1.linkLogger.debug({ target: dest, link: depLocation });
        return;
    }
    catch (err) { // eslint-disable-line
        if (err.code !== 'EEXIST' && err.code !== 'EISDIR')
            throw err;
    }
    let existingSymlink;
    try {
        existingSymlink = await (0, resolve_link_target_1.default)(dest);
    }
    catch (err) {
        hoistLogger.debug({
            skipped: dest,
            reason: 'a directory is present at the target location',
        });
        return;
    }
    if (!(0, is_subdir_1.default)(opts.virtualStoreDir, existingSymlink)) {
        hoistLogger.debug({
            skipped: dest,
            existingSymlink,
            reason: 'an external symlink is present at the target location',
        });
        return;
    }
    await fs_1.default.promises.unlink(dest);
    await (0, symlink_dir_1.default)(depLocation, dest);
    core_loggers_1.linkLogger.debug({ target: dest, link: depLocation });
}
//# sourceMappingURL=index.js.map