"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGitFetcher = void 0;
const path_1 = __importDefault(require("path"));
const logger_1 = require("@pnpm/logger");
const prepare_package_1 = require("@pnpm/prepare-package");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const execa_1 = __importDefault(require("execa"));
const url_1 = require("url");
function createGitFetcher(createOpts) {
    const allowedHosts = new Set(createOpts?.gitShallowHosts ?? []);
    const ignoreScripts = createOpts.ignoreScripts ?? false;
    const preparePkg = prepare_package_1.preparePackage.bind(null, {
        ignoreScripts: createOpts.ignoreScripts,
        rawConfig: createOpts.rawConfig,
        unsafePerm: createOpts.unsafePerm,
    });
    const gitFetcher = async (cafs, resolution, opts) => {
        const tempLocation = await cafs.tempDir();
        if (allowedHosts.size > 0 && shouldUseShallow(resolution.repo, allowedHosts)) {
            await execGit(['init'], { cwd: tempLocation });
            await execGit(['remote', 'add', 'origin', resolution.repo], { cwd: tempLocation });
            await execGit(['fetch', '--depth', '1', 'origin', resolution.commit], { cwd: tempLocation });
        }
        else {
            await execGit(['clone', resolution.repo, tempLocation]);
        }
        await execGit(['checkout', resolution.commit], { cwd: tempLocation });
        try {
            const shouldBeBuilt = await preparePkg(tempLocation);
            if (ignoreScripts && shouldBeBuilt) {
                (0, logger_1.globalWarn)(`The git-hosted package fetched from "${resolution.repo}" has to be built but the build scripts were ignored.`);
            }
        }
        catch (err) { // eslint-disable-line
            err.message = `Failed to prepare git-hosted package fetched from "${resolution.repo}": ${err.message}`; // eslint-disable-line
            throw err;
        }
        // removing /.git to make directory integrity calculation faster
        await (0, rimraf_1.default)(path_1.default.join(tempLocation, '.git'));
        const filesIndex = await cafs.addFilesFromDir(tempLocation, opts.manifest);
        // Important! We cannot remove the temp location at this stage.
        // Even though we have the index of the package,
        // the linking of files to the store is in progress.
        return { filesIndex };
    };
    return {
        git: gitFetcher,
    };
}
exports.createGitFetcher = createGitFetcher;
function shouldUseShallow(repoUrl, allowedHosts) {
    try {
        const { host } = new url_1.URL(repoUrl);
        if (allowedHosts.has(host)) {
            return true;
        }
    }
    catch (e) {
        // URL might be malformed
    }
    return false;
}
function prefixGitArgs() {
    return process.platform === 'win32' ? ['-c', 'core.longpaths=true'] : [];
}
function execGit(args, opts) {
    const fullArgs = prefixGitArgs().concat(args || []);
    return (0, execa_1.default)('git', fullArgs, opts);
}
//# sourceMappingURL=index.js.map