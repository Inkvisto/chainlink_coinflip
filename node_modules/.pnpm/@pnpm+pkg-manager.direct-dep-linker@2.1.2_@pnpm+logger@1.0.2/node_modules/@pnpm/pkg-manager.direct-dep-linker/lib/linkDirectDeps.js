"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkDirectDeps = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const symlink_dependency_1 = require("@pnpm/symlink-dependency");
const omit_1 = __importDefault(require("ramda/src/omit"));
const read_modules_dir_1 = require("@pnpm/read-modules-dir");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const resolve_link_target_1 = __importDefault(require("resolve-link-target"));
async function linkDirectDeps(projects, opts) {
    if (opts.dedupe && projects['.'] && Object.keys(projects).length > 1) {
        return linkDirectDepsAndDedupe(projects['.'], (0, omit_1.default)(['.'], projects));
    }
    const numberOfLinkedDeps = await Promise.all(Object.values(projects).map(linkDirectDepsOfProject));
    return numberOfLinkedDeps.reduce((sum, count) => sum + count, 0);
}
exports.linkDirectDeps = linkDirectDeps;
async function linkDirectDepsAndDedupe(rootProject, projects) {
    const linkedDeps = await linkDirectDepsOfProject(rootProject);
    const pkgsLinkedToRoot = await readLinkedDeps(rootProject.modulesDir);
    await Promise.all(Object.values(projects).map(async (project) => {
        const deletedAll = await deletePkgsPresentInRoot(project.modulesDir, pkgsLinkedToRoot);
        const dependencies = omitDepsFromRoot(project.dependencies, pkgsLinkedToRoot);
        if (dependencies.length > 0) {
            await linkDirectDepsOfProject({
                ...project,
                dependencies,
            });
            return;
        }
        if (deletedAll) {
            await (0, rimraf_1.default)(project.modulesDir);
        }
    }));
    return linkedDeps;
}
function omitDepsFromRoot(deps, pkgsLinkedToRoot) {
    return deps.filter(({ dir }) => !pkgsLinkedToRoot.some(pathsEqual.bind(null, dir)));
}
function pathsEqual(path1, path2) {
    return path_1.default.relative(path1, path2) === '';
}
async function readLinkedDeps(modulesDir) {
    const deps = (await (0, read_modules_dir_1.readModulesDir)(modulesDir)) ?? [];
    return Promise.all(deps.map((alias) => resolveLinkTargetOrFile(path_1.default.join(modulesDir, alias))));
}
async function deletePkgsPresentInRoot(modulesDir, pkgsLinkedToRoot) {
    const pkgsLinkedToCurrentProject = await readLinkedDepsWithRealLocations(modulesDir);
    const pkgsToDelete = pkgsLinkedToCurrentProject
        .filter(({ linkedFrom }) => pkgsLinkedToRoot.some(pathsEqual.bind(null, linkedFrom)));
    await Promise.all(pkgsToDelete.map(({ linkedTo }) => fs_1.default.promises.unlink(linkedTo)));
    return pkgsToDelete.length === pkgsLinkedToCurrentProject.length;
}
async function readLinkedDepsWithRealLocations(modulesDir) {
    const deps = (await (0, read_modules_dir_1.readModulesDir)(modulesDir)) ?? [];
    return Promise.all(deps.map(async (alias) => {
        const linkedTo = path_1.default.join(modulesDir, alias);
        return {
            linkedTo,
            linkedFrom: await resolveLinkTargetOrFile(linkedTo),
        };
    }));
}
async function resolveLinkTargetOrFile(filePath) {
    try {
        return await (0, resolve_link_target_1.default)(filePath);
    }
    catch (err) { // eslint-disable-line @typescript-eslint/no-explicit-any
        if (err.code !== 'EINVAL' && err.code !== 'UNKNOWN')
            throw err;
        return filePath;
    }
}
async function linkDirectDepsOfProject(project) {
    let linkedDeps = 0;
    await Promise.all(project.dependencies.map(async (dep) => {
        if (dep.isExternalLink) {
            await (0, symlink_dependency_1.symlinkDirectRootDependency)(dep.dir, project.modulesDir, dep.alias, {
                fromDependenciesField: dep.dependencyType === 'dev' && 'devDependencies' ||
                    dep.dependencyType === 'optional' && 'optionalDependencies' ||
                    'dependencies',
                linkedPackage: {
                    name: dep.name,
                    version: dep.version,
                },
                prefix: project.dir,
            });
            return;
        }
        if ((await (0, symlink_dependency_1.symlinkDependency)(dep.dir, project.modulesDir, dep.alias)).reused) {
            return;
        }
        core_loggers_1.rootLogger.debug({
            added: {
                dependencyType: dep.dependencyType,
                id: dep.id,
                latest: dep.latest,
                name: dep.alias,
                realName: dep.name,
                version: dep.version,
            },
            prefix: project.dir,
        });
        linkedDeps++;
    }));
    return linkedDeps;
}
//# sourceMappingURL=linkDirectDeps.js.map