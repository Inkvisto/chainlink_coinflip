"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateLockfile = void 0;
const logger_1 = require("@pnpm/logger");
const prune_lockfile_1 = require("@pnpm/prune-lockfile");
const dp = __importStar(require("@pnpm/dependency-path"));
const get_npm_tarball_url_1 = __importDefault(require("get-npm-tarball-url"));
const mergeRight_1 = __importDefault(require("ramda/src/mergeRight"));
const partition_1 = __importDefault(require("ramda/src/partition"));
const depPathToRef_1 = require("./depPathToRef");
function updateLockfile({ dependenciesGraph, lockfile, prefix, registries, lockfileIncludeTarballUrl }) {
    lockfile.packages = lockfile.packages ?? {};
    const pendingRequiresBuilds = [];
    for (const [depPath, depNode] of Object.entries(dependenciesGraph)) {
        const [updatedOptionalDeps, updatedDeps] = (0, partition_1.default)((child) => depNode.optionalDependencies.has(child.alias), Object.entries(depNode.children).map(([alias, depPath]) => ({ alias, depPath })));
        lockfile.packages[depPath] = toLockfileDependency(pendingRequiresBuilds, depNode, {
            depGraph: dependenciesGraph,
            depPath,
            prevSnapshot: lockfile.packages[depPath],
            registries,
            registry: dp.getRegistryByPackageName(registries, depNode.name),
            updatedDeps,
            updatedOptionalDeps,
            lockfileIncludeTarballUrl,
        });
    }
    const warn = (message) => {
        logger_1.logger.warn({ message, prefix });
    };
    return {
        newLockfile: (0, prune_lockfile_1.pruneSharedLockfile)(lockfile, { warn }),
        pendingRequiresBuilds,
    };
}
exports.updateLockfile = updateLockfile;
function toLockfileDependency(pendingRequiresBuilds, pkg, opts) {
    const lockfileResolution = toLockfileResolution({ id: pkg.id, name: pkg.name, version: pkg.version }, opts.depPath, pkg.resolution, opts.registry, opts.lockfileIncludeTarballUrl);
    const newResolvedDeps = updateResolvedDeps(opts.prevSnapshot?.dependencies ?? {}, opts.updatedDeps, opts.registries, opts.depGraph);
    const newResolvedOptionalDeps = updateResolvedDeps(opts.prevSnapshot?.optionalDependencies ?? {}, opts.updatedOptionalDeps, opts.registries, opts.depGraph);
    const result = {
        resolution: lockfileResolution,
    };
    if (dp.isAbsolute(opts.depPath)) {
        result['name'] = pkg.name;
        // There is no guarantee that a non-npmjs.org-hosted package is going to have a version field.
        // Also, for local directory dependencies, the version is not needed.
        if (pkg.version && lockfileResolution.type !== 'directory') {
            result['version'] = pkg.version;
        }
    }
    if (Object.keys(newResolvedDeps).length > 0) {
        result['dependencies'] = newResolvedDeps;
    }
    if (Object.keys(newResolvedOptionalDeps).length > 0) {
        result['optionalDependencies'] = newResolvedOptionalDeps;
    }
    if (pkg.dev && !pkg.prod) {
        result['dev'] = true;
    }
    else if (pkg.prod && !pkg.dev) {
        result['dev'] = false;
    }
    if (pkg.optional) {
        result['optional'] = true;
    }
    if (opts.depPath[0] !== '/' && !pkg.id.endsWith(opts.depPath)) {
        result['id'] = pkg.id;
    }
    if (Object.keys(pkg.peerDependencies ?? {}).length > 0) {
        result['peerDependencies'] = pkg.peerDependencies;
    }
    if (pkg.transitivePeerDependencies.size) {
        result['transitivePeerDependencies'] = Array.from(pkg.transitivePeerDependencies).sort();
    }
    if (pkg.peerDependenciesMeta != null) {
        const normalizedPeerDependenciesMeta = {};
        for (const [peer, { optional }] of Object.entries(pkg.peerDependenciesMeta)) {
            if (optional) {
                normalizedPeerDependenciesMeta[peer] = { optional: true };
            }
        }
        if (Object.keys(normalizedPeerDependenciesMeta).length > 0) {
            result['peerDependenciesMeta'] = normalizedPeerDependenciesMeta;
        }
    }
    if (pkg.additionalInfo.engines != null) {
        for (const [engine, version] of Object.entries(pkg.additionalInfo.engines)) {
            if (version === '*')
                continue;
            result.engines = result.engines ?? {}; // eslint-disable-line @typescript-eslint/no-explicit-any
            result.engines[engine] = version;
        }
    }
    if (pkg.additionalInfo.cpu != null) {
        result['cpu'] = pkg.additionalInfo.cpu;
    }
    if (pkg.additionalInfo.os != null) {
        result['os'] = pkg.additionalInfo.os;
    }
    if (pkg.additionalInfo.libc != null) {
        result['libc'] = pkg.additionalInfo.libc;
    }
    if (Array.isArray(pkg.additionalInfo.bundledDependencies) || Array.isArray(pkg.additionalInfo.bundleDependencies)) {
        result['bundledDependencies'] = pkg.additionalInfo.bundledDependencies ?? pkg.additionalInfo.bundleDependencies;
    }
    if (pkg.additionalInfo.deprecated) {
        result['deprecated'] = pkg.additionalInfo.deprecated;
    }
    if (pkg.hasBin) {
        result['hasBin'] = true;
    }
    if (pkg.patchFile) {
        result['patched'] = true;
    }
    const requiresBuildIsKnown = typeof pkg.requiresBuild === 'boolean';
    let pending = false;
    if (requiresBuildIsKnown) {
        if (pkg.requiresBuild) {
            result['requiresBuild'] = true;
        }
    }
    else if (opts.prevSnapshot != null) {
        if (opts.prevSnapshot.requiresBuild) {
            result['requiresBuild'] = opts.prevSnapshot.requiresBuild;
        }
        if (opts.prevSnapshot.prepare) {
            result['prepare'] = opts.prevSnapshot.prepare;
        }
    }
    else if (pkg.prepare) {
        result['prepare'] = true;
        result['requiresBuild'] = true;
    }
    else {
        pendingRequiresBuilds.push(opts.depPath);
        pending = true;
    }
    if (!requiresBuildIsKnown && !pending) {
        pkg.requiresBuild.resolve(result.requiresBuild ?? false);
    }
    return result;
}
// previous resolutions should not be removed from lockfile
// as installation might not reanalyze the whole dependency graph
// the `depth` property defines how deep should dependencies be checked
function updateResolvedDeps(prevResolvedDeps, updatedDeps, registries, depGraph) {
    const newResolvedDeps = Object.fromEntries(updatedDeps
        .map(({ alias, depPath }) => {
        if (depPath.startsWith('link:')) {
            return [alias, depPath];
        }
        const depNode = depGraph[depPath];
        return [
            alias,
            (0, depPathToRef_1.depPathToRef)(depNode.depPath, {
                alias,
                realName: depNode.name,
                registries,
                resolution: depNode.resolution,
            }),
        ];
    }));
    return (0, mergeRight_1.default)(prevResolvedDeps, newResolvedDeps);
}
function toLockfileResolution(pkg, depPath, resolution, registry, lockfileIncludeTarballUrl) {
    if (dp.isAbsolute(depPath) || resolution.type !== undefined || !resolution['integrity']) {
        return resolution;
    }
    if (lockfileIncludeTarballUrl) {
        return {
            integrity: resolution['integrity'],
            tarball: resolution['tarball'],
        };
    }
    // Sometimes packages are hosted under non-standard tarball URLs.
    // For instance, when they are hosted on npm Enterprise. See https://github.com/pnpm/pnpm/issues/867
    // Or in other weird cases, like https://github.com/pnpm/pnpm/issues/1072
    const expectedTarball = (0, get_npm_tarball_url_1.default)(pkg.name, pkg.version, { registry });
    const actualTarball = resolution['tarball'].replace('%2f', '/');
    if (removeProtocol(expectedTarball) !== removeProtocol(actualTarball)) {
        return {
            integrity: resolution['integrity'],
            tarball: resolution['tarball'],
        };
    }
    return {
        integrity: resolution['integrity'],
    };
}
function removeProtocol(url) {
    return url.split('://')[1];
}
//# sourceMappingURL=updateLockfile.js.map