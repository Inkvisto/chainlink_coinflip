"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDependencies = exports.getWantedDependencies = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("@pnpm/constants");
const error_1 = require("@pnpm/error");
const core_loggers_1 = require("@pnpm/core-loggers");
const logger_1 = require("@pnpm/logger");
const manifest_utils_1 = require("@pnpm/manifest-utils");
const read_package_json_1 = require("@pnpm/read-package-json");
const types_1 = require("@pnpm/types");
const promise_share_1 = __importDefault(require("promise-share"));
const difference_1 = __importDefault(require("ramda/src/difference"));
const zipWith_1 = __importDefault(require("ramda/src/zipWith"));
const is_subdir_1 = __importDefault(require("is-subdir"));
const getWantedDependencies_1 = require("./getWantedDependencies");
Object.defineProperty(exports, "getWantedDependencies", { enumerable: true, get: function () { return getWantedDependencies_1.getWantedDependencies; } });
const depPathToRef_1 = require("./depPathToRef");
const resolveDependencies_1 = require("./resolveDependencies");
const resolveDependencyTree_1 = require("./resolveDependencyTree");
const resolvePeers_1 = require("./resolvePeers");
const toResolveImporter_1 = require("./toResolveImporter");
const updateLockfile_1 = require("./updateLockfile");
const updateProjectManifest_1 = require("./updateProjectManifest");
async function resolveDependencies(importers, opts) {
    const _toResolveImporter = toResolveImporter_1.toResolveImporter.bind(null, {
        defaultUpdateDepth: opts.defaultUpdateDepth,
        lockfileOnly: opts.dryRun,
        preferredVersions: opts.preferredVersions,
        virtualStoreDir: opts.virtualStoreDir,
        workspacePackages: opts.workspacePackages,
    });
    const projectsToResolve = await Promise.all(importers.map(async (project) => _toResolveImporter(project)));
    const { dependenciesTree, outdatedDependencies, resolvedImporters, resolvedPackagesByDepPath, wantedToBeSkippedPackageIds, appliedPatches, time, } = await (0, resolveDependencyTree_1.resolveDependencyTree)(projectsToResolve, opts);
    // We only check whether patches were applied in cases when the whole lockfile was reanalyzed.
    if (opts.patchedDependencies &&
        (opts.forceFullResolution || !Object.keys(opts.wantedLockfile.packages ?? {})?.length) &&
        Object.keys(opts.wantedLockfile.importers).length === importers.length) {
        verifyPatches({
            patchedDependencies: Object.keys(opts.patchedDependencies),
            appliedPatches,
            allowNonAppliedPatches: opts.allowNonAppliedPatches,
        });
    }
    const linkedDependenciesByProjectId = {};
    const projectsToLink = await Promise.all(projectsToResolve.map(async (project, index) => {
        const resolvedImporter = resolvedImporters[project.id];
        linkedDependenciesByProjectId[project.id] = resolvedImporter.linkedDependencies;
        let updatedManifest = project.manifest;
        let updatedOriginalManifest = project.originalManifest;
        if (project.updatePackageManifest) {
            const manifests = await (0, updateProjectManifest_1.updateProjectManifest)(project, {
                directDependencies: resolvedImporter.directDependencies,
                preserveWorkspaceProtocol: opts.preserveWorkspaceProtocol,
                saveWorkspaceProtocol: opts.saveWorkspaceProtocol,
            });
            updatedManifest = manifests[0];
            updatedOriginalManifest = manifests[1];
        }
        else {
            core_loggers_1.packageManifestLogger.debug({
                prefix: project.rootDir,
                updated: project.manifest,
            });
        }
        if (updatedManifest != null) {
            if (opts.autoInstallPeers) {
                if (updatedManifest.peerDependencies) {
                    const allDeps = (0, manifest_utils_1.getAllDependenciesFromManifest)(updatedManifest);
                    for (const [peerName, peerRange] of Object.entries(updatedManifest.peerDependencies)) {
                        if (allDeps[peerName])
                            continue;
                        updatedManifest.dependencies ??= {};
                        updatedManifest.dependencies[peerName] = peerRange;
                    }
                }
            }
            const projectSnapshot = opts.wantedLockfile.importers[project.id];
            opts.wantedLockfile.importers[project.id] = addDirectDependenciesToLockfile(updatedManifest, projectSnapshot, resolvedImporter.linkedDependencies, resolvedImporter.directDependencies, opts.registries, opts.excludeLinksFromLockfile);
        }
        const topParents = project.manifest
            ? await getTopParents((0, difference_1.default)(Object.keys((0, manifest_utils_1.getAllDependenciesFromManifest)(project.manifest)), resolvedImporter.directDependencies.map(({ alias }) => alias) || []), project.modulesDir)
            : [];
        resolvedImporter.linkedDependencies.forEach((linkedDependency) => {
            // The location of the external link may vary on different machines, so it is better not to include it in the lockfile.
            // As a workaround, we symlink to the root of node_modules, which is a symlink to the actual location of the external link.
            const target = !opts.excludeLinksFromLockfile || (0, is_subdir_1.default)(opts.lockfileDir, linkedDependency.resolution.directory)
                ? linkedDependency.resolution.directory
                : path_1.default.join(project.modulesDir, linkedDependency.alias);
            const linkedDir = (0, resolveDependencies_1.createNodeIdForLinkedLocalPkg)(opts.lockfileDir, target);
            topParents.push({
                name: linkedDependency.alias,
                version: linkedDependency.version,
                linkedDir,
            });
        });
        const manifest = updatedOriginalManifest ?? project.originalManifest ?? project.manifest;
        importers[index].manifest = manifest;
        return {
            binsDir: project.binsDir,
            directNodeIdsByAlias: resolvedImporter.directNodeIdsByAlias,
            id: project.id,
            linkedDependencies: resolvedImporter.linkedDependencies,
            manifest: project.manifest,
            modulesDir: project.modulesDir,
            rootDir: project.rootDir,
            topParents,
        };
    }));
    const { dependenciesGraph, dependenciesByProjectId, peerDependencyIssuesByProjects, } = (0, resolvePeers_1.resolvePeers)({
        dependenciesTree,
        dedupePeerDependents: opts.dedupePeerDependents,
        lockfileDir: opts.lockfileDir,
        projects: projectsToLink,
        virtualStoreDir: opts.virtualStoreDir,
        resolvePeersFromWorkspaceRoot: Boolean(opts.resolvePeersFromWorkspaceRoot),
    });
    for (const { id, manifest } of projectsToLink) {
        for (const [alias, depPath] of Object.entries(dependenciesByProjectId[id])) {
            const projectSnapshot = opts.wantedLockfile.importers[id];
            if (manifest.dependenciesMeta != null) {
                projectSnapshot.dependenciesMeta = manifest.dependenciesMeta;
            }
            const depNode = dependenciesGraph[depPath];
            const ref = (0, depPathToRef_1.depPathToRef)(depPath, {
                alias,
                realName: depNode.name,
                registries: opts.registries,
                resolution: depNode.resolution,
            });
            if (projectSnapshot.dependencies?.[alias]) {
                projectSnapshot.dependencies[alias] = ref;
            }
            else if (projectSnapshot.devDependencies?.[alias]) {
                projectSnapshot.devDependencies[alias] = ref;
            }
            else if (projectSnapshot.optionalDependencies?.[alias]) {
                projectSnapshot.optionalDependencies[alias] = ref;
            }
        }
    }
    const { newLockfile, pendingRequiresBuilds } = (0, updateLockfile_1.updateLockfile)({
        dependenciesGraph,
        lockfile: opts.wantedLockfile,
        prefix: opts.virtualStoreDir,
        registries: opts.registries,
        lockfileIncludeTarballUrl: opts.lockfileIncludeTarballUrl,
    });
    if (time) {
        newLockfile.time = {
            ...opts.wantedLockfile.time,
            ...time,
        };
    }
    if (opts.forceFullResolution && opts.wantedLockfile != null) {
        for (const [depPath, pkg] of Object.entries(dependenciesGraph)) {
            if ((opts.allowBuild != null && !opts.allowBuild(pkg.name)) ||
                (opts.wantedLockfile.packages?.[depPath] == null) ||
                pkg.requiresBuild === true)
                continue;
            pendingRequiresBuilds.push(depPath);
        }
    }
    // waiting till package requests are finished
    const waitTillAllFetchingsFinish = async () => Promise.all(Object.values(resolvedPackagesByDepPath).map(async ({ finishing }) => finishing?.()));
    return {
        dependenciesByProjectId,
        dependenciesGraph,
        finishLockfileUpdates: (0, promise_share_1.default)(finishLockfileUpdates(dependenciesGraph, pendingRequiresBuilds, newLockfile)),
        outdatedDependencies,
        linkedDependenciesByProjectId,
        newLockfile,
        peerDependencyIssuesByProjects,
        waitTillAllFetchingsFinish,
        wantedToBeSkippedPackageIds,
    };
}
exports.resolveDependencies = resolveDependencies;
function verifyPatches({ patchedDependencies, appliedPatches, allowNonAppliedPatches, }) {
    const nonAppliedPatches = patchedDependencies.filter((patchKey) => !appliedPatches.has(patchKey));
    if (!nonAppliedPatches.length)
        return;
    const message = `The following patches were not applied: ${nonAppliedPatches.join(', ')}`;
    if (allowNonAppliedPatches) {
        (0, logger_1.globalWarn)(message);
        return;
    }
    throw new error_1.PnpmError('PATCH_NOT_APPLIED', message, {
        hint: 'Either remove them from "patchedDependencies" or update them to match packages in your dependencies.',
    });
}
async function finishLockfileUpdates(dependenciesGraph, pendingRequiresBuilds, newLockfile) {
    return Promise.all(pendingRequiresBuilds.map(async (depPath) => {
        const depNode = dependenciesGraph[depPath];
        let requiresBuild;
        if (depNode.optional) {
            // We assume that all optional dependencies have to be built.
            // Optional dependencies are not always downloaded, so there is no way to know whether they need to be built or not.
            requiresBuild = true;
        }
        else if (depNode.fetchingBundledManifest != null) {
            const filesResponse = await depNode.fetchingFiles();
            // The npm team suggests to always read the package.json for deciding whether the package has lifecycle scripts
            const pkgJson = await depNode.fetchingBundledManifest();
            requiresBuild = Boolean(pkgJson?.scripts != null && (Boolean(pkgJson.scripts.preinstall) ||
                Boolean(pkgJson.scripts.install) ||
                Boolean(pkgJson.scripts.postinstall)) ||
                filesResponse.filesIndex['binding.gyp'] ||
                Object.keys(filesResponse.filesIndex).some((filename) => !(filename.match(/^[.]hooks[\\/]/) == null)) // TODO: optimize this
            );
        }
        else {
            // This should never ever happen
            throw new Error(`Cannot create ${constants_1.WANTED_LOCKFILE} because raw manifest (aka package.json) wasn't fetched for "${depPath}"`);
        }
        if (typeof depNode.requiresBuild === 'function') {
            depNode.requiresBuild['resolve'](requiresBuild);
        }
        // TODO: try to cover with unit test the case when entry is no longer available in lockfile
        // It is an edge that probably happens if the entry is removed during lockfile prune
        if (requiresBuild && newLockfile.packages?.[depPath]) {
            newLockfile.packages[depPath].requiresBuild = true;
        }
    }));
}
function addDirectDependenciesToLockfile(newManifest, projectSnapshot, linkedPackages, directDependencies, registries, excludeLinksFromLockfile) {
    const newProjectSnapshot = {
        dependencies: {},
        devDependencies: {},
        optionalDependencies: {},
        specifiers: {},
    };
    if (newManifest.publishConfig?.directory) {
        newProjectSnapshot.publishDirectory = newManifest.publishConfig.directory;
    }
    linkedPackages.forEach((linkedPkg) => {
        newProjectSnapshot.specifiers[linkedPkg.alias] = (0, manifest_utils_1.getSpecFromPackageManifest)(newManifest, linkedPkg.alias);
    });
    const directDependenciesByAlias = directDependencies.reduce((acc, directDependency) => {
        acc[directDependency.alias] = directDependency;
        return acc;
    }, {});
    const allDeps = Array.from(new Set(Object.keys((0, manifest_utils_1.getAllDependenciesFromManifest)(newManifest))));
    for (const alias of allDeps) {
        const dep = directDependenciesByAlias[alias];
        const spec = dep && (0, manifest_utils_1.getSpecFromPackageManifest)(newManifest, dep.alias);
        if (dep &&
            (!excludeLinksFromLockfile ||
                !dep.isLinkedDependency ||
                spec.startsWith('workspace:'))) {
            const ref = (0, depPathToRef_1.depPathToRef)(dep.pkgId, {
                alias: dep.alias,
                realName: dep.name,
                registries,
                resolution: dep.resolution,
            });
            if (dep.dev) {
                newProjectSnapshot.devDependencies[dep.alias] = ref;
            }
            else if (dep.optional) {
                newProjectSnapshot.optionalDependencies[dep.alias] = ref;
            }
            else {
                newProjectSnapshot.dependencies[dep.alias] = ref;
            }
            newProjectSnapshot.specifiers[dep.alias] = spec;
        }
        else if (projectSnapshot.specifiers[alias]) {
            newProjectSnapshot.specifiers[alias] = projectSnapshot.specifiers[alias];
            if (projectSnapshot.dependencies?.[alias]) {
                newProjectSnapshot.dependencies[alias] = projectSnapshot.dependencies[alias];
            }
            else if (projectSnapshot.optionalDependencies?.[alias]) {
                newProjectSnapshot.optionalDependencies[alias] = projectSnapshot.optionalDependencies[alias];
            }
            else if (projectSnapshot.devDependencies?.[alias]) {
                newProjectSnapshot.devDependencies[alias] = projectSnapshot.devDependencies[alias];
            }
        }
    }
    alignDependencyTypes(newManifest, newProjectSnapshot);
    return newProjectSnapshot;
}
function alignDependencyTypes(manifest, projectSnapshot) {
    const depTypesOfAliases = getAliasToDependencyTypeMap(manifest);
    // Aligning the dependency types in pnpm-lock.yaml
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (projectSnapshot[depType] == null)
            continue;
        for (const [alias, ref] of Object.entries(projectSnapshot[depType] ?? {})) {
            if (depType === depTypesOfAliases[alias] || !depTypesOfAliases[alias])
                continue;
            projectSnapshot[depTypesOfAliases[alias]][alias] = ref;
            delete projectSnapshot[depType][alias];
        }
    }
}
function getAliasToDependencyTypeMap(manifest) {
    const depTypesOfAliases = {};
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (manifest[depType] == null)
            continue;
        for (const alias of Object.keys(manifest[depType] ?? {})) {
            if (!depTypesOfAliases[alias]) {
                depTypesOfAliases[alias] = depType;
            }
        }
    }
    return depTypesOfAliases;
}
async function getTopParents(pkgAliases, modulesDir) {
    const pkgs = await Promise.all(pkgAliases.map((alias) => path_1.default.join(modulesDir, alias)).map(read_package_json_1.safeReadPackageJsonFromDir));
    return (0, zipWith_1.default)((manifest, alias) => {
        if (!manifest)
            return null;
        return {
            alias,
            name: manifest.name,
            version: manifest.version,
        };
    }, pkgs, pkgAliases)
        .filter(Boolean);
}
//# sourceMappingURL=index.js.map