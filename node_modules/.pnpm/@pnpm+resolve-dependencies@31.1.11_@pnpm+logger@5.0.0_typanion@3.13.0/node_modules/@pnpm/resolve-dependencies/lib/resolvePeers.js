"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePeers = void 0;
const filenamify_1 = __importDefault(require("filenamify"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const core_1 = require("@yarnpkg/core");
const dependency_path_1 = require("@pnpm/dependency-path");
const map_1 = __importDefault(require("ramda/src/map"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const scan_1 = __importDefault(require("ramda/src/scan"));
const mergePeers_1 = require("./mergePeers");
const nodeIdUtils_1 = require("./nodeIdUtils");
function resolvePeers(opts) {
    const depGraph = {};
    const pathsByNodeId = new Map();
    const depPathsByPkgId = new Map();
    const _createPkgsByName = createPkgsByName.bind(null, opts.dependenciesTree);
    const rootPkgsByName = opts.resolvePeersFromWorkspaceRoot ? getRootPkgsByName(opts.dependenciesTree, opts.projects) : {};
    const peerDependencyIssuesByProjects = {};
    for (const { directNodeIdsByAlias, topParents, rootDir, id } of opts.projects) {
        const peerDependencyIssues = { bad: {}, missing: {} };
        const pkgsByName = {
            ...rootPkgsByName,
            ..._createPkgsByName({ directNodeIdsByAlias, topParents }),
        };
        resolvePeersOfChildren(directNodeIdsByAlias, pkgsByName, {
            dependenciesTree: opts.dependenciesTree,
            depGraph,
            lockfileDir: opts.lockfileDir,
            pathsByNodeId,
            depPathsByPkgId,
            peersCache: new Map(),
            peerDependencyIssues,
            purePkgs: new Set(),
            rootDir,
            virtualStoreDir: opts.virtualStoreDir,
        });
        if (Object.keys(peerDependencyIssues.bad).length > 0 || Object.keys(peerDependencyIssues.missing).length > 0) {
            peerDependencyIssuesByProjects[id] = {
                ...peerDependencyIssues,
                ...(0, mergePeers_1.mergePeers)(peerDependencyIssues.missing),
            };
        }
    }
    Object.values(depGraph).forEach((node) => {
        node.children = (0, map_1.default)((childNodeId) => pathsByNodeId.get(childNodeId) ?? childNodeId, node.children);
    });
    const dependenciesByProjectId = {};
    for (const { directNodeIdsByAlias, id } of opts.projects) {
        dependenciesByProjectId[id] = (0, map_1.default)((nodeId) => pathsByNodeId.get(nodeId), directNodeIdsByAlias);
    }
    if (opts.dedupePeerDependents) {
        const duplicates = Array.from(depPathsByPkgId.values()).filter((item) => item.size > 1);
        const allDepPathsMap = deduplicateAll(depGraph, duplicates);
        for (const { id } of opts.projects) {
            dependenciesByProjectId[id] = (0, map_1.default)((depPath) => allDepPathsMap[depPath] ?? depPath, dependenciesByProjectId[id]);
        }
    }
    return {
        dependenciesGraph: depGraph,
        dependenciesByProjectId,
        peerDependencyIssuesByProjects,
    };
}
exports.resolvePeers = resolvePeers;
function nodeDepsCount(node) {
    return Object.keys(node.children).length + node.resolvedPeerNames.size;
}
function deduplicateAll(depGraph, duplicates) {
    const { depPathsMap, remainingDuplicates } = deduplicateDepPaths(duplicates, depGraph);
    if (remainingDuplicates.length === duplicates.length) {
        return depPathsMap;
    }
    Object.values(depGraph).forEach((node) => {
        node.children = (0, map_1.default)((childDepPath) => depPathsMap[childDepPath] ?? childDepPath, node.children);
    });
    if (Object.keys(depPathsMap).length > 0) {
        return {
            ...depPathsMap,
            ...deduplicateAll(depGraph, remainingDuplicates),
        };
    }
    return depPathsMap;
}
function deduplicateDepPaths(duplicates, depGraph) {
    const depCountSorter = (depPath1, depPath2) => nodeDepsCount(depGraph[depPath1]) - nodeDepsCount(depGraph[depPath2]);
    const depPathsMap = {};
    const remainingDuplicates = [];
    for (const depPaths of duplicates) {
        const unresolvedDepPaths = new Set(depPaths.values());
        let currentDepPaths = [...depPaths].sort(depCountSorter);
        while (currentDepPaths.length) {
            const depPath1 = currentDepPaths.pop();
            const nextDepPaths = [];
            while (currentDepPaths.length) {
                const depPath2 = currentDepPaths.pop();
                if (isCompatibleAndHasMoreDeps(depGraph, depPath1, depPath2)) {
                    depPathsMap[depPath2] = depPath1;
                    unresolvedDepPaths.delete(depPath1);
                    unresolvedDepPaths.delete(depPath2);
                }
                else {
                    nextDepPaths.push(depPath2);
                }
            }
            nextDepPaths.push(...currentDepPaths);
            currentDepPaths = nextDepPaths.sort(depCountSorter);
        }
        if (unresolvedDepPaths.size) {
            remainingDuplicates.push(unresolvedDepPaths);
        }
    }
    return {
        depPathsMap,
        remainingDuplicates,
    };
}
function isCompatibleAndHasMoreDeps(depGraph, depPath1, depPath2) {
    const node1 = depGraph[depPath1];
    const node2 = depGraph[depPath2];
    if (nodeDepsCount(node1) < nodeDepsCount(node2))
        return false;
    const node1DepPathsSet = new Set(Object.values(node1.children));
    const node2DepPaths = Object.values(node2.children);
    if (!node2DepPaths.every((depPath) => node1DepPathsSet.has(depPath)))
        return false;
    for (const depPath of node2.resolvedPeerNames) {
        if (!node1.resolvedPeerNames.has(depPath))
            return false;
    }
    return true;
}
function getRootPkgsByName(dependenciesTree, projects) {
    const rootProject = projects.length > 1 ? projects.find(({ id }) => id === '.') : null;
    return rootProject == null ? {} : createPkgsByName(dependenciesTree, rootProject);
}
function createPkgsByName(dependenciesTree, { directNodeIdsByAlias, topParents }) {
    const parentRefs = toPkgByName(Object
        .keys(directNodeIdsByAlias)
        .map((alias) => ({
        alias,
        node: dependenciesTree.get(directNodeIdsByAlias[alias]),
        nodeId: directNodeIdsByAlias[alias],
    })));
    const _updateParentRefs = updateParentRefs.bind(null, parentRefs);
    for (const { name, version, alias, linkedDir } of topParents) {
        const pkg = {
            alias,
            depth: 0,
            version,
            nodeId: linkedDir,
        };
        _updateParentRefs(name, pkg);
        if (alias && alias !== name) {
            _updateParentRefs(alias, pkg);
        }
    }
    return parentRefs;
}
function resolvePeersOfNode(nodeId, parentParentPkgs, ctx) {
    const node = ctx.dependenciesTree.get(nodeId);
    if (node.depth === -1)
        return { resolvedPeers: new Map(), missingPeers: new Set() };
    const resolvedPackage = node.resolvedPackage;
    if (ctx.purePkgs.has(resolvedPackage.depPath) &&
        ctx.depGraph[resolvedPackage.depPath].depth <= node.depth &&
        Object.keys(resolvedPackage.peerDependencies).length === 0) {
        ctx.pathsByNodeId.set(nodeId, resolvedPackage.depPath);
        return { resolvedPeers: new Map(), missingPeers: new Set() };
    }
    if (typeof node.children === 'function') {
        node.children = node.children();
    }
    const children = node.children;
    const parentPkgs = Object.keys(children).length === 0
        ? parentParentPkgs
        : Object.assign(Object.create(parentParentPkgs), toPkgByName(Object.entries(children).map(([alias, nodeId]) => ({
            alias,
            node: ctx.dependenciesTree.get(nodeId),
            nodeId,
        }))));
    const hit = ctx.peersCache.get(resolvedPackage.depPath)?.find((cache) => {
        for (const [name, cachedNodeId] of cache.resolvedPeers) {
            const parentPkgNodeId = parentPkgs[name]?.nodeId;
            if (!parentPkgNodeId || !cachedNodeId)
                return false;
            if (parentPkgNodeId === cachedNodeId)
                continue;
            if (ctx.pathsByNodeId.has(cachedNodeId) &&
                ctx.pathsByNodeId.get(cachedNodeId) === ctx.pathsByNodeId.get(parentPkgNodeId))
                continue;
            if (!ctx.dependenciesTree.has(parentPkgNodeId) && parentPkgNodeId.startsWith('link:')) {
                return false;
            }
            const parentDepPath = ctx.dependenciesTree.get(parentPkgNodeId).resolvedPackage.depPath;
            if (!ctx.purePkgs.has(parentDepPath))
                return false;
            const cachedDepPath = ctx.dependenciesTree.get(cachedNodeId).resolvedPackage.depPath;
            if (parentDepPath !== cachedDepPath)
                return false;
        }
        for (const missingPeer of cache.missingPeers) {
            if (parentPkgs[missingPeer])
                return false;
        }
        return true;
    });
    if (hit != null) {
        ctx.pathsByNodeId.set(nodeId, hit.depPath);
        ctx.depGraph[hit.depPath].depth = Math.min(ctx.depGraph[hit.depPath].depth, node.depth);
        return {
            missingPeers: hit.missingPeers,
            resolvedPeers: hit.resolvedPeers,
        };
    }
    const { resolvedPeers: unknownResolvedPeersOfChildren, missingPeers: missingPeersOfChildren, } = resolvePeersOfChildren(children, parentPkgs, ctx);
    const { resolvedPeers, missingPeers } = Object.keys(resolvedPackage.peerDependencies).length === 0
        ? { resolvedPeers: new Map(), missingPeers: new Set() }
        : _resolvePeers({
            currentDepth: node.depth,
            dependenciesTree: ctx.dependenciesTree,
            lockfileDir: ctx.lockfileDir,
            nodeId,
            parentPkgs,
            peerDependencyIssues: ctx.peerDependencyIssues,
            resolvedPackage,
            rootDir: ctx.rootDir,
        });
    const allResolvedPeers = unknownResolvedPeersOfChildren;
    for (const [k, v] of resolvedPeers) {
        allResolvedPeers.set(k, v);
    }
    allResolvedPeers.delete(node.resolvedPackage.name);
    const allMissingPeers = new Set();
    for (const peer of missingPeersOfChildren) {
        allMissingPeers.add(peer);
    }
    for (const peer of missingPeers) {
        allMissingPeers.add(peer);
    }
    let depPath;
    if (allResolvedPeers.size === 0) {
        depPath = resolvedPackage.depPath;
    }
    else {
        const peersFolderSuffix = (0, dependency_path_1.createPeersFolderSuffix)([...allResolvedPeers.entries()]
            .map(([alias, nodeId]) => {
            if (nodeId.startsWith('link:')) {
                const linkedDir = nodeId.slice(5);
                return {
                    name: alias,
                    version: (0, filenamify_1.default)(linkedDir, { replacement: '+' }),
                };
            }
            const { name, version } = ctx.dependenciesTree.get(nodeId).resolvedPackage;
            return { name, version };
        }));
        depPath = `${resolvedPackage.depPath}${peersFolderSuffix}`;
    }
    const localLocation = path_1.default.join(ctx.virtualStoreDir, (0, dependency_path_1.depPathToFilename)(depPath));
    const modules = path_1.default.join(localLocation, 'node_modules');
    const isPure = allResolvedPeers.size === 0 && allMissingPeers.size === 0;
    if (isPure) {
        ctx.purePkgs.add(resolvedPackage.depPath);
    }
    else {
        const cache = {
            missingPeers: allMissingPeers,
            depPath,
            resolvedPeers: allResolvedPeers,
        };
        if (ctx.peersCache.has(resolvedPackage.depPath)) {
            ctx.peersCache.get(resolvedPackage.depPath).push(cache);
        }
        else {
            ctx.peersCache.set(resolvedPackage.depPath, [cache]);
        }
    }
    ctx.pathsByNodeId.set(nodeId, depPath);
    if (ctx.depPathsByPkgId != null) {
        if (!ctx.depPathsByPkgId.has(resolvedPackage.depPath)) {
            ctx.depPathsByPkgId.set(resolvedPackage.depPath, new Set());
        }
        if (!ctx.depPathsByPkgId.get(resolvedPackage.depPath).has(depPath)) {
            ctx.depPathsByPkgId.get(resolvedPackage.depPath).add(depPath);
        }
    }
    const peerDependencies = { ...resolvedPackage.peerDependencies };
    if (!ctx.depGraph[depPath] || ctx.depGraph[depPath].depth > node.depth) {
        const dir = path_1.default.join(modules, resolvedPackage.name);
        const transitivePeerDependencies = new Set();
        for (const unknownPeer of unknownResolvedPeersOfChildren.keys()) {
            if (!peerDependencies[unknownPeer]) {
                transitivePeerDependencies.add(unknownPeer);
            }
        }
        for (const unknownPeer of missingPeersOfChildren) {
            if (!peerDependencies[unknownPeer]) {
                transitivePeerDependencies.add(unknownPeer);
            }
        }
        ctx.depGraph[depPath] = {
            ...node.resolvedPackage,
            children: Object.assign(getPreviouslyResolvedChildren(nodeId, ctx.dependenciesTree), children, Object.fromEntries(resolvedPeers.entries())),
            depPath,
            depth: node.depth,
            dir,
            installable: node.installable,
            isPure,
            modules,
            peerDependencies,
            transitivePeerDependencies,
            resolvedPeerNames: new Set(allResolvedPeers.keys()),
        };
    }
    return { resolvedPeers: allResolvedPeers, missingPeers: allMissingPeers };
}
// When a package has itself in the subdependencies, so there's a cycle,
// pnpm will break the cycle, when it first repeats itself.
// However, when the cycle is broken up, the last repeated package is removed
// from the dependencies of the parent package.
// So we need to merge all the children of all the parent packages with same ID as the resolved package.
// This way we get all the children that were removed, when ending cycles.
function getPreviouslyResolvedChildren(nodeId, dependenciesTree) {
    const parentIds = (0, nodeIdUtils_1.splitNodeId)(nodeId);
    const ownId = parentIds.pop();
    const allChildren = {};
    if (!ownId || !parentIds.includes(ownId))
        return allChildren;
    const nodeIdChunks = parentIds.join('>').split(`>${ownId}>`);
    nodeIdChunks.pop();
    nodeIdChunks.reduce((accNodeId, part) => {
        accNodeId += `>${part}>${ownId}`;
        const parentNode = dependenciesTree.get(`${accNodeId}>`);
        if (typeof parentNode.children === 'function') {
            parentNode.children = parentNode.children();
        }
        Object.assign(allChildren, parentNode.children);
        return accNodeId;
    }, '');
    return allChildren;
}
function resolvePeersOfChildren(children, parentPkgs, ctx) {
    const allResolvedPeers = new Map();
    const allMissingPeers = new Set();
    for (const childNodeId of Object.values(children)) {
        const { resolvedPeers, missingPeers } = resolvePeersOfNode(childNodeId, parentPkgs, ctx);
        for (const [k, v] of resolvedPeers) {
            allResolvedPeers.set(k, v);
        }
        for (const missingPeer of missingPeers) {
            allMissingPeers.add(missingPeer);
        }
    }
    const unknownResolvedPeersOfChildren = new Map();
    for (const [alias, v] of allResolvedPeers) {
        if (!children[alias]) {
            unknownResolvedPeersOfChildren.set(alias, v);
        }
    }
    return { resolvedPeers: unknownResolvedPeersOfChildren, missingPeers: allMissingPeers };
}
function _resolvePeers(ctx) {
    const resolvedPeers = new Map();
    const missingPeers = new Set();
    for (const peerName in ctx.resolvedPackage.peerDependencies) { // eslint-disable-line:forin
        const peerVersionRange = ctx.resolvedPackage.peerDependencies[peerName].replace(/^workspace:/, '');
        const resolved = ctx.parentPkgs[peerName];
        const optionalPeer = ctx.resolvedPackage.peerDependenciesMeta?.[peerName]?.optional === true;
        if (!resolved) {
            missingPeers.add(peerName);
            const location = getLocationFromNodeIdAndPkg({
                dependenciesTree: ctx.dependenciesTree,
                nodeId: ctx.nodeId,
                pkg: ctx.resolvedPackage,
            });
            if (!ctx.peerDependencyIssues.missing[peerName]) {
                ctx.peerDependencyIssues.missing[peerName] = [];
            }
            ctx.peerDependencyIssues.missing[peerName].push({
                parents: location.parents,
                optional: optionalPeer,
                wantedRange: peerVersionRange,
            });
            continue;
        }
        if (!core_1.semverUtils.satisfiesWithPrereleases(resolved.version, peerVersionRange, true)) {
            const location = getLocationFromNodeIdAndPkg({
                dependenciesTree: ctx.dependenciesTree,
                nodeId: ctx.nodeId,
                pkg: ctx.resolvedPackage,
            });
            if (!ctx.peerDependencyIssues.bad[peerName]) {
                ctx.peerDependencyIssues.bad[peerName] = [];
            }
            const peerLocation = resolved.nodeId == null
                ? []
                : getLocationFromNodeId({
                    dependenciesTree: ctx.dependenciesTree,
                    nodeId: resolved.nodeId,
                }).parents;
            ctx.peerDependencyIssues.bad[peerName].push({
                foundVersion: resolved.version,
                resolvedFrom: peerLocation,
                parents: location.parents,
                optional: optionalPeer,
                wantedRange: peerVersionRange,
            });
        }
        if (resolved?.nodeId)
            resolvedPeers.set(peerName, resolved.nodeId);
    }
    return { resolvedPeers, missingPeers };
}
function getLocationFromNodeIdAndPkg({ dependenciesTree, nodeId, pkg, }) {
    const { projectId, parents } = getLocationFromNodeId({ dependenciesTree, nodeId });
    parents.push({ name: pkg.name, version: pkg.version });
    return {
        projectId,
        parents,
    };
}
function getLocationFromNodeId({ dependenciesTree, nodeId, }) {
    const parts = (0, nodeIdUtils_1.splitNodeId)(nodeId).slice(0, -1);
    const parents = (0, scan_1.default)((prevNodeId, pkgId) => (0, nodeIdUtils_1.createNodeId)(prevNodeId, pkgId), '>', parts)
        .slice(2)
        .map((nid) => (0, pick_1.default)(['name', 'version'], dependenciesTree.get(nid).resolvedPackage));
    return {
        projectId: parts[0],
        parents,
    };
}
function toPkgByName(nodes) {
    const pkgsByName = {};
    const _updateParentRefs = updateParentRefs.bind(null, pkgsByName);
    for (const { alias, node, nodeId } of nodes) {
        const pkg = {
            alias,
            depth: node.depth,
            nodeId,
            version: node.resolvedPackage.version,
        };
        _updateParentRefs(alias, pkg);
        if (alias !== node.resolvedPackage.name) {
            _updateParentRefs(node.resolvedPackage.name, pkg);
        }
    }
    return pkgsByName;
}
function updateParentRefs(parentRefs, newAlias, pkg) {
    const existing = parentRefs[newAlias];
    if (existing) {
        const existingHasAlias = existing.alias != null && existing.alias !== newAlias;
        if (!existingHasAlias)
            return;
        const newHasAlias = pkg.alias != null && pkg.alias !== newAlias;
        if (newHasAlias && semver_1.default.gte(existing.version, pkg.version))
            return;
    }
    parentRefs[newAlias] = pkg;
}
//# sourceMappingURL=resolvePeers.js.map