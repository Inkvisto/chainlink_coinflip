import { type Lockfile, type ResolvedDependencies } from '@pnpm/lockfile-types';
import { type DirectoryResolution, type PreferredVersions, type Resolution, type WorkspacePackages } from '@pnpm/resolver-base';
import { type PackageFilesResponse, type StoreController } from '@pnpm/store-controller-types';
import { type AllowedDeprecatedVersions, type Dependencies, type DependencyManifest, type PackageManifest, type PatchFile, type PeerDependenciesMeta, type ReadPackageHook, type Registries } from '@pnpm/types';
import { type WantedDependency } from './getNonDevWantedDependencies';
import { type SafePromiseDefer } from 'safe-promise-defer';
export declare function nodeIdToParents(nodeId: string, resolvedPackagesByDepPath: ResolvedPackagesByDepPath): {
    id: string;
    name: string;
    version: string;
}[];
export interface ChildrenMap {
    [alias: string]: string;
}
export type DependenciesTreeNode<T> = {
    children: (() => ChildrenMap) | ChildrenMap;
    installable: boolean;
} & ({
    resolvedPackage: T & {
        name: string;
        version: string;
    };
    depth: number;
} | {
    resolvedPackage: {
        name: string;
        version: string;
    };
    depth: -1;
});
export type DependenciesTree<T> = Map<string, DependenciesTreeNode<T>>;
export type ResolvedPackagesByDepPath = Record<string, ResolvedPackage>;
export interface LinkedDependency {
    isLinkedDependency: true;
    optional: boolean;
    depPath: string;
    dev: boolean;
    resolution: DirectoryResolution;
    pkgId: string;
    version: string;
    name: string;
    normalizedPref?: string;
    alias: string;
}
export interface PendingNode {
    alias: string;
    nodeId: string;
    resolvedPackage: ResolvedPackage;
    depth: number;
    installable: boolean;
}
export interface ChildrenByParentDepPath {
    [depPath: string]: Array<{
        alias: string;
        depPath: string;
    }>;
}
export interface ResolutionContext {
    autoInstallPeers: boolean;
    allowBuild?: (pkgName: string) => boolean;
    allowedDeprecatedVersions: AllowedDeprecatedVersions;
    appliedPatches: Set<string>;
    updatedSet: Set<string>;
    defaultTag: string;
    dryRun: boolean;
    forceFullResolution: boolean;
    ignoreScripts?: boolean;
    resolvedPackagesByDepPath: ResolvedPackagesByDepPath;
    outdatedDependencies: {
        [pkgId: string]: string;
    };
    childrenByParentDepPath: ChildrenByParentDepPath;
    patchedDependencies?: Record<string, PatchFile>;
    pendingNodes: PendingNode[];
    wantedLockfile: Lockfile;
    currentLockfile: Lockfile;
    linkWorkspacePackagesDepth: number;
    lockfileDir: string;
    storeController: StoreController;
    skipped: Set<string>;
    dependenciesTree: DependenciesTree<ResolvedPackage>;
    force: boolean;
    preferWorkspacePackages?: boolean;
    readPackageHook?: ReadPackageHook;
    engineStrict: boolean;
    nodeVersion: string;
    pnpmVersion: string;
    registries: Registries;
    resolutionMode?: 'highest' | 'time-based' | 'lowest-direct';
    virtualStoreDir: string;
    workspacePackages?: WorkspacePackages;
    missingPeersOfChildrenByPkgId: Record<string, {
        parentImporterId: string;
        missingPeersOfChildren: MissingPeersOfChildren;
    }>;
}
export type MissingPeers = Record<string, string>;
export type ResolvedPeers = Record<string, PkgAddress>;
interface MissingPeersOfChildren {
    resolve: (missingPeers: MissingPeers) => void;
    reject: (err: Error) => void;
    get: () => Promise<MissingPeers>;
    resolved?: boolean;
}
export type PkgAddress = {
    alias: string;
    depIsLinked: boolean;
    depPath: string;
    isNew: boolean;
    isLinkedDependency?: false;
    nodeId: string;
    pkgId: string;
    normalizedPref?: string;
    installable: boolean;
    pkg: PackageManifest;
    version?: string;
    updated: boolean;
    rootDir: string;
    missingPeers: MissingPeers;
    missingPeersOfChildren?: MissingPeersOfChildren;
    publishedAt?: string;
} & ({
    isLinkedDependency: true;
    version: string;
} | {
    isLinkedDependency: undefined;
});
export interface ResolvedPackage {
    id: string;
    resolution: Resolution;
    prod: boolean;
    dev: boolean;
    optional: boolean;
    fetchingFiles: () => Promise<PackageFilesResponse>;
    fetchingBundledManifest?: () => Promise<DependencyManifest | undefined>;
    filesIndexFile: string;
    finishing: () => Promise<void>;
    name: string;
    version: string;
    peerDependencies: Dependencies;
    peerDependenciesMeta?: PeerDependenciesMeta;
    optionalDependencies: Set<string>;
    hasBin: boolean;
    hasBundledDependencies: boolean;
    patchFile?: PatchFile;
    prepare: boolean;
    depPath: string;
    requiresBuild: boolean | SafePromiseDefer<boolean>;
    additionalInfo: {
        deprecated?: string;
        bundleDependencies?: string[];
        bundledDependencies?: string[];
        engines?: {
            node?: string;
            npm?: string;
        };
        cpu?: string[];
        os?: string[];
        libc?: string[];
    };
    parentImporterIds: Set<string>;
}
type ParentPkg = Pick<PkgAddress, 'nodeId' | 'installable' | 'depPath' | 'rootDir'>;
export type ParentPkgAliases = Record<string, PkgAddress | true>;
export type UpdateMatchingFunction = (pkgName: string) => boolean;
interface ResolvedDependenciesOptions {
    currentDepth: number;
    parentPkg: ParentPkg;
    parentPkgAliases: ParentPkgAliases;
    preferredDependencies?: ResolvedDependencies;
    proceed: boolean;
    publishedBy?: Date;
    pickLowestVersion?: boolean;
    resolvedDependencies?: ResolvedDependencies;
    updateMatching?: UpdateMatchingFunction;
    updateDepth: number;
    prefix: string;
}
interface PeersResolutionResult {
    missingPeers: MissingPeers;
    resolvedPeers: ResolvedPeers;
}
interface ResolvedRootDependenciesResult {
    pkgAddressesByImporters: Array<Array<PkgAddress | LinkedDependency>>;
    time?: Record<string, string>;
}
export declare function resolveRootDependencies(ctx: ResolutionContext, importers: ImporterToResolve[]): Promise<ResolvedRootDependenciesResult>;
interface ResolvedDependenciesResult {
    pkgAddresses: Array<PkgAddress | LinkedDependency>;
    resolvingPeers: Promise<PeersResolutionResult>;
}
export interface ImporterToResolve {
    updatePackageManifest: boolean;
    preferredVersions: PreferredVersions;
    parentPkgAliases: ParentPkgAliases;
    wantedDependencies: Array<WantedDependency & {
        updateDepth?: number;
    }>;
    options: Omit<ResolvedDependenciesOptions, 'parentPkgAliases' | 'publishedBy'>;
}
export declare function resolveDependencies(ctx: ResolutionContext, preferredVersions: PreferredVersions, wantedDependencies: Array<WantedDependency & {
    updateDepth?: number;
}>, options: ResolvedDependenciesOptions): Promise<ResolvedDependenciesResult>;
export declare function createNodeIdForLinkedLocalPkg(lockfileDir: string, pkgDir: string): string;
export {};
