"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVersionsOverrider = void 0;
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const partition_1 = __importDefault(require("ramda/src/partition"));
const error_1 = require("@pnpm/error");
const parse_overrides_1 = require("@pnpm/parse-overrides");
const normalize_path_1 = __importDefault(require("normalize-path"));
const isSubRange_1 = require("./isSubRange");
function createVersionsOverrider(overrides, rootDir) {
    const parsedOverrides = tryParseOverrides(overrides);
    const [versionOverrides, genericVersionOverrides] = (0, partition_1.default)(({ parentPkg }) => parentPkg != null, parsedOverrides
        .map((override) => {
        let linkTarget;
        if (override.newPref.startsWith('link:')) {
            linkTarget = path_1.default.join(rootDir, override.newPref.substring(5));
        }
        let linkFileTarget;
        if (override.newPref.startsWith('file:')) {
            const pkgPath = override.newPref.substring(5);
            linkFileTarget = path_1.default.isAbsolute(pkgPath) ? pkgPath : path_1.default.join(rootDir, pkgPath);
        }
        return {
            ...override,
            linkTarget,
            linkFileTarget,
        };
    }));
    return ((manifest, dir) => {
        const versionOverridesWithParent = versionOverrides.filter(({ parentPkg }) => {
            return (parentPkg.name === manifest.name &&
                (!parentPkg.pref || semver_1.default.satisfies(manifest.version, parentPkg.pref)));
        });
        overrideDepsOfPkg({ manifest, dir }, versionOverridesWithParent, genericVersionOverrides);
        return manifest;
    });
}
exports.createVersionsOverrider = createVersionsOverrider;
function tryParseOverrides(overrides) {
    try {
        return (0, parse_overrides_1.parseOverrides)(overrides);
    }
    catch (e) {
        throw new error_1.PnpmError('INVALID_OVERRIDES_SELECTOR', `${e.message} in pnpm.overrides`);
    }
}
function overrideDepsOfPkg({ manifest, dir }, versionOverrides, genericVersionOverrides) {
    if (manifest.dependencies != null)
        overrideDeps(versionOverrides, genericVersionOverrides, manifest.dependencies, dir);
    if (manifest.optionalDependencies != null)
        overrideDeps(versionOverrides, genericVersionOverrides, manifest.optionalDependencies, dir);
    if (manifest.devDependencies != null)
        overrideDeps(versionOverrides, genericVersionOverrides, manifest.devDependencies, dir);
}
function overrideDeps(versionOverrides, genericVersionOverrides, deps, dir) {
    for (const [name, pref] of Object.entries(deps)) {
        const versionOverride = pickMostSpecificVersionOverride(versionOverrides.filter(({ targetPkg }) => targetPkg.name === name && (0, isSubRange_1.isSubRange)(targetPkg.pref, pref))) ??
            pickMostSpecificVersionOverride(genericVersionOverrides.filter(({ targetPkg }) => targetPkg.name === name && (0, isSubRange_1.isSubRange)(targetPkg.pref, pref)));
        if (!versionOverride)
            continue;
        if (versionOverride.linkTarget && dir) {
            deps[versionOverride.targetPkg.name] = `link:${(0, normalize_path_1.default)(path_1.default.relative(dir, versionOverride.linkTarget))}`;
            continue;
        }
        if (versionOverride.linkFileTarget) {
            deps[versionOverride.targetPkg.name] = `file:${versionOverride.linkFileTarget}`;
            continue;
        }
        deps[versionOverride.targetPkg.name] = versionOverride.newPref;
    }
}
function pickMostSpecificVersionOverride(versionOverrides) {
    return versionOverrides.sort((a, b) => (0, isSubRange_1.isSubRange)(b.targetPkg.pref ?? '', a.targetPkg.pref ?? '') ? -1 : 1)[0];
}
//# sourceMappingURL=createVersionsOverrider.js.map