"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPeerDependencyPatcher = void 0;
const semver_1 = __importDefault(require("semver"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const error_1 = require("@pnpm/error");
const parse_overrides_1 = require("@pnpm/parse-overrides");
const matcher_1 = require("@pnpm/matcher");
const isSubRange_1 = require("./isSubRange");
function createPeerDependencyPatcher(peerDependencyRules) {
    const ignoreMissingPatterns = [...new Set(peerDependencyRules.ignoreMissing ?? [])];
    const ignoreMissingMatcher = (0, matcher_1.createMatcher)(ignoreMissingPatterns);
    const allowAnyPatterns = [...new Set(peerDependencyRules.allowAny ?? [])];
    const allowAnyMatcher = (0, matcher_1.createMatcher)(allowAnyPatterns);
    const { allowedVersionsMatchAll, allowedVersionsByParentPkgName } = parseAllowedVersions(peerDependencyRules.allowedVersions ?? {});
    const _getAllowedVersionsByParentPkg = getAllowedVersionsByParentPkg.bind(null, allowedVersionsByParentPkgName);
    return ((pkg) => {
        if ((0, isEmpty_1.default)(pkg.peerDependencies))
            return pkg;
        const allowedVersions = {
            ...allowedVersionsMatchAll,
            ..._getAllowedVersionsByParentPkg(pkg),
        };
        for (const [peerName, peerVersion] of Object.entries(pkg.peerDependencies ?? {})) {
            if (ignoreMissingMatcher(peerName) &&
                !pkg.peerDependenciesMeta?.[peerName]?.optional) {
                pkg.peerDependenciesMeta = pkg.peerDependenciesMeta ?? {};
                pkg.peerDependenciesMeta[peerName] = {
                    optional: true,
                };
            }
            if (allowAnyMatcher(peerName)) {
                pkg.peerDependencies[peerName] = '*';
                continue;
            }
            if (!allowedVersions?.[peerName] || peerVersion === '*') {
                continue;
            }
            if (allowedVersions?.[peerName].includes('*')) {
                pkg.peerDependencies[peerName] = '*';
                continue;
            }
            const currentVersions = parseVersions(pkg.peerDependencies[peerName]);
            allowedVersions[peerName].forEach(allowedVersion => {
                if (!currentVersions.includes(allowedVersion)) {
                    currentVersions.push(allowedVersion);
                }
            });
            pkg.peerDependencies[peerName] = currentVersions.join(' || ');
        }
        return pkg;
    });
}
exports.createPeerDependencyPatcher = createPeerDependencyPatcher;
function parseAllowedVersions(allowedVersions) {
    const overrides = tryParseAllowedVersions(allowedVersions);
    const allowedVersionsMatchAll = {};
    const allowedVersionsByParentPkgName = {};
    for (const { parentPkg, targetPkg, newPref } of overrides) {
        const ranges = parseVersions(newPref);
        if (!parentPkg) {
            allowedVersionsMatchAll[targetPkg.name] = ranges;
            continue;
        }
        if (!allowedVersionsByParentPkgName[parentPkg.name]) {
            allowedVersionsByParentPkgName[parentPkg.name] = [];
        }
        allowedVersionsByParentPkgName[parentPkg.name].push({
            parentPkg,
            targetPkg,
            ranges,
        });
    }
    return {
        allowedVersionsMatchAll,
        allowedVersionsByParentPkgName,
    };
}
function tryParseAllowedVersions(allowedVersions) {
    try {
        return (0, parse_overrides_1.parseOverrides)(allowedVersions ?? {});
    }
    catch (err) {
        throw new error_1.PnpmError('INVALID_ALLOWED_VERSION_SELECTOR', `${err.message} in pnpm.peerDependencyRules.allowedVersions`);
    }
}
function getAllowedVersionsByParentPkg(allowedVersionsByParentPkgName, pkg) {
    if (!pkg.name || !allowedVersionsByParentPkgName[pkg.name])
        return {};
    return allowedVersionsByParentPkgName[pkg.name]
        .reduce((acc, { targetPkg, parentPkg, ranges }) => {
        if (!pkg.peerDependencies[targetPkg.name])
            return acc;
        if (!parentPkg.pref || pkg.version &&
            ((0, isSubRange_1.isSubRange)(parentPkg.pref, pkg.version) || semver_1.default.satisfies(pkg.version, parentPkg.pref))) {
            acc[targetPkg.name] = ranges;
        }
        return acc;
    }, {});
}
function parseVersions(versions) {
    return versions.split('||').map(v => v.trim());
}
//# sourceMappingURL=createPeerDependencyPatcher.js.map