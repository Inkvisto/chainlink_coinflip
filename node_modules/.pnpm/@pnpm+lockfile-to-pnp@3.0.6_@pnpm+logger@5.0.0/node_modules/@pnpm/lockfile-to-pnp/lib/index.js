"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lockfileToPackageRegistry = exports.writePnpFile = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const dependency_path_1 = require("@pnpm/dependency-path");
const pnp_1 = require("@yarnpkg/pnp");
const normalize_path_1 = __importDefault(require("normalize-path"));
async function writePnpFile(lockfile, opts) {
    const packageRegistry = lockfileToPackageRegistry(lockfile, opts);
    const loaderFile = (0, pnp_1.generateInlinedScript)({
        blacklistedLocations: undefined,
        dependencyTreeRoots: [],
        ignorePattern: undefined,
        packageRegistry,
        shebang: undefined,
    });
    await fs_1.promises.writeFile(path_1.default.join(opts.lockfileDir, '.pnp.cjs'), loaderFile, 'utf8');
}
exports.writePnpFile = writePnpFile;
function lockfileToPackageRegistry(lockfile, opts) {
    const packageRegistry = new Map();
    for (const [importerId, importer] of Object.entries(lockfile.importers)) {
        if (importerId === '.') {
            const packageStore = new Map([
                [
                    null,
                    {
                        packageDependencies: new Map([
                            ...((importer.dependencies != null) ? toPackageDependenciesMap(lockfile, importer.dependencies) : []),
                            ...((importer.optionalDependencies != null) ? toPackageDependenciesMap(lockfile, importer.optionalDependencies) : []),
                            ...((importer.devDependencies != null) ? toPackageDependenciesMap(lockfile, importer.devDependencies) : []),
                        ]),
                        packageLocation: './',
                    },
                ],
            ]);
            packageRegistry.set(null, packageStore);
        }
        else {
            const name = opts.importerNames[importerId];
            const packageStore = new Map([
                [
                    importerId,
                    {
                        packageDependencies: new Map([
                            [name, importerId],
                            ...((importer.dependencies != null) ? toPackageDependenciesMap(lockfile, importer.dependencies, importerId) : []),
                            ...((importer.optionalDependencies != null) ? toPackageDependenciesMap(lockfile, importer.optionalDependencies, importerId) : []),
                            ...((importer.devDependencies != null) ? toPackageDependenciesMap(lockfile, importer.devDependencies, importerId) : []),
                        ]),
                        packageLocation: `./${importerId}`,
                    },
                ],
            ]);
            packageRegistry.set(name, packageStore);
        }
    }
    for (const [relDepPath, pkgSnapshot] of Object.entries(lockfile.packages ?? {})) {
        const { name, version, peersSuffix } = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(relDepPath, pkgSnapshot);
        const pnpVersion = toPnPVersion(version, peersSuffix);
        let packageStore = packageRegistry.get(name);
        if (!packageStore) {
            packageStore = new Map();
            packageRegistry.set(name, packageStore);
        }
        // Seems like this field should always contain a relative path
        let packageLocation = (0, normalize_path_1.default)(path_1.default.relative(opts.lockfileDir, path_1.default.join(opts.virtualStoreDir, (0, dependency_path_1.depPathToFilename)(relDepPath), 'node_modules', name)));
        if (!packageLocation.startsWith('../')) {
            packageLocation = `./${packageLocation}`;
        }
        packageStore.set(pnpVersion, {
            packageDependencies: new Map([
                [name, pnpVersion],
                ...((pkgSnapshot.dependencies != null) ? toPackageDependenciesMap(lockfile, pkgSnapshot.dependencies) : []),
                ...((pkgSnapshot.optionalDependencies != null) ? toPackageDependenciesMap(lockfile, pkgSnapshot.optionalDependencies) : []),
            ]),
            packageLocation,
        });
    }
    return packageRegistry;
}
exports.lockfileToPackageRegistry = lockfileToPackageRegistry;
function toPackageDependenciesMap(lockfile, deps, importerId) {
    return Object.entries(deps).map(([depAlias, ref]) => {
        if (importerId && ref.startsWith('link:')) {
            return [depAlias, path_1.default.join(importerId, ref.slice(5))];
        }
        const relDepPath = (0, dependency_path_1.refToRelative)(ref, depAlias);
        if (!relDepPath)
            return [depAlias, ref];
        const { name, version, peersSuffix } = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(relDepPath, lockfile.packages[relDepPath]);
        const pnpVersion = toPnPVersion(version, peersSuffix);
        if (depAlias === name) {
            return [depAlias, pnpVersion];
        }
        return [depAlias, [name, pnpVersion]];
    });
}
function toPnPVersion(version, peersSuffix) {
    return peersSuffix
        ? `virtual:${version}_${peersSuffix}#${version}`
        : version;
}
//# sourceMappingURL=index.js.map