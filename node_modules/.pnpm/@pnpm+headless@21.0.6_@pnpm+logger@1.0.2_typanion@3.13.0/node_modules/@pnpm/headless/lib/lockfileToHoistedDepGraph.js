"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lockfileToHoistedDepGraph = void 0;
const path_exists_1 = __importDefault(require("path-exists"));
const path_1 = __importDefault(require("path"));
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const package_is_installable_1 = require("@pnpm/package-is-installable");
const real_hoist_1 = require("@pnpm/real-hoist");
const dp = __importStar(require("@pnpm/dependency-path"));
async function lockfileToHoistedDepGraph(lockfile, currentLockfile, opts) {
    let prevGraph;
    if (currentLockfile?.packages != null) {
        prevGraph = (await _lockfileToHoistedDepGraph(currentLockfile, opts)).graph;
    }
    else {
        prevGraph = {};
    }
    return {
        ...(await _lockfileToHoistedDepGraph(lockfile, opts)),
        prevGraph,
    };
}
exports.lockfileToHoistedDepGraph = lockfileToHoistedDepGraph;
async function _lockfileToHoistedDepGraph(lockfile, opts) {
    const tree = (0, real_hoist_1.hoist)(lockfile, {
        hoistingLimits: opts.hoistingLimits,
        externalDependencies: opts.externalDependencies,
        autoInstallPeers: opts.autoInstallPeers,
    });
    const graph = {};
    const modulesDir = path_1.default.join(opts.lockfileDir, 'node_modules');
    const fetchDepsOpts = {
        ...opts,
        lockfile,
        graph,
        pkgLocationsByDepPath: {},
        hoistedLocations: {},
    };
    const hierarchy = {
        [opts.lockfileDir]: await fetchDeps(fetchDepsOpts, modulesDir, tree.dependencies),
    };
    const directDependenciesByImporterId = {
        '.': directDepsMap(Object.keys(hierarchy[opts.lockfileDir]), graph),
    };
    const symlinkedDirectDependenciesByImporterId = { '.': {} };
    await Promise.all(Array.from(tree.dependencies).map(async (rootDep) => {
        const reference = Array.from(rootDep.references)[0];
        if (reference.startsWith('workspace:')) {
            const importerId = reference.replace('workspace:', '');
            const projectDir = path_1.default.join(opts.lockfileDir, importerId);
            const modulesDir = path_1.default.join(projectDir, 'node_modules');
            const nextHierarchy = (await fetchDeps(fetchDepsOpts, modulesDir, rootDep.dependencies));
            hierarchy[projectDir] = nextHierarchy;
            const importer = lockfile.importers[importerId];
            const importerDir = path_1.default.join(opts.lockfileDir, importerId);
            symlinkedDirectDependenciesByImporterId[importerId] = pickLinkedDirectDeps(importer, importerDir, opts.include);
            directDependenciesByImporterId[importerId] = directDepsMap(Object.keys(nextHierarchy), graph);
        }
    }));
    return {
        directDependenciesByImporterId,
        graph,
        hierarchy,
        pkgLocationsByDepPath: fetchDepsOpts.pkgLocationsByDepPath,
        symlinkedDirectDependenciesByImporterId,
        hoistedLocations: fetchDepsOpts.hoistedLocations,
    };
}
function directDepsMap(directDepDirs, graph) {
    return directDepDirs.reduce((acc, dir) => {
        acc[graph[dir].alias] = dir;
        return acc;
    }, {});
}
function pickLinkedDirectDeps(importer, importerDir, include) {
    const rootDeps = {
        ...(include.devDependencies ? importer.devDependencies : {}),
        ...(include.dependencies ? importer.dependencies : {}),
        ...(include.optionalDependencies ? importer.optionalDependencies : {}),
    };
    return Object.entries(rootDeps)
        .reduce((directDeps, [alias, ref]) => {
        if (ref.startsWith('link:')) {
            directDeps[alias] = path_1.default.resolve(importerDir, ref.slice(5));
        }
        return directDeps;
    }, {});
}
async function fetchDeps(opts, modules, deps) {
    const depHierarchy = {};
    await Promise.all(Array.from(deps).map(async (dep) => {
        const depPath = Array.from(dep.references)[0];
        if (opts.skipped.has(depPath) || depPath.startsWith('workspace:'))
            return;
        const pkgSnapshot = opts.lockfile.packages[depPath];
        if (!pkgSnapshot) {
            // it is a link
            return;
        }
        const { name: pkgName, version: pkgVersion } = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, pkgSnapshot);
        const packageId = (0, lockfile_utils_1.packageIdFromSnapshot)(depPath, pkgSnapshot, opts.registries);
        const pkg = {
            name: pkgName,
            version: pkgVersion,
            engines: pkgSnapshot.engines,
            cpu: pkgSnapshot.cpu,
            os: pkgSnapshot.os,
            libc: pkgSnapshot.libc,
        };
        if (!opts.force &&
            (0, package_is_installable_1.packageIsInstallable)(packageId, pkg, {
                engineStrict: opts.engineStrict,
                lockfileDir: opts.lockfileDir,
                nodeVersion: opts.nodeVersion,
                optional: pkgSnapshot.optional === true,
                pnpmVersion: opts.pnpmVersion,
            }) === false) {
            opts.skipped.add(depPath);
            return;
        }
        const dir = path_1.default.join(modules, dep.name);
        const depLocation = path_1.default.relative(opts.lockfileDir, dir);
        const resolution = (0, lockfile_utils_1.pkgSnapshotToResolution)(depPath, pkgSnapshot, opts.registries);
        let fetchResponse;
        // We check for the existence of the package inside node_modules.
        // It will only be missing if the user manually removed it.
        // That shouldn't normally happen but Bit CLI does remove node_modules in component directories:
        // https://github.com/teambit/bit/blob/5e1eed7cd122813ad5ea124df956ee89d661d770/scopes/dependencies/dependency-resolver/dependency-installer.ts#L169
        const skipFetch = opts.currentHoistedLocations?.[depPath]?.includes(depLocation) &&
            await (0, path_exists_1.default)(path_1.default.join(opts.lockfileDir, depLocation));
        const pkgResolution = {
            id: packageId,
            resolution,
        };
        if (skipFetch) {
            const { filesIndexFile } = opts.storeController.getFilesIndexFilePath({
                ignoreScripts: opts.ignoreScripts,
                pkg: pkgResolution,
            });
            fetchResponse = { filesIndexFile }; // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        else {
            try {
                fetchResponse = opts.storeController.fetchPackage({
                    force: false,
                    lockfileDir: opts.lockfileDir,
                    ignoreScripts: opts.ignoreScripts,
                    pkg: pkgResolution,
                    expectedPkg: {
                        name: pkgName,
                        version: pkgVersion,
                    },
                });
                if (fetchResponse instanceof Promise)
                    fetchResponse = await fetchResponse;
            }
            catch (err) { // eslint-disable-line
                if (pkgSnapshot.optional)
                    return;
                throw err;
            }
        }
        opts.graph[dir] = {
            alias: dep.name,
            children: {},
            depPath,
            dir,
            fetchingFiles: fetchResponse.files,
            filesIndexFile: fetchResponse.filesIndexFile,
            finishing: fetchResponse.finishing,
            hasBin: pkgSnapshot.hasBin === true,
            hasBundledDependencies: pkgSnapshot.bundledDependencies != null,
            modules,
            name: pkgName,
            optional: !!pkgSnapshot.optional,
            optionalDependencies: new Set(Object.keys(pkgSnapshot.optionalDependencies ?? {})),
            prepare: pkgSnapshot.prepare === true,
            requiresBuild: pkgSnapshot.requiresBuild === true,
            patchFile: opts.patchedDependencies?.[`${pkgName}@${pkgVersion}`],
        };
        if (!opts.pkgLocationsByDepPath[depPath]) {
            opts.pkgLocationsByDepPath[depPath] = [];
        }
        opts.pkgLocationsByDepPath[depPath].push(dir);
        depHierarchy[dir] = await fetchDeps(opts, path_1.default.join(dir, 'node_modules'), dep.dependencies);
        if (!opts.hoistedLocations[depPath]) {
            opts.hoistedLocations[depPath] = [];
        }
        opts.hoistedLocations[depPath].push(depLocation);
        opts.graph[dir].children = getChildren(pkgSnapshot, opts.pkgLocationsByDepPath, opts);
    }));
    return depHierarchy;
}
function getChildren(pkgSnapshot, pkgLocationsByDepPath, opts) {
    const allDeps = {
        ...pkgSnapshot.dependencies,
        ...(opts.include.optionalDependencies ? pkgSnapshot.optionalDependencies : {}),
    };
    const children = {};
    for (const [childName, childRef] of Object.entries(allDeps)) {
        const childDepPath = dp.refToRelative(childRef, childName);
        if (childDepPath && pkgLocationsByDepPath[childDepPath]) {
            children[childName] = pkgLocationsByDepPath[childDepPath][0];
        }
    }
    return children;
}
//# sourceMappingURL=lockfileToHoistedDepGraph.js.map