"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allProjectsAreUpToDate = void 0;
const path_1 = __importDefault(require("path"));
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const read_package_json_1 = require("@pnpm/read-package-json");
const types_1 = require("@pnpm/types");
const p_every_1 = __importDefault(require("p-every"));
const any_1 = __importDefault(require("ramda/src/any"));
const semver_1 = __importDefault(require("semver"));
async function allProjectsAreUpToDate(projects, opts) {
    const manifestsByDir = opts.workspacePackages ? getWorkspacePackagesByDirectory(opts.workspacePackages) : {};
    const _satisfiesPackageManifest = lockfile_utils_1.satisfiesPackageManifest.bind(null, {
        autoInstallPeers: opts.autoInstallPeers,
        excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
    });
    const _linkedPackagesAreUpToDate = linkedPackagesAreUpToDate.bind(null, {
        linkWorkspacePackages: opts.linkWorkspacePackages,
        manifestsByDir,
        workspacePackages: opts.workspacePackages,
        lockfilePackages: opts.wantedLockfile.packages,
        lockfileDir: opts.lockfileDir,
    });
    return (0, p_every_1.default)(projects, (project) => {
        const importer = opts.wantedLockfile.importers[project.id];
        return !hasLocalTarballDepsInRoot(importer) &&
            _satisfiesPackageManifest(importer, project.manifest).satisfies &&
            _linkedPackagesAreUpToDate({
                dir: project.rootDir,
                manifest: project.manifest,
                snapshot: importer,
            });
    });
}
exports.allProjectsAreUpToDate = allProjectsAreUpToDate;
function getWorkspacePackagesByDirectory(workspacePackages) {
    const workspacePackagesByDirectory = {};
    Object.keys(workspacePackages || {}).forEach((pkgName) => {
        Object.keys(workspacePackages[pkgName] || {}).forEach((pkgVersion) => {
            workspacePackagesByDirectory[workspacePackages[pkgName][pkgVersion].dir] = workspacePackages[pkgName][pkgVersion].manifest;
        });
    });
    return workspacePackagesByDirectory;
}
async function linkedPackagesAreUpToDate({ linkWorkspacePackages, manifestsByDir, workspacePackages, lockfilePackages, lockfileDir, }, project) {
    return (0, p_every_1.default)(types_1.DEPENDENCIES_FIELDS, (depField) => {
        const lockfileDeps = project.snapshot[depField];
        const manifestDeps = project.manifest[depField];
        if ((lockfileDeps == null) || (manifestDeps == null))
            return true;
        const depNames = Object.keys(lockfileDeps);
        return (0, p_every_1.default)(depNames, async (depName) => {
            const currentSpec = manifestDeps[depName];
            if (!currentSpec)
                return true;
            const lockfileRef = lockfileDeps[depName];
            if ((0, lockfile_utils_1.refIsLocalDirectory)(project.snapshot.specifiers[depName])) {
                return isLocalFileDepUpdated(lockfileDir, lockfilePackages?.[lockfileRef]);
            }
            const isLinked = lockfileRef.startsWith('link:');
            if (isLinked &&
                (currentSpec.startsWith('link:') ||
                    currentSpec.startsWith('file:') ||
                    currentSpec.startsWith('workspace:.'))) {
                return true;
            }
            const linkedDir = isLinked
                ? path_1.default.join(project.dir, lockfileRef.slice(5))
                : workspacePackages?.[depName]?.[lockfileRef]?.dir;
            if (!linkedDir)
                return true;
            if (!linkWorkspacePackages && !currentSpec.startsWith('workspace:')) {
                // we found a linked dir, but we don't want to use it, because it's not specified as a
                // workspace:x.x.x dependency
                return true;
            }
            const linkedPkg = manifestsByDir[linkedDir] ?? await (0, read_package_json_1.safeReadPackageJsonFromDir)(linkedDir);
            const availableRange = getVersionRange(currentSpec);
            // This should pass the same options to semver as @pnpm/npm-resolver
            const localPackageSatisfiesRange = availableRange === '*' || availableRange === '^' || availableRange === '~' ||
                linkedPkg && semver_1.default.satisfies(linkedPkg.version, availableRange, { loose: true });
            if (isLinked !== localPackageSatisfiesRange)
                return false;
            return true;
        });
    });
}
async function isLocalFileDepUpdated(lockfileDir, pkgSnapshot) {
    if (!pkgSnapshot)
        return false;
    const localDepDir = path_1.default.join(lockfileDir, pkgSnapshot.resolution.directory);
    const manifest = await (0, read_package_json_1.safeReadPackageJsonFromDir)(localDepDir);
    if (!manifest)
        return false;
    for (const depField of types_1.DEPENDENCIES_OR_PEER_FIELDS) {
        if (depField === 'devDependencies')
            continue;
        const manifestDeps = manifest[depField] ?? {};
        const lockfileDeps = pkgSnapshot[depField] ?? {};
        // Lock file has more dependencies than the current manifest, e.g. some dependencies are removed.
        if (Object.keys(lockfileDeps).some(depName => !manifestDeps[depName])) {
            return false;
        }
        for (const depName of Object.keys(manifestDeps)) {
            // If a dependency does not exist in the lock file, e.g. a new dependency is added to the current manifest.
            // We need to do full resolution again.
            if (!lockfileDeps[depName]) {
                return false;
            }
            const currentSpec = manifestDeps[depName];
            // We do not care about the link dependencies of local dependency.
            if (currentSpec.startsWith('file:') || currentSpec.startsWith('link:') || currentSpec.startsWith('workspace:'))
                continue;
            if (semver_1.default.satisfies(lockfileDeps[depName], getVersionRange(currentSpec), { loose: true })) {
                continue;
            }
            else {
                return false;
            }
        }
    }
    return true;
}
function getVersionRange(spec) {
    if (spec.startsWith('workspace:'))
        return spec.slice(10);
    if (spec.startsWith('npm:')) {
        spec = spec.slice(4);
        const index = spec.indexOf('@', 1);
        if (index === -1)
            return '*';
        return spec.slice(index + 1) || '*';
    }
    return spec;
}
function hasLocalTarballDepsInRoot(importer) {
    return (0, any_1.default)(lockfile_utils_1.refIsLocalTarball, Object.values(importer.dependencies ?? {})) ||
        (0, any_1.default)(lockfile_utils_1.refIsLocalTarball, Object.values(importer.devDependencies ?? {})) ||
        (0, any_1.default)(lockfile_utils_1.refIsLocalTarball, Object.values(importer.optionalDependencies ?? {}));
}
//# sourceMappingURL=allProjectsAreUpToDate.js.map