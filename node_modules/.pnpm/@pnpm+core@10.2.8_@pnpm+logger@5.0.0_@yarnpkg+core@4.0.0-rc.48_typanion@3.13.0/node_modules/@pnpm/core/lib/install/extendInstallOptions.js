"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendOptions = void 0;
const constants_1 = require("@pnpm/constants");
const error_1 = require("@pnpm/error");
const hooks_read_package_hook_1 = require("@pnpm/hooks.read-package-hook");
const normalize_registries_1 = require("@pnpm/normalize-registries");
const pnpmPkgJson_1 = require("../pnpmPkgJson");
const defaults = async (opts) => {
    const packageManager = opts.packageManager ?? {
        name: pnpmPkgJson_1.pnpmPkgJson.name,
        version: pnpmPkgJson_1.pnpmPkgJson.version,
    };
    return {
        allowedDeprecatedVersions: {},
        allowNonAppliedPatches: false,
        autoInstallPeers: true,
        childConcurrency: 5,
        confirmModulesPurge: !opts.force,
        depth: 0,
        enablePnp: false,
        engineStrict: false,
        force: false,
        forceFullResolution: false,
        forceSharedLockfile: false,
        frozenLockfile: false,
        hoistPattern: undefined,
        publicHoistPattern: undefined,
        hooks: {},
        ignoreCurrentPrefs: false,
        ignoreDepScripts: false,
        ignoreScripts: false,
        include: {
            dependencies: true,
            devDependencies: true,
            optionalDependencies: true,
        },
        includeDirect: {
            dependencies: true,
            devDependencies: true,
            optionalDependencies: true,
        },
        lockfileDir: opts.lockfileDir ?? opts.dir ?? process.cwd(),
        lockfileOnly: false,
        nodeVersion: process.version,
        nodeLinker: 'isolated',
        overrides: {},
        ownLifecycleHooksStdio: 'inherit',
        ignoreCompatibilityDb: false,
        ignorePackageManifest: false,
        packageExtensions: {},
        packageManager,
        preferFrozenLockfile: true,
        preferWorkspacePackages: false,
        preserveWorkspaceProtocol: true,
        pruneLockfileImporters: false,
        pruneStore: false,
        rawConfig: {},
        registries: normalize_registries_1.DEFAULT_REGISTRIES,
        resolutionMode: 'lowest-direct',
        saveWorkspaceProtocol: 'rolling',
        lockfileIncludeTarballUrl: false,
        scriptsPrependNodePath: false,
        shamefullyHoist: false,
        shellEmulator: false,
        sideEffectsCacheRead: false,
        sideEffectsCacheWrite: false,
        symlink: true,
        storeController: opts.storeController,
        storeDir: opts.storeDir,
        strictPeerDependencies: true,
        tag: 'latest',
        unsafePerm: process.platform === 'win32' ||
            process.platform === 'cygwin' ||
            !process.setgid ||
            process.getuid() !== 0,
        useLockfile: true,
        saveLockfile: true,
        useGitBranchLockfile: false,
        mergeGitBranchLockfiles: false,
        userAgent: `${packageManager.name}/${packageManager.version} npm/? node/${process.version} ${process.platform} ${process.arch}`,
        verifyStoreIntegrity: true,
        workspacePackages: {},
        enableModulesDir: true,
        modulesCacheMaxAge: 7 * 24 * 60,
        resolveSymlinksInInjectedDirs: false,
        dedupeDirectDeps: true,
        dedupePeerDependents: true,
        resolvePeersFromWorkspaceRoot: true,
        extendNodePath: true,
        ignoreWorkspaceCycles: false,
        excludeLinksFromLockfile: false,
    };
};
async function extendOptions(opts) {
    if (opts) {
        for (const key in opts) {
            if (opts[key] === undefined) {
                delete opts[key];
            }
        }
    }
    if (opts.onlyBuiltDependencies && opts.neverBuiltDependencies) {
        throw new error_1.PnpmError('CONFIG_CONFLICT_BUILT_DEPENDENCIES', 'Cannot have both neverBuiltDependencies and onlyBuiltDependencies');
    }
    const defaultOpts = await defaults(opts);
    const extendedOpts = {
        ...defaultOpts,
        ...opts,
        storeDir: defaultOpts.storeDir,
    };
    extendedOpts.readPackageHook = (0, hooks_read_package_hook_1.createReadPackageHook)({
        ignoreCompatibilityDb: extendedOpts.ignoreCompatibilityDb,
        readPackageHook: extendedOpts.hooks?.readPackage,
        overrides: extendedOpts.overrides,
        lockfileDir: extendedOpts.lockfileDir,
        packageExtensions: extendedOpts.packageExtensions,
        peerDependencyRules: extendedOpts.peerDependencyRules,
    });
    if (extendedOpts.lockfileOnly) {
        extendedOpts.ignoreScripts = true;
        if (!extendedOpts.useLockfile) {
            throw new error_1.PnpmError('CONFIG_CONFLICT_LOCKFILE_ONLY_WITH_NO_LOCKFILE', `Cannot generate a ${constants_1.WANTED_LOCKFILE} because lockfile is set to false`);
        }
    }
    if (extendedOpts.userAgent.startsWith('npm/')) {
        extendedOpts.userAgent = `${extendedOpts.packageManager.name}/${extendedOpts.packageManager.version} ${extendedOpts.userAgent}`;
    }
    extendedOpts.registries = (0, normalize_registries_1.normalizeRegistries)(extendedOpts.registries);
    extendedOpts.rawConfig['registry'] = extendedOpts.registries.default;
    return extendedOpts;
}
exports.extendOptions = extendOptions;
//# sourceMappingURL=extendInstallOptions.js.map