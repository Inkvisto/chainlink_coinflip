"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prune = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const logger_1 = require("@pnpm/logger");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const load_json_file_1 = __importDefault(require("load-json-file"));
const ssri_1 = __importDefault(require("ssri"));
const BIG_ONE = BigInt(1);
async function prune({ cacheDir, storeDir }) {
    const cafsDir = path_1.default.join(storeDir, 'files');
    await Promise.all([
        (0, rimraf_1.default)(path_1.default.join(cacheDir, 'metadata')),
        (0, rimraf_1.default)(path_1.default.join(cacheDir, 'metadata-full')),
        (0, rimraf_1.default)(path_1.default.join(cacheDir, 'metadata-v1.1')),
    ]);
    await (0, rimraf_1.default)(path_1.default.join(storeDir, 'tmp'));
    (0, logger_1.globalInfo)('Removed all cached metadata files');
    const pkgIndexFiles = [];
    const removedHashes = new Set();
    const dirs = (await fs_1.promises.readdir(cafsDir, { withFileTypes: true }))
        .filter(entry => entry.isDirectory())
        .map(dir => dir.name);
    let fileCounter = 0;
    await Promise.all(dirs.map(async (dir) => {
        const subdir = path_1.default.join(cafsDir, dir);
        await Promise.all((await fs_1.promises.readdir(subdir)).map(async (fileName) => {
            const filePath = path_1.default.join(subdir, fileName);
            if (fileName.endsWith('-index.json')) {
                pkgIndexFiles.push(filePath);
                return;
            }
            const stat = await fs_1.promises.stat(filePath);
            if (stat.isDirectory()) {
                (0, logger_1.globalWarn)(`An alien directory is present in the store: ${filePath}`);
                return;
            }
            if (stat.nlink === 1 || stat.nlink === BIG_ONE) {
                await fs_1.promises.unlink(filePath);
                fileCounter++;
                removedHashes.add(ssri_1.default.fromHex(`${dir}${fileName}`, 'sha512').toString());
            }
        }));
    }));
    (0, logger_1.globalInfo)(`Removed ${fileCounter} file${fileCounter === 1 ? '' : 's'}`);
    let pkgCounter = 0;
    await Promise.all(pkgIndexFiles.map(async (pkgIndexFilePath) => {
        const { files: pkgFilesIndex } = await (0, load_json_file_1.default)(pkgIndexFilePath);
        if (removedHashes.has(pkgFilesIndex['package.json'].integrity)) {
            await fs_1.promises.unlink(pkgIndexFilePath);
            pkgCounter++;
        }
    }));
    (0, logger_1.globalInfo)(`Removed ${pkgCounter} package${pkgCounter === 1 ? '' : 's'}`);
}
exports.prune = prune;
//# sourceMappingURL=prune.js.map