"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorePath = void 0;
const fs_1 = require("fs");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const can_link_1 = __importDefault(require("can-link"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const path_absolute_1 = __importDefault(require("path-absolute"));
const path_temp_1 = __importDefault(require("path-temp"));
const root_link_target_1 = __importDefault(require("root-link-target"));
const touch_1 = __importDefault(require("touch"));
const STORE_VERSION = 'v3';
function getStorePath({ pkgRoot, storePath, pnpmHomeDir, }) {
    if (!storePath) {
        return storePathRelativeToHome(pkgRoot, 'store', pnpmHomeDir);
    }
    if (isHomepath(storePath)) {
        const homedir = getHomedir();
        return storePathRelativeToHome(pkgRoot, storePath.substring(2), homedir);
    }
    const storeBasePath = (0, path_absolute_1.default)(storePath, pkgRoot);
    if (storeBasePath.endsWith(`${path_1.default.sep}${STORE_VERSION}`)) {
        return storeBasePath;
    }
    return path_1.default.join(storeBasePath, STORE_VERSION);
}
exports.getStorePath = getStorePath;
async function storePathRelativeToHome(pkgRoot, relStore, homedir) {
    const tempFile = (0, path_temp_1.default)(pkgRoot);
    await fs_1.promises.mkdir(path_1.default.dirname(tempFile), { recursive: true });
    await (0, touch_1.default)(tempFile);
    const storeInHomeDir = path_1.default.join(homedir, relStore, STORE_VERSION);
    if (await canLinkToSubdir(tempFile, homedir)) {
        await fs_1.promises.unlink(tempFile);
        // If the project is on the drive on which the OS home directory
        // then the store is placed in the home directory
        return storeInHomeDir;
    }
    try {
        let mountpoint = await (0, root_link_target_1.default)(tempFile);
        // Usually, it is disallowed to write files into the drive's root.
        // So we create an empty directory and try to link there.
        // The store will be a directory anyway.
        const mountpointParent = path_1.default.join(mountpoint, '..');
        if (!dirsAreEqual(mountpointParent, mountpoint) && await canLinkToSubdir(tempFile, mountpointParent)) {
            mountpoint = mountpointParent;
        }
        // If linking works only in the project folder
        // then prefer to place the store inside the homedir
        if (dirsAreEqual(pkgRoot, mountpoint)) {
            return storeInHomeDir;
        }
        return path_1.default.join(mountpoint, '.pnpm-store', STORE_VERSION);
    }
    catch (err) {
        // this is an unlikely situation but if there is no way to find
        // a linkable place on the disk, create the store in homedir
        return storeInHomeDir;
    }
    finally {
        await fs_1.promises.unlink(tempFile);
    }
}
async function canLinkToSubdir(fileToLink, dir) {
    let result = false;
    const tmpDir = (0, path_temp_1.default)(dir);
    try {
        await fs_1.promises.mkdir(tmpDir, { recursive: true });
        result = await (0, can_link_1.default)(fileToLink, (0, path_temp_1.default)(tmpDir));
    }
    catch (err) {
        result = false;
    }
    finally {
        await safeRmdir(tmpDir);
    }
    return result;
}
async function safeRmdir(dir) {
    try {
        // We cannot use just fs.rmdir here because can-link
        // sometimes might not remove the temporary file in time
        // and fs.rmdir can only remove an empty directory.
        await (0, rimraf_1.default)(dir);
    }
    catch (err) {
        // ignore
    }
}
function dirsAreEqual(dir1, dir2) {
    return path_1.default.relative(dir1, dir2) === '.';
}
function getHomedir() {
    const home = os_1.default.homedir();
    if (!home)
        throw new Error('Could not find the homedir');
    return home;
}
function isHomepath(filepath) {
    return filepath.indexOf('~/') === 0 || filepath.indexOf('~\\') === 0;
}
//# sourceMappingURL=index.js.map