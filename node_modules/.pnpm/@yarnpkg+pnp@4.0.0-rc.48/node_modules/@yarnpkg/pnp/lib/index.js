'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const require$$0 = require('zlib');
const path = require('path');
const module$1 = require('module');
const url = require('url');
const nodeUtils = require('util');
const assert = require('assert');
const fs = require('fs');
const crypto = require('crypto');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
  return LinkType2;
})(LinkType || {});

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const Filename = {
  home: `~`,
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  pnpData: `.pnp.data.json`,
  pnpEsmLoader: `.pnp.loader.mjs`,
  rc: `.yarnrc.yml`,
  env: `.env`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = () => toPortablePath(process.cwd());
ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__default.default.posix.resolve(...segments);
  } else {
    return path__default.default.posix.resolve(ppath.cwd(), ...segments);
  }
};
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
const defaultTimeMs = defaultTime.getTime();
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  await copyImpl(prelayout, postlayout, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, destinationFs, destination, sourceFs, source, opts) {
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
  }
  if (opts.linkStrategy?.type !== `HardlinkFromIndex` || !sourceStat.isFile()) {
    if (updated || destinationStat?.mtime?.getTime() !== mtime.getTime() || destinationStat?.atime?.getTime() !== atime.getTime()) {
      postlayout.push(() => destinationFs.lutimesPromise(destination, atime, mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
async function copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, linkStrategy) {
  const sourceHash = await sourceFs.checksumFilePromise(source, { algorithm: `sha1` });
  const indexPath = destinationFs.pathUtils.join(linkStrategy.indexPath, sourceHash.slice(0, 2), `${sourceHash}.dat`);
  let AtomicBehavior;
  ((AtomicBehavior2) => {
    AtomicBehavior2[AtomicBehavior2["Lock"] = 0] = "Lock";
    AtomicBehavior2[AtomicBehavior2["Rename"] = 1] = "Rename";
  })(AtomicBehavior || (AtomicBehavior = {}));
  let atomicBehavior = 1 /* Rename */;
  let indexStat = await maybeLStat(destinationFs, indexPath);
  if (destinationStat) {
    const isDestinationHardlinkedFromIndex = indexStat && destinationStat.dev === indexStat.dev && destinationStat.ino === indexStat.ino;
    const isIndexModified = indexStat?.mtimeMs !== defaultTimeMs;
    if (isDestinationHardlinkedFromIndex) {
      if (isIndexModified && linkStrategy.autoRepair) {
        atomicBehavior = 0 /* Lock */;
        indexStat = null;
      }
    }
    if (!isDestinationHardlinkedFromIndex) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
  }
  const tempPath = !indexStat && atomicBehavior === 1 /* Rename */ ? `${indexPath}.${Math.floor(Math.random() * 4294967296).toString(16).padStart(8, `0`)}` : null;
  let tempPathCleaned = false;
  prelayout.push(async () => {
    if (!indexStat) {
      if (atomicBehavior === 0 /* Lock */) {
        await destinationFs.lockPromise(indexPath, async () => {
          const content = await sourceFs.readFilePromise(source);
          await destinationFs.writeFilePromise(indexPath, content);
        });
      }
      if (atomicBehavior === 1 /* Rename */ && tempPath) {
        const content = await sourceFs.readFilePromise(source);
        await destinationFs.writeFilePromise(tempPath, content);
        try {
          await destinationFs.linkPromise(tempPath, indexPath);
        } catch (err) {
          if (err.code === `EEXIST`) {
            tempPathCleaned = true;
            await destinationFs.unlinkPromise(tempPath);
          } else {
            throw err;
          }
        }
      }
    }
    if (!destinationStat) {
      await destinationFs.linkPromise(indexPath, destination);
    }
  });
  postlayout.push(async () => {
    if (!indexStat)
      await destinationFs.lutimesPromise(indexPath, defaultTime, defaultTime);
    if (tempPath && !tempPathCleaned) {
      await destinationFs.unlinkPromise(tempPath);
    }
  });
  return false;
}
async function copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    const content = await sourceFs.readFilePromise(source);
    await destinationFs.writeFilePromise(destination, content);
  });
  return true;
}
async function copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (opts.linkStrategy?.type === `HardlinkFromIndex`) {
    return copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, opts.linkStrategy);
  } else {
    return copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
  }
}
async function copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async checksumFilePromise(path, { algorithm = `sha512` } = {}) {
    const fd = await this.openPromise(path, `r`);
    try {
      const CHUNK_SIZE = 65536;
      const chunk = Buffer.allocUnsafeSlow(CHUNK_SIZE);
      const hash = crypto.createHash(algorithm);
      let bytesRead = 0;
      while ((bytesRead = await this.readPromise(fd, chunk, 0, CHUNK_SIZE)) !== 0)
        hash.update(bytesRead === CHUNK_SIZE ? chunk : chunk.slice(0, bytesRead));
      return hash.digest(`hex`);
    } finally {
      await this.closePromise(fd);
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, space)}
`);
  }
  writeJsonSync(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return this.writeFileSync(p, `${JSON.stringify(data, null, space)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    await this.lutimesPromise(p, stat.atime, stat.mtime);
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    this.lutimesSync(p, stat.atime, stat.mtime);
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return this.baseFs.lutimesPromise(this.mapToBase(p), atime, mtime);
  }
  lutimesSync(p, atime, mtime) {
    return this.baseFs.lutimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
  }
  readFileSync(p, encoding) {
    return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
  }
  readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.lutimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSync(p, atime, mtime) {
    this.realFs.lutimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

const prettyJsonMachine = {
  ["DEFAULT" /* DEFAULT */]: {
    collapsed: false,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["TOP_LEVEL" /* TOP_LEVEL */]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: "FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */,
      [`packageRegistryData`]: "PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */]: {
    collapsed: false,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */
    }
  },
  ["FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */
    }
  },
  ["FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */
    }
  },
  ["PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */
    }
  },
  ["PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */
    }
  },
  ["PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */
    }
  },
  ["PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: "PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */
    }
  },
  ["PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const { next } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const { collapsed } = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, "TOP_LEVEL" /* TOP_LEVEL */, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = /* @__PURE__ */ new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({ name, reference }) => name,
    ({ name, reference }) => reference
  ]);
  for (const { name, reference } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = /* @__PURE__ */ new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, { packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup }] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */
`,
    `"use strict";
`,
    `
`,
    loader,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `const RAW_RUNTIME_STATE =
`,
    `${generateStringLiteral(generatePrettyJson(data))};

`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(JSON.parse(RAW_RUNTIME_STATE), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateSplitSetup() {
  return [
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(require(${JSON.stringify(`./${Filename.pnpData}`)}), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup();
  const loaderFile = generateLoader(settings.shebang, setup);
  return { dataFile: generateJsonString(data), loaderFile };
}

function hydrateRuntimeState(data, { basePath }) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = /* @__PURE__ */ new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = packageInformationData.discardFromLookup ?? false;
      const packageLocator = { name: packageName, reference: packageReference };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, { locator: packageLocator, discardFromLookup });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert__default.default(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);
const ERR_PACKAGE_PATH_NOT_EXPORTED = createErrorType(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + url.fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      url.fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = url.fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

/**
  @license
  Copyright Node.js contributors. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
*/
function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && url.fileURLToPath(new URL(".", packageJSONUrl)),
    url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${url.fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && url.fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && url.fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key)
    return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB)
    return -1;
  if (baseLenB > baseLenA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {
  if (typeof exports === "string" || ArrayIsArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = ObjectGetOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  for (let j = 0; j < keys.length; j++) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        url.fileURLToPath(packageJSONUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function throwExportsNotFound(subpath, packageJSONUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    base && url.fileURLToPath(base)
  );
}
const emittedPackageWarnings = /* @__PURE__ */ new Set();
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = url.fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${url.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve({
  packageJSONUrl,
  packageSubpath,
  exports,
  base,
  conditions
}) {
  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))
    exports = { ".": exports };
  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath) && !StringPrototypeIncludes(packageSubpath, "*") && !StringPrototypeEndsWith(packageSubpath, "/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath;
  const keys = ObjectGetOwnPropertyNames(exports);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const patternIndex = StringPrototypeIndexOf(key, "*");
    if (patternIndex !== -1 && StringPrototypeStartsWith(
      packageSubpath,
      StringPrototypeSlice(key, 0, patternIndex)
    )) {
      if (StringPrototypeEndsWith(packageSubpath, "/"))
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJSONUrl,
          base
        );
      const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
      if (packageSubpath.length >= key.length && StringPrototypeEndsWith(packageSubpath, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = StringPrototypeSlice(
          packageSubpath,
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  throwExportsNotFound(packageSubpath, packageJSONUrl, base);
}
function packageImportsResolve({ name, base, conditions, readFileSyncFn }) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, url.fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  return ErrorCode2;
})(ErrorCode || {});
const MODULE_NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "BUILTIN_NODE_RESOLUTION_FAILED" /* BUILTIN_NODE_RESOLUTION_FAILED */,
  "MISSING_DEPENDENCY" /* MISSING_DEPENDENCY */,
  "MISSING_PEER_DEPENDENCY" /* MISSING_PEER_DEPENDENCY */,
  "QUALIFIED_PATH_RESOLUTION_FAILED" /* QUALIFIED_PATH_RESOLUTION_FAILED */,
  "UNDECLARED_DEPENDENCY" /* UNDECLARED_DEPENDENCY */
]);
function makeError(pnpCode, message, data = {}, code) {
  code ??= MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: {
      ...propertySpec,
      value: code
    },
    pnpCode: {
      ...propertySpec,
      value: pnpCode
    },
    data: {
      ...propertySpec,
      value: data
    }
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const flagSymbol = Symbol('arg flag');

class ArgError extends Error {
	constructor(msg, code) {
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	}
}

function arg(
	opts,
	{
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	} = {}
) {
	if (!opts) {
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	}

	const result = { _: [] };

	const aliases = {};
	const handlers = {};

	for (const key of Object.keys(opts)) {
		if (!key) {
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		}

		if (key[0] !== '-') {
			throw new ArgError(
				`argument key must start with '-' but found: '${key}'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		}

		if (key.length === 1) {
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: ${key}`,
				'ARG_CONFIG_NONAME_KEY'
			);
		}

		if (typeof opts[key] === 'string') {
			aliases[key] = opts[key];
			continue;
		}

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) {
			const [fn] = type;
			type = (value, name, prev = []) => {
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			};
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		} else if (typeof type === 'function') {
			isFlag = type === Boolean || type[flagSymbol] === true;
		} else {
			throw new ArgError(
				`type missing or not a function or valid array type: ${key}`,
				'ARG_CONFIG_VAD_TYPE'
			);
		}

		if (key[1] !== '-' && key.length > 2) {
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: ${key}`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		}

		handlers[key] = [type, isFlag];
	}

	for (let i = 0, len = argv.length; i < len; i++) {
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) {
			result._ = result._.concat(argv.slice(i));
			break;
		}

		if (wholeArg === '--') {
			result._ = result._.concat(argv.slice(i + 1));
			break;
		}

		if (wholeArg.length > 1 && wholeArg[0] === '-') {
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-${a}`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) {
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) {
					argName = aliases[argName];
				}

				if (!(argName in handlers)) {
					if (permissive) {
						result._.push(arg);
						continue;
					} else {
						throw new ArgError(
							`unknown or unexpected option: ${originalArgName}`,
							'ARG_UNKNOWN_OPTION'
						);
					}
				}

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) {
					throw new ArgError(
						`option requires argument (but was followed by another short argument): ${originalArgName}`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				}

				if (isFlag) {
					result[argName] = type(true, argName, result[argName]);
				} else if (argStr === undefined) {
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) {
						const extended =
							originalArgName === argName ? '' : ` (alias for ${argName})`;
						throw new ArgError(
							`option requires argument: ${originalArgName}${extended}`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					}

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				} else {
					result[argName] = type(argStr, argName, result[argName]);
				}
			}
		} else {
			result._.push(wholeArg);
		}
	}

	return result;
}

arg.flag = (fn) => {
	fn[flagSymbol] = true;
	return fn;
};

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

var arg_1 = arg;

/**
  @license
  The MIT License (MIT)

  Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
function getOptionValue(opt) {
  parseOptions();
  return options[opt];
}
let options;
function parseOptions() {
  if (!options) {
    options = {
      "--conditions": [],
      ...parseArgv(getNodeOptionsEnvArgv()),
      ...parseArgv(process.execArgv)
    };
  }
}
function parseArgv(argv) {
  return arg_1(
    {
      "--conditions": [String],
      "-C": "--conditions"
    },
    {
      argv,
      permissive: true
    }
  );
}
function getNodeOptionsEnvArgv() {
  const errors = [];
  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
  if (errors.length !== 0) ;
  return envArgv;
}
function ParseNodeOptionsEnvVar(node_options, errors) {
  const env_argv = [];
  let is_in_string = false;
  let will_start_new_arg = true;
  for (let index = 0; index < node_options.length; ++index) {
    let c = node_options[index];
    if (c === "\\" && is_in_string) {
      if (index + 1 === node_options.length) {
        errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
        return env_argv;
      } else {
        c = node_options[++index];
      }
    } else if (c === " " && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c === '"') {
      is_in_string = !is_in_string;
      continue;
    }
    if (will_start_new_arg) {
      env_argv.push(c);
      will_start_new_arg = false;
    } else {
      env_argv[env_argv.length - 1] += c;
    }
  }
  if (is_in_string) {
    errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
  }
  return env_argv;
}

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;

const builtinModules = new Set(module$1.Module.builtinModules || Object.keys(process.binding(`natives`)));
const isBuiltinModule = (request) => request.startsWith(`node:`) || builtinModules.has(request);
function reportRequiredFilesToWatchMode(files) {
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    files = files.map((filename) => npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(filename))));
    if (WATCH_MODE_MESSAGE_USES_ARRAYS) {
      process.send({ "watch:require": files });
    } else {
      for (const filename of files) {
        process.send({ "watch:require": filename });
      }
    }
  }
}

function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = { name: null, reference: null };
  const fallbackLocators = [];
  const emittedWarnings = /* @__PURE__ */ new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({ name, reference });
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    const colors = process.stderr?.hasColors?.() ?? process.stdout.isTTY;
    const c = (n, str) => `\x1B[${n}m${str}\x1B[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${entry.error?.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, { colors, compact: true })}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, { colors, compact: true })}`);
    }
    const stack = new Error().stack.match(/(?<=^ +)at.*/gm)?.slice(2) ?? [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(
        ErrorCode.INTERNAL,
        `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`
      );
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = /* @__PURE__ */ new Set([
    `node`,
    `require`,
    ...getOptionValue(`--conditions`)
  ]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`
      );
    }
    const { packageLocation } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    if (pkgJson.exports == null)
      return null;
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`
      );
    }
    if (subpath !== `.` && !isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    try {
      const resolvedExport = packageExportsResolve({
        packageJSONUrl: url.pathToFileURL(npath.fromPortablePath(manifestPath)),
        packageSubpath: subpath,
        exports: pkgJson.exports,
        base: issuer ? url.pathToFileURL(npath.fromPortablePath(issuer)) : null,
        conditions
      });
      return npath.toPortablePath(url.fileURLToPath(resolvedExport));
    } catch (error) {
      throw makeError(
        ErrorCode.EXPORTS_RESOLUTION_FAILED,
        error.message,
        { unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions },
        error.code
      );
    }
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions }) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, { extensions });
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({ dir: unqualifiedPath, name: `index`, ext: extensions[i] });
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, { plugnplay: false });
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = { std: 3, resolveVirtual: 1, getAllLocators: 1 };
  const topLevel = topLevelLocator;
  function getPackageInformation({ name, reference }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({ name, reference }) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = /* @__PURE__ */ new Map();
    const alreadyVisited = /* @__PURE__ */ new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = /* @__PURE__ */ new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({ name, reference });
    return brokenList;
  }
  function findPackageLocator(location, { resolveIgnored = false, includeDiscardFromLookup = false } = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function tryReadFile(filePath) {
    try {
      return opts.fakeFs.readFileSync(npath.toPortablePath(filePath), `utf8`);
    } catch (err) {
      if (err.code === `ENOENT`)
        return void 0;
      throw err;
    }
  }
  function resolveToUnqualified(request, issuer, { considerBuiltins = true } = {}) {
    if (request.startsWith(`#`))
      throw new Error(`resolveToUnqualified can not handle private import mappings`);
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && isBuiltinModule(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(
            ErrorCode.API_ERROR,
            `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(
          ErrorCode.API_ERROR,
          `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
          { request: requestForDisplay, issuer: issuerForDisplay }
        );
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(
            ErrorCode.MISSING_PEER_DEPENDENCY,
            `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
          );
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          } else {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && isBuiltinModule(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? { name: dependencyReference[0], reference: dependencyReference[1] } : { name: dependencyName, reference: dependencyReference };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(
          ErrorCode.MISSING_DEPENDENCY,
          `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
          { request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator) }
        );
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions, issuer);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, { extensions = Object.keys(module$1.Module._extensions) } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions });
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      reportRequiredFilesToWatchMode(candidates.map((candidate) => npath.fromPortablePath(candidate)));
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const { packageLocation } = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if (err?.code === `ENOENT`) {
            exists = false;
          } else {
            const readableError = (err?.message ?? err ?? `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, { unqualifiedPath: unqualifiedPathForDisplay, extensions });
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(
            ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
            `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`,
            { unqualifiedPath: unqualifiedPathForDisplay, extensions }
          );
        }
      }
      throw makeError(
        ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
        `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`,
        { unqualifiedPath: unqualifiedPathForDisplay, extensions }
      );
    }
  }
  function resolvePrivateRequest(request, issuer, opts2) {
    if (!issuer)
      throw new Error(`Assertion failed: An issuer is required to resolve private import mappings`);
    const resolved = packageImportsResolve({
      name: request,
      base: url.pathToFileURL(npath.fromPortablePath(issuer)),
      conditions: opts2.conditions ?? defaultExportsConditions,
      readFileSyncFn: tryReadFile
    });
    if (resolved instanceof URL) {
      return resolveUnqualified(npath.toPortablePath(url.fileURLToPath(resolved)), { extensions: opts2.extensions });
    } else {
      if (resolved.startsWith(`#`))
        throw new Error(`Mapping from one private import to another isn't allowed`);
      return resolveRequest(resolved, issuer, opts2);
    }
  }
  function resolveRequest(request, issuer, opts2 = {}) {
    try {
      if (request.startsWith(`#`))
        return resolvePrivateRequest(request, issuer, opts2);
      const { considerBuiltins, extensions, conditions } = opts2;
      const unqualifiedPath = resolveToUnqualified(request, issuer, { considerBuiltins });
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !isBuiltinModule(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions, issuer) : unqualifiedPath;
      return resolveUnqualified(remappedPath, { extensions });
    } catch (error) {
      if (Object.prototype.hasOwnProperty.call(error, `pnpCode`))
        Object.assign(error.data, { request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer) });
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return { name: referencish[0], reference: referencish[1] };
      } else {
        return { name, reference: referencish };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({ name, reference });
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info, packageLocation };
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

async function hydratePnpFile(location, { fakeFs, pnpapiResolution }) {
  const source = await fakeFs.readFilePromise(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, { basePath, fakeFs, pnpapiResolution }) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, { basePath });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, { fakeFs, pnpapiResolution });
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook;
};

exports.LinkType = LinkType;
exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
