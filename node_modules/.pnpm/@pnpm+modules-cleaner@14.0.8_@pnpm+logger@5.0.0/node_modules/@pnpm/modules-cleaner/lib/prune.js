"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prune = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const filter_lockfile_1 = require("@pnpm/filter-lockfile");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = require("@pnpm/logger");
const read_modules_dir_1 = require("@pnpm/read-modules-dir");
const types_1 = require("@pnpm/types");
const dependency_path_1 = require("@pnpm/dependency-path");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const difference_1 = __importDefault(require("ramda/src/difference"));
const equals_1 = __importDefault(require("ramda/src/equals"));
const mergeAll_1 = __importDefault(require("ramda/src/mergeAll"));
const pickAll_1 = __importDefault(require("ramda/src/pickAll"));
const removeDirectDependency_1 = require("./removeDirectDependency");
async function prune(importers, opts) {
    const wantedLockfile = (0, filter_lockfile_1.filterLockfile)(opts.wantedLockfile, {
        include: opts.include,
        skipped: opts.skipped,
    });
    await Promise.all(importers.map(async ({ binsDir, id, modulesDir, pruneDirectDependencies, removePackages, rootDir }) => {
        const currentImporter = opts.currentLockfile.importers[id] || {};
        const currentPkgs = Object.entries(mergeDependencies(currentImporter));
        const wantedPkgs = mergeDependencies(wantedLockfile.importers[id]);
        const allCurrentPackages = new Set((pruneDirectDependencies === true || removePackages?.length)
            ? (await (0, read_modules_dir_1.readModulesDir)(modulesDir) ?? [])
            : []);
        const depsToRemove = new Set((removePackages ?? []).filter((removePackage) => allCurrentPackages.has(removePackage)));
        currentPkgs.forEach(([depName, depVersion]) => {
            if (!wantedPkgs[depName] || wantedPkgs[depName] !== depVersion) {
                depsToRemove.add(depName);
            }
        });
        if (pruneDirectDependencies) {
            const publiclyHoistedDeps = getPubliclyHoistedDependencies(opts.hoistedDependencies);
            if (allCurrentPackages.size > 0) {
                for (const currentPackage of allCurrentPackages) {
                    if (!wantedPkgs[currentPackage] && !publiclyHoistedDeps.has(currentPackage)) {
                        depsToRemove.add(currentPackage);
                    }
                }
            }
        }
        return Promise.all(Array.from(depsToRemove).map(async (depName) => {
            return (0, removeDirectDependency_1.removeDirectDependency)({
                dependenciesField: currentImporter.devDependencies?.[depName] != null && 'devDependencies' ||
                    currentImporter.optionalDependencies?.[depName] != null && 'optionalDependencies' ||
                    currentImporter.dependencies?.[depName] != null && 'dependencies' ||
                    undefined,
                name: depName,
            }, {
                binsDir,
                dryRun: opts.dryRun,
                modulesDir,
                rootDir,
            });
        }));
    }));
    const selectedImporterIds = importers.map((importer) => importer.id).sort();
    // In case installation is done on a subset of importers,
    // we may only prune dependencies that are used only by that subset of importers.
    // Otherwise, we would break the node_modules.
    const currentPkgIdsByDepPaths = (0, equals_1.default)(selectedImporterIds, Object.keys(opts.wantedLockfile.importers))
        ? getPkgsDepPaths(opts.registries, opts.currentLockfile.packages ?? {}, opts.skipped)
        : getPkgsDepPathsOwnedOnlyByImporters(selectedImporterIds, opts.registries, opts.currentLockfile, opts.include, opts.skipped);
    const wantedPkgIdsByDepPaths = getPkgsDepPaths(opts.registries, wantedLockfile.packages ?? {}, opts.skipped);
    const orphanDepPaths = Object.keys(currentPkgIdsByDepPaths).filter(path => !wantedPkgIdsByDepPaths[path]);
    const orphanPkgIds = new Set(orphanDepPaths.map(path => currentPkgIdsByDepPaths[path]));
    core_loggers_1.statsLogger.debug({
        prefix: opts.lockfileDir,
        removed: orphanPkgIds.size,
    });
    if (!opts.dryRun) {
        if ((orphanDepPaths.length > 0) &&
            (opts.currentLockfile.packages != null) &&
            (opts.hoistedModulesDir != null || opts.publicHoistedModulesDir != null)) {
            const prefix = path_1.default.join(opts.virtualStoreDir, '../..');
            await Promise.all(orphanDepPaths.map(async (orphanDepPath) => {
                if (opts.hoistedDependencies[orphanDepPath]) {
                    await Promise.all(Object.entries(opts.hoistedDependencies[orphanDepPath]).map(([alias, hoistType]) => {
                        const modulesDir = hoistType === 'public'
                            ? opts.publicHoistedModulesDir
                            : opts.hoistedModulesDir;
                        if (!modulesDir)
                            return undefined;
                        return (0, removeDirectDependency_1.removeDirectDependency)({
                            name: alias,
                        }, {
                            binsDir: path_1.default.join(modulesDir, '.bin'),
                            modulesDir,
                            muteLogs: true,
                            rootDir: prefix,
                        });
                    }));
                }
                delete opts.hoistedDependencies[orphanDepPath];
            }));
        }
        if (opts.pruneVirtualStore !== false) {
            const _tryRemovePkg = tryRemovePkg.bind(null, opts.lockfileDir, opts.virtualStoreDir);
            await Promise.all(orphanDepPaths
                .map((orphanDepPath) => (0, dependency_path_1.depPathToFilename)(orphanDepPath))
                .map(async (orphanDepPath) => _tryRemovePkg(orphanDepPath)));
            const neededPkgs = new Set(['node_modules']);
            for (const depPath of Object.keys(opts.wantedLockfile.packages ?? {})) {
                if (opts.skipped.has(depPath))
                    continue;
                neededPkgs.add((0, dependency_path_1.depPathToFilename)(depPath));
            }
            const availablePkgs = await readVirtualStoreDir(opts.virtualStoreDir, opts.lockfileDir);
            await Promise.all(availablePkgs
                .filter((availablePkg) => !neededPkgs.has(availablePkg))
                .map(async (orphanDepPath) => _tryRemovePkg(orphanDepPath)));
        }
    }
    return new Set(orphanDepPaths);
}
exports.prune = prune;
async function readVirtualStoreDir(virtualStoreDir, lockfileDir) {
    try {
        return await fs_1.promises.readdir(virtualStoreDir);
    }
    catch (err) { // eslint-disable-line
        if (err.code !== 'ENOENT') {
            logger_1.logger.warn({
                error: err,
                message: `Failed to read virtualStoreDir at "${virtualStoreDir}"`,
                prefix: lockfileDir,
            });
        }
        return [];
    }
}
async function tryRemovePkg(lockfileDir, virtualStoreDir, pkgDir) {
    const pathToRemove = path_1.default.join(virtualStoreDir, pkgDir);
    core_loggers_1.removalLogger.debug(pathToRemove);
    try {
        await (0, rimraf_1.default)(pathToRemove);
    }
    catch (err) { // eslint-disable-line
        logger_1.logger.warn({
            error: err,
            message: `Failed to remove "${pathToRemove}"`,
            prefix: lockfileDir,
        });
    }
}
function mergeDependencies(projectSnapshot) {
    return (0, mergeAll_1.default)(types_1.DEPENDENCIES_FIELDS.map((depType) => projectSnapshot[depType] ?? {}));
}
function getPkgsDepPaths(registries, packages, skipped) {
    return Object.entries(packages).reduce((acc, [depPath, pkg]) => {
        if (skipped.has(depPath))
            return acc;
        acc[depPath] = (0, lockfile_utils_1.packageIdFromSnapshot)(depPath, pkg, registries);
        return acc;
    }, {});
}
function getPkgsDepPathsOwnedOnlyByImporters(importerIds, registries, lockfile, include, skipped) {
    const selected = (0, filter_lockfile_1.filterLockfileByImporters)(lockfile, importerIds, {
        failOnMissingDependencies: false,
        include,
        skipped,
    });
    const other = (0, filter_lockfile_1.filterLockfileByImporters)(lockfile, (0, difference_1.default)(Object.keys(lockfile.importers), importerIds), {
        failOnMissingDependencies: false,
        include,
        skipped,
    });
    const packagesOfSelectedOnly = (0, pickAll_1.default)((0, difference_1.default)(Object.keys(selected.packages), Object.keys(other.packages)), selected.packages);
    return getPkgsDepPaths(registries, packagesOfSelectedOnly, skipped);
}
function getPubliclyHoistedDependencies(hoistedDependencies) {
    const publiclyHoistedDeps = new Set();
    for (const hoistedAliases of Object.values(hoistedDependencies)) {
        for (const [alias, hoistType] of Object.entries(hoistedAliases)) {
            if (hoistType === 'public') {
                publiclyHoistedDeps.add(alias);
            }
        }
    }
    return publiclyHoistedDeps;
}
//# sourceMappingURL=prune.js.map