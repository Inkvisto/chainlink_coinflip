"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toResolveImporter = void 0;
const logger_1 = require("@pnpm/logger");
const manifest_utils_1 = require("@pnpm/manifest-utils");
const version_selector_type_1 = __importDefault(require("version-selector-type"));
const getWantedDependencies_1 = require("./getWantedDependencies");
const safeIsInnerLink_1 = require("./safeIsInnerLink");
async function toResolveImporter(opts, project) {
    const allDeps = (0, getWantedDependencies_1.getWantedDependencies)(project.manifest);
    const nonLinkedDependencies = await partitionLinkedPackages(allDeps, {
        lockfileOnly: opts.lockfileOnly,
        modulesDir: project.modulesDir,
        projectDir: project.rootDir,
        virtualStoreDir: opts.virtualStoreDir,
        workspacePackages: opts.workspacePackages,
    });
    const defaultUpdateDepth = (project.update === true || (project.updateMatching != null)) ? opts.defaultUpdateDepth : -1;
    const existingDeps = nonLinkedDependencies
        .filter(({ alias }) => !project.wantedDependencies.some((wantedDep) => wantedDep.alias === alias));
    let wantedDependencies;
    if (!project.manifest) {
        wantedDependencies = [
            ...project.wantedDependencies,
            ...existingDeps,
        ]
            .map((dep) => ({
            ...dep,
            updateDepth: defaultUpdateDepth,
        }));
    }
    else {
        // Direct local tarballs are always checked,
        // so their update depth should be at least 0
        const updateLocalTarballs = (dep) => ({
            ...dep,
            updateDepth: project.updateMatching != null
                ? defaultUpdateDepth
                : (prefIsLocalTarball(dep.pref) ? 0 : -1),
        });
        wantedDependencies = [
            ...project.wantedDependencies.map(defaultUpdateDepth < 0
                ? updateLocalTarballs
                : (dep) => ({ ...dep, updateDepth: defaultUpdateDepth })),
            ...existingDeps.map(updateLocalTarballs),
        ];
    }
    return {
        ...project,
        hasRemovedDependencies: Boolean(project.removePackages?.length),
        preferredVersions: opts.preferredVersions ?? (project.manifest && getPreferredVersionsFromPackage(project.manifest)) ?? {},
        wantedDependencies,
    };
}
exports.toResolveImporter = toResolveImporter;
function prefIsLocalTarball(pref) {
    return pref.startsWith('file:') && pref.endsWith('.tgz');
}
async function partitionLinkedPackages(dependencies, opts) {
    const nonLinkedDependencies = [];
    const linkedAliases = new Set();
    await Promise.all(dependencies.map(async (dependency) => {
        if (!dependency.alias ||
            opts.workspacePackages?.[dependency.alias] != null ||
            dependency.pref.startsWith('workspace:')) {
            nonLinkedDependencies.push(dependency);
            return;
        }
        const isInnerLink = await (0, safeIsInnerLink_1.safeIsInnerLink)(opts.modulesDir, dependency.alias, {
            hideAlienModules: !opts.lockfileOnly,
            projectDir: opts.projectDir,
            virtualStoreDir: opts.virtualStoreDir,
        });
        if (isInnerLink === true) {
            nonLinkedDependencies.push(dependency);
            return;
        }
        if (!dependency.pref.startsWith('link:')) {
            // This info-log might be better to be moved to the reporter
            logger_1.logger.info({
                message: `${dependency.alias} is linked to ${opts.modulesDir} from ${isInnerLink}`,
                prefix: opts.projectDir,
            });
        }
        linkedAliases.add(dependency.alias);
    }));
    return nonLinkedDependencies;
}
function getPreferredVersionsFromPackage(pkg) {
    return getVersionSpecsByRealNames((0, manifest_utils_1.getAllDependenciesFromManifest)(pkg));
}
function getVersionSpecsByRealNames(deps) {
    return Object.entries(deps)
        .reduce((acc, [depName, currentPref]) => {
        if (currentPref.startsWith('npm:')) {
            const pref = currentPref.slice(4);
            const index = pref.lastIndexOf('@');
            const spec = pref.slice(index + 1);
            const selector = (0, version_selector_type_1.default)(spec);
            if (selector != null) {
                const pkgName = pref.substring(0, index);
                acc[pkgName] = acc[pkgName] || {};
                acc[pkgName][selector.normalized] = selector.type;
            }
        }
        else if (!currentPref.includes(':')) { // we really care only about semver specs
            const selector = (0, version_selector_type_1.default)(currentPref);
            if (selector != null) {
                acc[depName] = acc[depName] || {};
                acc[depName][selector.normalized] = selector.type;
            }
        }
        return acc;
    }, {});
}
//# sourceMappingURL=toResolveImporter.js.map