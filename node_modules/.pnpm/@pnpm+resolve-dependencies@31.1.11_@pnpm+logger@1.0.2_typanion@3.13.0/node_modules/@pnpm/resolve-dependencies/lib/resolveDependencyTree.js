"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDependencyTree = void 0;
const partition_1 = __importDefault(require("ramda/src/partition"));
const zipObj_1 = __importDefault(require("ramda/src/zipObj"));
const nodeIdUtils_1 = require("./nodeIdUtils");
const resolveDependencies_1 = require("./resolveDependencies");
__exportStar(require("./nodeIdUtils"), exports);
async function resolveDependencyTree(importers, opts) {
    const wantedToBeSkippedPackageIds = new Set();
    const ctx = {
        autoInstallPeers: opts.autoInstallPeers === true,
        allowBuild: opts.allowBuild,
        allowedDeprecatedVersions: opts.allowedDeprecatedVersions,
        childrenByParentDepPath: {},
        currentLockfile: opts.currentLockfile,
        defaultTag: opts.tag,
        dependenciesTree: new Map(),
        dryRun: opts.dryRun,
        engineStrict: opts.engineStrict,
        force: opts.force,
        forceFullResolution: opts.forceFullResolution,
        ignoreScripts: opts.ignoreScripts,
        linkWorkspacePackagesDepth: opts.linkWorkspacePackagesDepth ?? -1,
        lockfileDir: opts.lockfileDir,
        nodeVersion: opts.nodeVersion,
        outdatedDependencies: {},
        patchedDependencies: opts.patchedDependencies,
        pendingNodes: [],
        pnpmVersion: opts.pnpmVersion,
        preferWorkspacePackages: opts.preferWorkspacePackages,
        readPackageHook: opts.hooks.readPackage,
        registries: opts.registries,
        resolvedPackagesByDepPath: {},
        resolutionMode: opts.resolutionMode,
        skipped: wantedToBeSkippedPackageIds,
        storeController: opts.storeController,
        virtualStoreDir: opts.virtualStoreDir,
        wantedLockfile: opts.wantedLockfile,
        appliedPatches: new Set(),
        updatedSet: new Set(),
        workspacePackages: opts.workspacePackages,
        missingPeersOfChildrenByPkgId: {},
    };
    const resolveArgs = importers.map((importer) => {
        const projectSnapshot = opts.wantedLockfile.importers[importer.id];
        // This may be optimized.
        // We only need to proceed resolving every dependency
        // if the newly added dependency has peer dependencies.
        const proceed = importer.id === '.' || importer.hasRemovedDependencies === true || importer.wantedDependencies.some((wantedDep) => wantedDep.isNew); // eslint-disable-line @typescript-eslint/no-explicit-any
        const resolveOpts = {
            currentDepth: 0,
            parentPkg: {
                installable: true,
                nodeId: `>${importer.id}>`,
                optional: false,
                depPath: importer.id,
                rootDir: importer.rootDir,
            },
            proceed,
            resolvedDependencies: {
                ...projectSnapshot.dependencies,
                ...projectSnapshot.devDependencies,
                ...projectSnapshot.optionalDependencies,
            },
            updateDepth: -1,
            updateMatching: importer.updateMatching,
            prefix: importer.rootDir,
        };
        return {
            updatePackageManifest: importer.updatePackageManifest,
            parentPkgAliases: Object.fromEntries(importer.wantedDependencies.filter(({ alias }) => alias).map(({ alias }) => [alias, true])),
            preferredVersions: importer.preferredVersions ?? {},
            wantedDependencies: importer.wantedDependencies,
            options: resolveOpts,
        };
    });
    const { pkgAddressesByImporters, time } = await (0, resolveDependencies_1.resolveRootDependencies)(ctx, resolveArgs);
    const directDepsByImporterId = (0, zipObj_1.default)(importers.map(({ id }) => id), pkgAddressesByImporters);
    ctx.pendingNodes.forEach((pendingNode) => {
        ctx.dependenciesTree.set(pendingNode.nodeId, {
            children: () => buildTree(ctx, pendingNode.nodeId, pendingNode.resolvedPackage.id, ctx.childrenByParentDepPath[pendingNode.resolvedPackage.depPath], pendingNode.depth + 1, pendingNode.installable),
            depth: pendingNode.depth,
            installable: pendingNode.installable,
            resolvedPackage: pendingNode.resolvedPackage,
        });
    });
    const resolvedImporters = {};
    for (const { id } of importers) {
        const directDeps = directDepsByImporterId[id];
        const [linkedDependencies, directNonLinkedDeps] = (0, partition_1.default)((dep) => dep.isLinkedDependency === true, directDeps);
        resolvedImporters[id] = {
            directDependencies: directDeps
                .map((dep) => {
                if (dep.isLinkedDependency === true) {
                    return dep;
                }
                const resolvedPackage = ctx.dependenciesTree.get(dep.nodeId).resolvedPackage;
                return {
                    alias: dep.alias,
                    dev: resolvedPackage.dev,
                    name: resolvedPackage.name,
                    normalizedPref: dep.normalizedPref,
                    optional: resolvedPackage.optional,
                    pkgId: resolvedPackage.id,
                    resolution: resolvedPackage.resolution,
                    version: resolvedPackage.version,
                };
            }),
            directNodeIdsByAlias: directNonLinkedDeps
                .reduce((acc, { alias, nodeId }) => {
                acc[alias] = nodeId;
                return acc;
            }, {}),
            linkedDependencies,
        };
    }
    return {
        dependenciesTree: ctx.dependenciesTree,
        outdatedDependencies: ctx.outdatedDependencies,
        resolvedImporters,
        resolvedPackagesByDepPath: ctx.resolvedPackagesByDepPath,
        wantedToBeSkippedPackageIds,
        appliedPatches: ctx.appliedPatches,
        time,
    };
}
exports.resolveDependencyTree = resolveDependencyTree;
function buildTree(ctx, parentNodeId, parentId, children, depth, installable) {
    const childrenNodeIds = {};
    for (const child of children) {
        if (child.depPath.startsWith('link:')) {
            childrenNodeIds[child.alias] = child.depPath;
            continue;
        }
        if ((0, nodeIdUtils_1.nodeIdContainsSequence)(parentNodeId, parentId, child.depPath) || parentId === child.depPath) {
            continue;
        }
        const childNodeId = (0, nodeIdUtils_1.createNodeId)(parentNodeId, child.depPath);
        childrenNodeIds[child.alias] = childNodeId;
        installable = installable && !ctx.skipped.has(child.depPath);
        ctx.dependenciesTree.set(childNodeId, {
            children: () => buildTree(ctx, childNodeId, child.depPath, ctx.childrenByParentDepPath[child.depPath], depth + 1, installable),
            depth,
            installable,
            resolvedPackage: ctx.resolvedPackagesByDepPath[child.depPath],
        });
    }
    return childrenNodeIds;
}
//# sourceMappingURL=resolveDependencyTree.js.map