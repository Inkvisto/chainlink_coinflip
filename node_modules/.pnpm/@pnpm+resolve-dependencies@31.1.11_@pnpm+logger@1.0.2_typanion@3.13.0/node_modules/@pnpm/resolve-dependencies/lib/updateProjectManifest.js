"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProjectManifest = void 0;
const manifest_utils_1 = require("@pnpm/manifest-utils");
const version_selector_type_1 = __importDefault(require("version-selector-type"));
const semver_1 = __importDefault(require("semver"));
async function updateProjectManifest(importer, opts) {
    if (!importer.manifest) {
        throw new Error('Cannot save because no package.json found');
    }
    const specsToUpsert = opts.directDependencies
        .filter((rdd, index) => importer.wantedDependencies[index]?.updateSpec)
        .map((rdd, index) => {
        const wantedDep = importer.wantedDependencies[index];
        return resolvedDirectDepToSpecObject({ ...rdd, isNew: wantedDep.isNew, specRaw: wantedDep.raw, preserveNonSemverVersionSpec: wantedDep.preserveNonSemverVersionSpec }, importer, {
            nodeExecPath: wantedDep.nodeExecPath,
            pinnedVersion: wantedDep.pinnedVersion ?? importer.pinnedVersion ?? 'major',
            preserveWorkspaceProtocol: opts.preserveWorkspaceProtocol,
            saveWorkspaceProtocol: opts.saveWorkspaceProtocol,
        });
    });
    for (const pkgToInstall of importer.wantedDependencies) {
        if (pkgToInstall.updateSpec && pkgToInstall.alias && !specsToUpsert.some(({ alias }) => alias === pkgToInstall.alias)) {
            specsToUpsert.push({
                alias: pkgToInstall.alias,
                nodeExecPath: pkgToInstall.nodeExecPath,
                peer: importer.peer,
                saveType: importer.targetDependenciesField,
            });
        }
    }
    const hookedManifest = await (0, manifest_utils_1.updateProjectManifestObject)(importer.rootDir, importer.manifest, specsToUpsert);
    const originalManifest = (importer.originalManifest != null)
        ? await (0, manifest_utils_1.updateProjectManifestObject)(importer.rootDir, importer.originalManifest, specsToUpsert)
        : undefined;
    return [hookedManifest, originalManifest];
}
exports.updateProjectManifest = updateProjectManifest;
function resolvedDirectDepToSpecObject({ alias, isNew, name, normalizedPref, resolution, specRaw, version, preserveNonSemverVersionSpec, }, importer, opts) {
    let pref;
    if (normalizedPref) {
        pref = normalizedPref;
    }
    else {
        const shouldUseWorkspaceProtocol = resolution.type === 'directory' &&
            (Boolean(opts.saveWorkspaceProtocol) ||
                (opts.preserveWorkspaceProtocol && specRaw.includes('@workspace:'))) &&
            opts.pinnedVersion !== 'none';
        if (isNew === true) {
            pref = getPrefPreferSpecifiedSpec({
                alias,
                name,
                pinnedVersion: opts.pinnedVersion,
                specRaw,
                version,
                rolling: shouldUseWorkspaceProtocol && opts.saveWorkspaceProtocol === 'rolling',
            });
        }
        else {
            pref = getPrefPreferSpecifiedExoticSpec({
                alias,
                name,
                pinnedVersion: opts.pinnedVersion,
                specRaw,
                version,
                rolling: shouldUseWorkspaceProtocol && opts.saveWorkspaceProtocol === 'rolling',
                preserveNonSemverVersionSpec,
            });
        }
        if (shouldUseWorkspaceProtocol &&
            !pref.startsWith('workspace:')) {
            pref = `workspace:${pref}`;
        }
    }
    return {
        alias,
        nodeExecPath: opts.nodeExecPath,
        peer: importer['peer'],
        pref,
        saveType: importer['targetDependenciesField'],
    };
}
function getPrefPreferSpecifiedSpec(opts) {
    const prefix = (0, manifest_utils_1.getPrefix)(opts.alias, opts.name);
    if (opts.specRaw?.startsWith(`${opts.alias}@${prefix}`)) {
        const range = opts.specRaw.slice(`${opts.alias}@${prefix}`.length);
        if (range) {
            const selector = (0, version_selector_type_1.default)(range);
            if ((selector != null) && (selector.type === 'version' || selector.type === 'range')) {
                return opts.specRaw.slice(opts.alias.length + 1);
            }
        }
    }
    // A prerelease version is always added as an exact version
    if (semver_1.default.parse(opts.version)?.prerelease.length) {
        return `${prefix}${opts.version}`;
    }
    return `${prefix}${(0, manifest_utils_1.createVersionSpec)(opts.version, { pinnedVersion: opts.pinnedVersion, rolling: opts.rolling })}`;
}
function getPrefPreferSpecifiedExoticSpec(opts) {
    const prefix = (0, manifest_utils_1.getPrefix)(opts.alias, opts.name);
    if (opts.specRaw?.startsWith(`${opts.alias}@${prefix}`)) {
        let specWithoutName = opts.specRaw.slice(`${opts.alias}@${prefix}`.length);
        if (specWithoutName.startsWith('workspace:')) {
            specWithoutName = specWithoutName.slice(10);
            if (specWithoutName === '*' || specWithoutName === '^' || specWithoutName === '~') {
                return specWithoutName;
            }
        }
        const selector = (0, version_selector_type_1.default)(specWithoutName);
        if (((selector == null) || (selector.type !== 'version' && selector.type !== 'range')) &&
            opts.preserveNonSemverVersionSpec) {
            return opts.specRaw.slice(opts.alias.length + 1);
        }
    }
    // A prerelease version is always added as an exact version
    if (semver_1.default.parse(opts.version)?.prerelease.length) {
        return `${prefix}${opts.version}`;
    }
    return `${prefix}${(0, manifest_utils_1.createVersionSpec)(opts.version, { pinnedVersion: opts.pinnedVersion, rolling: opts.rolling })}`;
}
//# sourceMappingURL=updateProjectManifest.js.map