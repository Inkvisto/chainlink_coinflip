"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeIdForLinkedLocalPkg = exports.resolveDependencies = exports.resolveRootDependencies = exports.nodeIdToParents = void 0;
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = require("@pnpm/error");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = require("@pnpm/logger");
const pick_registry_for_package_1 = require("@pnpm/pick-registry-for-package");
const resolver_base_1 = require("@pnpm/resolver-base");
const dp = __importStar(require("@pnpm/dependency-path"));
const normalize_path_1 = __importDefault(require("normalize-path"));
const path_exists_1 = __importDefault(require("path-exists"));
const p_defer_1 = __importDefault(require("p-defer"));
const promise_share_1 = __importDefault(require("promise-share"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const omit_1 = __importDefault(require("ramda/src/omit"));
const zipWith_1 = __importDefault(require("ramda/src/zipWith"));
const semver_1 = __importDefault(require("semver"));
const encodePkgId_1 = require("./encodePkgId");
const getNonDevWantedDependencies_1 = require("./getNonDevWantedDependencies");
const mergePeers_1 = require("./mergePeers");
const nodeIdUtils_1 = require("./nodeIdUtils");
const wantedDepIsLocallyAvailable_1 = require("./wantedDepIsLocallyAvailable");
const safe_promise_defer_1 = __importDefault(require("safe-promise-defer"));
const dependencyResolvedLogger = (0, logger_1.logger)('_dependency_resolved');
function nodeIdToParents(nodeId, resolvedPackagesByDepPath) {
    return (0, nodeIdUtils_1.splitNodeId)(nodeId).slice(1)
        .map((depPath) => {
        const { id, name, version } = resolvedPackagesByDepPath[depPath];
        return { id, name, version };
    });
}
exports.nodeIdToParents = nodeIdToParents;
async function resolveRootDependencies(ctx, importers) {
    const { pkgAddressesByImportersWithoutPeers, publishedBy, time } = await resolveDependenciesOfImporters(ctx, importers);
    const pkgAddressesByImporters = await Promise.all((0, zipWith_1.default)(async (importerResolutionResult, { parentPkgAliases, preferredVersions, options }) => {
        const pkgAddresses = importerResolutionResult.pkgAddresses;
        if (!ctx.autoInstallPeers)
            return pkgAddresses;
        while (true) {
            for (const pkgAddress of importerResolutionResult.pkgAddresses) {
                parentPkgAliases[pkgAddress.alias] = true;
            }
            for (const missingPeerName of Object.keys(importerResolutionResult.missingPeers ?? {})) {
                parentPkgAliases[missingPeerName] = true;
            }
            // All the missing peers should get installed in the root.
            // Otherwise, pending nodes will not work.
            // even those peers should be hoisted that are not autoinstalled
            for (const [resolvedPeerName, resolvedPeerAddress] of Object.entries(importerResolutionResult.resolvedPeers ?? {})) {
                if (!parentPkgAliases[resolvedPeerName]) {
                    pkgAddresses.push(resolvedPeerAddress);
                }
            }
            if (!Object.keys(importerResolutionResult.missingPeers).length)
                break;
            const wantedDependencies = (0, getNonDevWantedDependencies_1.getNonDevWantedDependencies)({ dependencies: importerResolutionResult.missingPeers });
            // eslint-disable-next-line no-await-in-loop
            const resolveDependenciesResult = await resolveDependencies(ctx, preferredVersions, wantedDependencies, {
                ...options,
                parentPkgAliases,
                publishedBy,
            });
            importerResolutionResult = {
                pkgAddresses: resolveDependenciesResult.pkgAddresses,
                // eslint-disable-next-line no-await-in-loop
                ...filterMissingPeers(await resolveDependenciesResult.resolvingPeers, parentPkgAliases),
            };
            pkgAddresses.push(...importerResolutionResult.pkgAddresses);
        }
        return pkgAddresses;
    }, pkgAddressesByImportersWithoutPeers, importers));
    return { pkgAddressesByImporters, time };
}
exports.resolveRootDependencies = resolveRootDependencies;
async function resolveDependenciesOfImporters(ctx, importers) {
    const extendedWantedDepsByImporters = importers.map(({ wantedDependencies, options }) => getDepsToResolve(wantedDependencies, ctx.wantedLockfile, {
        preferredDependencies: options.preferredDependencies,
        prefix: options.prefix,
        proceed: options.proceed || ctx.forceFullResolution,
        registries: ctx.registries,
        resolvedDependencies: options.resolvedDependencies,
    }));
    const pickLowestVersion = ctx.resolutionMode === 'time-based' || ctx.resolutionMode === 'lowest-direct';
    const resolveResults = await Promise.all((0, zipWith_1.default)(async (extendedWantedDeps, importer) => {
        const postponedResolutionsQueue = [];
        const postponedPeersResolutionQueue = [];
        const pkgAddresses = [];
        (await Promise.all(extendedWantedDeps.map((extendedWantedDep) => resolveDependenciesOfDependency(ctx, importer.preferredVersions, {
            ...importer.options,
            parentPkgAliases: importer.parentPkgAliases,
            pickLowestVersion: pickLowestVersion && !importer.updatePackageManifest,
        }, extendedWantedDep)))).forEach(({ resolveDependencyResult, postponedPeersResolution, postponedResolution }) => {
            if (resolveDependencyResult) {
                pkgAddresses.push(resolveDependencyResult);
            }
            if (postponedResolution) {
                postponedResolutionsQueue.push(postponedResolution);
            }
            if (postponedPeersResolution) {
                postponedPeersResolutionQueue.push(postponedPeersResolution);
            }
        });
        return { pkgAddresses, postponedResolutionsQueue, postponedPeersResolutionQueue };
    }, extendedWantedDepsByImporters, importers));
    let publishedBy;
    let time;
    if (ctx.resolutionMode === 'time-based') {
        const result = getPublishedByDate(resolveResults.map(({ pkgAddresses }) => pkgAddresses).flat(), ctx.wantedLockfile.time);
        if (result.publishedBy) {
            publishedBy = new Date(result.publishedBy.getTime() + 60 * 60 * 1000); // adding 1 hour delta
            time = result.newTime;
        }
    }
    const pkgAddressesByImportersWithoutPeers = await Promise.all((0, zipWith_1.default)(async (importer, { pkgAddresses, postponedResolutionsQueue, postponedPeersResolutionQueue }) => {
        const newPreferredVersions = Object.create(importer.preferredVersions);
        const currentParentPkgAliases = {};
        for (const pkgAddress of pkgAddresses) {
            if (currentParentPkgAliases[pkgAddress.alias] !== true) {
                currentParentPkgAliases[pkgAddress.alias] = pkgAddress;
            }
            if (pkgAddress.updated) {
                ctx.updatedSet.add(pkgAddress.alias);
            }
            const resolvedPackage = ctx.resolvedPackagesByDepPath[pkgAddress.depPath];
            if (!resolvedPackage)
                continue; // This will happen only with linked dependencies
            if (!Object.prototype.hasOwnProperty.call(newPreferredVersions, resolvedPackage.name)) {
                newPreferredVersions[resolvedPackage.name] = { ...importer.preferredVersions[resolvedPackage.name] };
            }
            if (!newPreferredVersions[resolvedPackage.name][resolvedPackage.version]) {
                newPreferredVersions[resolvedPackage.name][resolvedPackage.version] = {
                    selectorType: 'version',
                    weight: resolver_base_1.DIRECT_DEP_SELECTOR_WEIGHT,
                };
            }
        }
        const newParentPkgAliases = { ...importer.parentPkgAliases, ...currentParentPkgAliases };
        const postponedResolutionOpts = {
            preferredVersions: newPreferredVersions,
            parentPkgAliases: newParentPkgAliases,
            publishedBy,
        };
        const childrenResults = await Promise.all(postponedResolutionsQueue.map((postponedResolution) => postponedResolution(postponedResolutionOpts)));
        if (!ctx.autoInstallPeers) {
            return {
                missingPeers: {},
                pkgAddresses,
                resolvedPeers: {},
            };
        }
        const postponedPeersResolution = await Promise.all(postponedPeersResolutionQueue.map((postponedMissingPeers) => postponedMissingPeers(postponedResolutionOpts.parentPkgAliases)));
        const resolvedPeers = [...childrenResults, ...postponedPeersResolution].reduce((acc, { resolvedPeers }) => Object.assign(acc, resolvedPeers), {});
        const allMissingPeers = mergePkgsDeps([
            ...filterMissingPeersFromPkgAddresses(pkgAddresses, currentParentPkgAliases, resolvedPeers),
            ...childrenResults,
            ...postponedPeersResolution,
        ].map(({ missingPeers }) => missingPeers).filter(Boolean));
        return {
            missingPeers: allMissingPeers,
            pkgAddresses,
            resolvedPeers,
        };
    }, importers, resolveResults));
    return {
        pkgAddressesByImportersWithoutPeers,
        publishedBy,
        time,
    };
}
function filterMissingPeersFromPkgAddresses(pkgAddresses, currentParentPkgAliases, resolvedPeers) {
    return pkgAddresses.map((pkgAddress) => ({
        ...pkgAddress,
        missingPeers: (0, pickBy_1.default)((peer, peerName) => {
            if (!currentParentPkgAliases[peerName])
                return true;
            if (currentParentPkgAliases[peerName] !== true) {
                resolvedPeers[peerName] = currentParentPkgAliases[peerName];
            }
            return false;
        }, pkgAddress.missingPeers ?? {}),
    }));
}
function getPublishedByDate(pkgAddresses, timeFromLockfile = {}) {
    const newTime = {};
    for (const pkgAddress of pkgAddresses) {
        if (pkgAddress.publishedAt) {
            newTime[pkgAddress.depPath] = pkgAddress.publishedAt;
        }
        else if (timeFromLockfile[pkgAddress.depPath]) {
            newTime[pkgAddress.depPath] = timeFromLockfile[pkgAddress.depPath];
        }
    }
    const sortedDates = Object.values(newTime)
        .map((publishedAt) => new Date(publishedAt))
        .sort((d1, d2) => d1.getTime() - d2.getTime());
    return { publishedBy: sortedDates[sortedDates.length - 1], newTime };
}
async function resolveDependencies(ctx, preferredVersions, wantedDependencies, options) {
    const extendedWantedDeps = getDepsToResolve(wantedDependencies, ctx.wantedLockfile, {
        preferredDependencies: options.preferredDependencies,
        prefix: options.prefix,
        proceed: options.proceed || ctx.forceFullResolution,
        registries: ctx.registries,
        resolvedDependencies: options.resolvedDependencies,
    });
    const postponedResolutionsQueue = [];
    const postponedPeersResolutionQueue = [];
    const pkgAddresses = [];
    (await Promise.all(extendedWantedDeps.map((extendedWantedDep) => resolveDependenciesOfDependency(ctx, preferredVersions, options, extendedWantedDep)))).forEach(({ resolveDependencyResult, postponedResolution, postponedPeersResolution }) => {
        if (resolveDependencyResult) {
            pkgAddresses.push(resolveDependencyResult);
        }
        if (postponedResolution) {
            postponedResolutionsQueue.push(postponedResolution);
        }
        if (postponedPeersResolution) {
            postponedPeersResolutionQueue.push(postponedPeersResolution);
        }
    });
    const newPreferredVersions = Object.create(preferredVersions);
    const currentParentPkgAliases = {};
    for (const pkgAddress of pkgAddresses) {
        if (currentParentPkgAliases[pkgAddress.alias] !== true) {
            currentParentPkgAliases[pkgAddress.alias] = pkgAddress;
        }
        if (pkgAddress.updated) {
            ctx.updatedSet.add(pkgAddress.alias);
        }
        const resolvedPackage = ctx.resolvedPackagesByDepPath[pkgAddress.depPath];
        if (!resolvedPackage)
            continue; // This will happen only with linked dependencies
        if (!Object.prototype.hasOwnProperty.call(newPreferredVersions, resolvedPackage.name)) {
            newPreferredVersions[resolvedPackage.name] = { ...preferredVersions[resolvedPackage.name] };
        }
        if (!newPreferredVersions[resolvedPackage.name][resolvedPackage.version]) {
            newPreferredVersions[resolvedPackage.name][resolvedPackage.version] = 'version';
        }
    }
    const newParentPkgAliases = {
        ...options.parentPkgAliases,
        ...currentParentPkgAliases,
    };
    const postponedResolutionOpts = {
        preferredVersions: newPreferredVersions,
        parentPkgAliases: newParentPkgAliases,
        publishedBy: options.publishedBy,
    };
    const childrenResults = await Promise.all(postponedResolutionsQueue.map((postponedResolution) => postponedResolution(postponedResolutionOpts)));
    if (!ctx.autoInstallPeers) {
        return {
            resolvingPeers: Promise.resolve({
                missingPeers: {},
                resolvedPeers: {},
            }),
            pkgAddresses,
        };
    }
    return {
        pkgAddresses,
        resolvingPeers: startResolvingPeers({
            childrenResults,
            pkgAddresses,
            parentPkgAliases: options.parentPkgAliases,
            currentParentPkgAliases,
            postponedPeersResolutionQueue,
        }),
    };
}
exports.resolveDependencies = resolveDependencies;
async function startResolvingPeers({ childrenResults, currentParentPkgAliases, parentPkgAliases, pkgAddresses, postponedPeersResolutionQueue, }) {
    const results = await Promise.all(postponedPeersResolutionQueue.map((postponedPeersResolution) => postponedPeersResolution(parentPkgAliases)));
    const resolvedPeers = [...childrenResults, ...results].reduce((acc, { resolvedPeers }) => Object.assign(acc, resolvedPeers), {});
    const allMissingPeers = mergePkgsDeps([
        ...filterMissingPeersFromPkgAddresses(pkgAddresses, currentParentPkgAliases, resolvedPeers),
        ...childrenResults,
        ...results,
    ].map(({ missingPeers }) => missingPeers).filter(Boolean));
    return {
        missingPeers: allMissingPeers,
        resolvedPeers,
    };
}
function mergePkgsDeps(pkgsDeps) {
    const groupedRanges = {};
    for (const deps of pkgsDeps) {
        for (const [name, range] of Object.entries(deps)) {
            if (!groupedRanges[name]) {
                groupedRanges[name] = [];
            }
            groupedRanges[name].push(range);
        }
    }
    const mergedPkgDeps = {};
    for (const [name, ranges] of Object.entries(groupedRanges)) {
        const intersection = (0, mergePeers_1.safeIntersect)(ranges);
        if (intersection) {
            mergedPkgDeps[name] = intersection;
        }
    }
    return mergedPkgDeps;
}
async function resolveDependenciesOfDependency(ctx, preferredVersions, options, extendedWantedDep) {
    const updateDepth = typeof extendedWantedDep.wantedDependency.updateDepth === 'number'
        ? extendedWantedDep.wantedDependency.updateDepth
        : options.updateDepth;
    const updateShouldContinue = options.currentDepth <= updateDepth;
    const update = ((extendedWantedDep.infoFromLockfile?.dependencyLockfile) == null) ||
        (updateShouldContinue && ((options.updateMatching == null) ||
            options.updateMatching(extendedWantedDep.infoFromLockfile.name))) || Boolean((ctx.workspacePackages != null) &&
        ctx.linkWorkspacePackagesDepth !== -1 &&
        (0, wantedDepIsLocallyAvailable_1.wantedDepIsLocallyAvailable)(ctx.workspacePackages, extendedWantedDep.wantedDependency, { defaultTag: ctx.defaultTag, registry: ctx.registries.default })) || ctx.updatedSet.has(extendedWantedDep.infoFromLockfile.name);
    const resolveDependencyOpts = {
        currentDepth: options.currentDepth,
        parentPkg: options.parentPkg,
        parentPkgAliases: options.parentPkgAliases,
        preferredVersions,
        currentPkg: extendedWantedDep.infoFromLockfile ?? undefined,
        pickLowestVersion: options.pickLowestVersion,
        prefix: options.prefix,
        proceed: extendedWantedDep.proceed || updateShouldContinue || ctx.updatedSet.size > 0,
        publishedBy: options.publishedBy,
        update,
        updateDepth,
        updateMatching: options.updateMatching,
    };
    const resolveDependencyResult = await resolveDependency(extendedWantedDep.wantedDependency, ctx, resolveDependencyOpts);
    if (resolveDependencyResult == null)
        return { resolveDependencyResult: null };
    if (resolveDependencyResult.isLinkedDependency) {
        ctx.dependenciesTree.set(createNodeIdForLinkedLocalPkg(ctx.lockfileDir, resolveDependencyResult.resolution.directory), {
            children: {},
            depth: -1,
            installable: true,
            resolvedPackage: {
                name: resolveDependencyResult.name,
                version: resolveDependencyResult.version,
            },
        });
        return { resolveDependencyResult };
    }
    if (!resolveDependencyResult.isNew) {
        return {
            resolveDependencyResult,
            postponedPeersResolution: resolveDependencyResult.missingPeersOfChildren != null
                ? async (parentPkgAliases) => {
                    const missingPeers = await resolveDependencyResult.missingPeersOfChildren.get();
                    return filterMissingPeers({ missingPeers, resolvedPeers: {} }, parentPkgAliases);
                }
                : undefined,
        };
    }
    const postponedResolution = resolveChildren.bind(null, ctx, {
        parentPkg: resolveDependencyResult,
        dependencyLockfile: extendedWantedDep.infoFromLockfile?.dependencyLockfile,
        parentDepth: options.currentDepth,
        updateDepth,
        prefix: options.prefix,
        updateMatching: options.updateMatching,
    });
    return {
        resolveDependencyResult,
        postponedResolution: async (postponedResolutionOpts) => {
            const { missingPeers, resolvedPeers } = await postponedResolution(postponedResolutionOpts);
            if (resolveDependencyResult.missingPeersOfChildren) {
                resolveDependencyResult.missingPeersOfChildren.resolved = true;
                resolveDependencyResult.missingPeersOfChildren.resolve(missingPeers);
            }
            return filterMissingPeers({ missingPeers, resolvedPeers }, postponedResolutionOpts.parentPkgAliases);
        },
    };
}
function createNodeIdForLinkedLocalPkg(lockfileDir, pkgDir) {
    return `link:${(0, normalize_path_1.default)(path_1.default.relative(lockfileDir, pkgDir))}`;
}
exports.createNodeIdForLinkedLocalPkg = createNodeIdForLinkedLocalPkg;
function filterMissingPeers({ missingPeers, resolvedPeers }, parentPkgAliases) {
    const newMissing = {};
    for (const [peerName, peerVersion] of Object.entries(missingPeers)) {
        if (parentPkgAliases[peerName]) {
            if (parentPkgAliases[peerName] !== true) {
                resolvedPeers[peerName] = parentPkgAliases[peerName];
            }
        }
        else {
            newMissing[peerName] = peerVersion;
        }
    }
    return {
        resolvedPeers,
        missingPeers: newMissing,
    };
}
async function resolveChildren(ctx, { parentPkg, dependencyLockfile, parentDepth, updateDepth, updateMatching, prefix, }, { parentPkgAliases, preferredVersions, publishedBy, }) {
    const currentResolvedDependencies = (dependencyLockfile != null)
        ? {
            ...dependencyLockfile.dependencies,
            ...dependencyLockfile.optionalDependencies,
        }
        : undefined;
    const resolvedDependencies = parentPkg.updated
        ? undefined
        : currentResolvedDependencies;
    const parentDependsOnPeer = Boolean(Object.keys(dependencyLockfile?.peerDependencies ??
        parentPkg.pkg.peerDependencies ??
        {}).length);
    const wantedDependencies = (0, getNonDevWantedDependencies_1.getNonDevWantedDependencies)(parentPkg.pkg);
    const { pkgAddresses, resolvingPeers, } = await resolveDependencies(ctx, preferredVersions, wantedDependencies, {
        currentDepth: parentDepth + 1,
        parentPkg,
        parentPkgAliases,
        preferredDependencies: currentResolvedDependencies,
        prefix,
        // If the package is not linked, we should also gather information about its dependencies.
        // After linking the package we'll need to symlink its dependencies.
        proceed: !parentPkg.depIsLinked || parentDependsOnPeer,
        publishedBy,
        resolvedDependencies,
        updateDepth,
        updateMatching,
    });
    ctx.childrenByParentDepPath[parentPkg.depPath] = pkgAddresses.map((child) => ({
        alias: child.alias,
        depPath: child.depPath,
    }));
    ctx.dependenciesTree.set(parentPkg.nodeId, {
        children: pkgAddresses.reduce((chn, child) => {
            chn[child.alias] = child.nodeId ?? child.pkgId;
            return chn;
        }, {}),
        depth: parentDepth,
        installable: parentPkg.installable,
        resolvedPackage: ctx.resolvedPackagesByDepPath[parentPkg.depPath],
    });
    return resolvingPeers;
}
function getDepsToResolve(wantedDependencies, wantedLockfile, options) {
    const resolvedDependencies = options.resolvedDependencies ?? {};
    const preferredDependencies = options.preferredDependencies ?? {};
    const extendedWantedDeps = [];
    // The only reason we resolve children in case the package depends on peers
    // is to get information about the existing dependencies, so that they can
    // be merged with the resolved peers.
    let proceedAll = options.proceed;
    const satisfiesWanted2Args = referenceSatisfiesWantedSpec.bind(null, {
        lockfile: wantedLockfile,
        prefix: options.prefix,
    });
    for (const wantedDependency of wantedDependencies) {
        let reference = undefined;
        let proceed = proceedAll;
        if (wantedDependency.alias) {
            const satisfiesWanted = satisfiesWanted2Args.bind(null, wantedDependency);
            if (resolvedDependencies[wantedDependency.alias] &&
                satisfiesWanted(resolvedDependencies[wantedDependency.alias])) {
                reference = resolvedDependencies[wantedDependency.alias];
            }
            else if (
            // If dependencies that were used by the previous version of the package
            // satisfy the newer version's requirements, then pnpm tries to keep
            // the previous dependency.
            // So for example, if foo@1.0.0 had bar@1.0.0 as a dependency
            // and foo was updated to 1.1.0 which depends on bar ^1.0.0
            // then bar@1.0.0 can be reused for foo@1.1.0
            semver_1.default.validRange(wantedDependency.pref) !== null &&
                preferredDependencies[wantedDependency.alias] &&
                satisfiesWanted(preferredDependencies[wantedDependency.alias])) {
                proceed = true;
                reference = preferredDependencies[wantedDependency.alias];
            }
        }
        const infoFromLockfile = getInfoFromLockfile(wantedLockfile, options.registries, reference, wantedDependency.alias);
        if (!proceedAll &&
            ((infoFromLockfile == null) ||
                infoFromLockfile.dependencyLockfile != null && (infoFromLockfile.dependencyLockfile.peerDependencies != null ||
                    infoFromLockfile.dependencyLockfile.transitivePeerDependencies?.length))) {
            proceed = true;
            proceedAll = true;
            for (const extendedWantedDep of extendedWantedDeps) {
                if (!extendedWantedDep.proceed) {
                    extendedWantedDep.proceed = true;
                }
            }
        }
        extendedWantedDeps.push({
            infoFromLockfile,
            proceed,
            wantedDependency,
        });
    }
    return extendedWantedDeps;
}
function referenceSatisfiesWantedSpec(opts, wantedDep, preferredRef) {
    const depPath = dp.refToRelative(preferredRef, wantedDep.alias);
    if (depPath === null)
        return false;
    const pkgSnapshot = opts.lockfile.packages?.[depPath];
    if (pkgSnapshot == null) {
        logger_1.logger.warn({
            message: `Could not find preferred package ${depPath} in lockfile`,
            prefix: opts.prefix,
        });
        return false;
    }
    const { version } = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, pkgSnapshot);
    return semver_1.default.satisfies(version, wantedDep.pref, true);
}
function getInfoFromLockfile(lockfile, registries, reference, alias) {
    if (!reference || !alias) {
        return undefined;
    }
    const depPath = dp.refToRelative(reference, alias);
    if (!depPath) {
        return undefined;
    }
    let dependencyLockfile = lockfile.packages?.[depPath];
    if (dependencyLockfile != null) {
        if ((dependencyLockfile.peerDependencies != null) && (dependencyLockfile.dependencies != null)) {
            // This is done to guarantee that the dependency will be relinked with the
            // up-to-date peer dependencies
            // Covered by test: "peer dependency is grouped with dependency when peer is resolved not from a top dependency"
            const dependencies = {};
            for (const [depName, ref] of Object.entries(dependencyLockfile.dependencies ?? {})) {
                if (dependencyLockfile.peerDependencies[depName])
                    continue;
                dependencies[depName] = ref;
            }
            dependencyLockfile = {
                ...dependencyLockfile,
                dependencies,
            };
        }
        return {
            ...(0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, dependencyLockfile),
            dependencyLockfile,
            depPath,
            pkgId: (0, lockfile_utils_1.packageIdFromSnapshot)(depPath, dependencyLockfile, registries),
            // resolution may not exist if lockfile is broken, and an unexpected error will be thrown
            // if resolution does not exist, return undefined so it can be autofixed later
            resolution: dependencyLockfile.resolution && (0, lockfile_utils_1.pkgSnapshotToResolution)(depPath, dependencyLockfile, registries),
        };
    }
    else {
        return {
            depPath,
            pkgId: dp.tryGetPackageId(registries, depPath) ?? depPath, // Does it make sense to set pkgId when we're not sure?
        };
    }
}
async function resolveDependency(wantedDependency, ctx, options) {
    const currentPkg = options.currentPkg ?? {};
    const currentLockfileContainsTheDep = currentPkg.depPath
        ? Boolean(ctx.currentLockfile.packages?.[currentPkg.depPath])
        : undefined;
    const depIsLinked = Boolean(
    // if package is not in `node_modules/.pnpm-lock.yaml`
    // we can safely assume that it doesn't exist in `node_modules`
    currentLockfileContainsTheDep &&
        currentPkg.depPath &&
        currentPkg.dependencyLockfile &&
        await (0, path_exists_1.default)(path_1.default.join(ctx.virtualStoreDir, dp.depPathToFilename(currentPkg.depPath), 'node_modules', currentPkg.name, 'package.json')));
    if (!options.update && !options.proceed && (currentPkg.resolution != null) && depIsLinked) {
        return null;
    }
    let pkgResponse;
    if (!options.parentPkg.installable) {
        wantedDependency = {
            ...wantedDependency,
            optional: true,
        };
    }
    try {
        pkgResponse = await ctx.storeController.requestPackage(wantedDependency, {
            alwaysTryWorkspacePackages: ctx.linkWorkspacePackagesDepth >= options.currentDepth,
            currentPkg: currentPkg
                ? {
                    id: currentPkg.pkgId,
                    resolution: currentPkg.resolution,
                }
                : undefined,
            expectedPkg: currentPkg,
            defaultTag: ctx.defaultTag,
            ignoreScripts: ctx.ignoreScripts,
            publishedBy: options.publishedBy,
            pickLowestVersion: options.pickLowestVersion,
            downloadPriority: -options.currentDepth,
            lockfileDir: ctx.lockfileDir,
            preferredVersions: options.preferredVersions,
            preferWorkspacePackages: ctx.preferWorkspacePackages,
            projectDir: (options.currentDepth > 0 &&
                !wantedDependency.pref.startsWith('file:'))
                ? ctx.lockfileDir
                : options.parentPkg.rootDir,
            registry: wantedDependency.alias && (0, pick_registry_for_package_1.pickRegistryForPackage)(ctx.registries, wantedDependency.alias, wantedDependency.pref) || ctx.registries.default,
            // Unfortunately, even when run with --lockfile-only, we need the *real* package.json
            // so fetching of the tarball cannot be ever avoided. Related issue: https://github.com/pnpm/pnpm/issues/1176
            skipFetch: false,
            update: options.update,
            workspacePackages: ctx.workspacePackages,
        });
    }
    catch (err) { // eslint-disable-line
        if (wantedDependency.optional) {
            core_loggers_1.skippedOptionalDependencyLogger.debug({
                details: err.toString(),
                package: {
                    name: wantedDependency.alias,
                    pref: wantedDependency.pref,
                    version: wantedDependency.alias ? wantedDependency.pref : undefined,
                },
                parents: nodeIdToParents(options.parentPkg.nodeId, ctx.resolvedPackagesByDepPath),
                prefix: options.prefix,
                reason: 'resolution_failure',
            });
            return null;
        }
        err.prefix = options.prefix;
        err.pkgsStack = nodeIdToParents(options.parentPkg.nodeId, ctx.resolvedPackagesByDepPath);
        throw err;
    }
    dependencyResolvedLogger.debug({
        resolution: pkgResponse.body.id,
        wanted: {
            dependentId: options.parentPkg.depPath,
            name: wantedDependency.alias,
            rawSpec: wantedDependency.pref,
        },
    });
    pkgResponse.body.id = (0, encodePkgId_1.encodePkgId)(pkgResponse.body.id);
    if (!pkgResponse.body.updated &&
        options.currentDepth === Math.max(0, options.updateDepth) &&
        depIsLinked && !ctx.force && !options.proceed) {
        return null;
    }
    if (pkgResponse.body.isLocal) {
        const manifest = pkgResponse.body.manifest ?? await pkgResponse.bundledManifest();
        if (!manifest) {
            // This should actually never happen because the local-resolver returns a manifest
            // even if no real manifest exists in the filesystem.
            throw new error_1.PnpmError('MISSING_PACKAGE_JSON', `Can't install ${wantedDependency.pref}: Missing package.json file`);
        }
        return {
            alias: wantedDependency.alias || manifest.name,
            depPath: pkgResponse.body.id,
            dev: wantedDependency.dev,
            isLinkedDependency: true,
            name: manifest.name,
            normalizedPref: pkgResponse.body.normalizedPref,
            optional: wantedDependency.optional,
            pkgId: pkgResponse.body.id,
            resolution: pkgResponse.body.resolution,
            version: manifest.version,
        };
    }
    let prepare;
    let hasBin;
    let pkg = await getManifestFromResponse(pkgResponse, wantedDependency);
    if (!pkg.dependencies) {
        pkg.dependencies = {};
    }
    if (ctx.readPackageHook != null) {
        pkg = await ctx.readPackageHook(pkg);
    }
    if (pkg.peerDependencies && pkg.dependencies) {
        if (ctx.autoInstallPeers) {
            pkg = {
                ...pkg,
                dependencies: (0, omit_1.default)(Object.keys(pkg.peerDependencies), pkg.dependencies),
            };
        }
        else {
            pkg = {
                ...pkg,
                dependencies: (0, omit_1.default)(Object.keys(pkg.peerDependencies).filter((peerDep) => options.parentPkgAliases[peerDep]), pkg.dependencies),
            };
        }
    }
    if (!pkg.name) { // TODO: don't fail on optional dependencies
        throw new error_1.PnpmError('MISSING_PACKAGE_NAME', `Can't install ${wantedDependency.pref}: Missing package name`);
    }
    let depPath = dp.relative(ctx.registries, pkg.name, pkgResponse.body.id);
    const nameAndVersion = `${pkg.name}@${pkg.version}`;
    const patchFile = ctx.patchedDependencies?.[nameAndVersion];
    if (patchFile) {
        ctx.appliedPatches.add(nameAndVersion);
        depPath += `(patch_hash=${patchFile.hash})`;
    }
    // We are building the dependency tree only until there are new packages
    // or the packages repeat in a unique order.
    // This is needed later during peer dependencies resolution.
    //
    // So we resolve foo > bar > qar > foo
    // But we stop on foo > bar > qar > foo > qar
    // In the second example, there's no reason to walk qar again
    // when qar is included the first time, the dependencies of foo
    // are already resolved and included as parent dependencies of qar.
    // So during peers resolution, qar cannot possibly get any new or different
    // peers resolved, after the first occurrence.
    //
    // However, in the next example we would analyze the second qar as well,
    // because zoo is a new parent package:
    // foo > bar > qar > zoo > qar
    if ((0, nodeIdUtils_1.nodeIdContainsSequence)(options.parentPkg.nodeId, options.parentPkg.depPath, depPath) || depPath === options.parentPkg.depPath) {
        return null;
    }
    if (!options.update && (currentPkg.dependencyLockfile != null) && currentPkg.depPath &&
        !pkgResponse.body.updated &&
        // peerDependencies field is also used for transitive peer dependencies which should not be linked
        // That's why we cannot omit reading package.json of such dependencies.
        // This can be removed if we implement something like peerDependenciesMeta.transitive: true
        (currentPkg.dependencyLockfile.peerDependencies == null)) {
        prepare = currentPkg.dependencyLockfile.prepare === true;
        hasBin = currentPkg.dependencyLockfile.hasBin === true;
        pkg = {
            ...(0, lockfile_utils_1.nameVerFromPkgSnapshot)(currentPkg.depPath, currentPkg.dependencyLockfile),
            ...currentPkg.dependencyLockfile,
            ...pkg,
        };
    }
    else {
        prepare = Boolean(pkgResponse.body.resolvedVia === 'git-repository' &&
            typeof pkg.scripts?.prepare === 'string');
        if (currentPkg.dependencyLockfile?.deprecated &&
            !pkgResponse.body.updated && !pkg.deprecated) {
            pkg.deprecated = currentPkg.dependencyLockfile.deprecated;
        }
        hasBin = Boolean((pkg.bin && !(pkg.bin === '' || Object.keys(pkg.bin).length === 0)) ?? pkg.directories?.bin);
        /* eslint-enable @typescript-eslint/dot-notation */
    }
    if (options.currentDepth === 0 && pkgResponse.body.latest && pkgResponse.body.latest !== pkg.version) {
        ctx.outdatedDependencies[pkgResponse.body.id] = pkgResponse.body.latest;
    }
    // In case of leaf dependencies (dependencies that have no prod deps or peer deps),
    // we only ever need to analyze one leaf dep in a graph, so the nodeId can be short and stateless.
    const nodeId = pkgIsLeaf(pkg)
        ? `>${depPath}>`
        : (0, nodeIdUtils_1.createNodeId)(options.parentPkg.nodeId, depPath);
    const parentIsInstallable = options.parentPkg.installable === undefined || options.parentPkg.installable;
    const installable = parentIsInstallable && pkgResponse.body.isInstallable !== false;
    const isNew = !ctx.resolvedPackagesByDepPath[depPath];
    const parentImporterId = options.parentPkg.nodeId.substring(0, options.parentPkg.nodeId.indexOf('>', 1) + 1);
    let resolveChildren = false;
    if (isNew) {
        if (pkg.deprecated &&
            (!ctx.allowedDeprecatedVersions[pkg.name] || !semver_1.default.satisfies(pkg.version, ctx.allowedDeprecatedVersions[pkg.name]))) {
            // Report deprecated packages only on first occurrence.
            core_loggers_1.deprecationLogger.debug({
                deprecated: pkg.deprecated,
                depth: options.currentDepth,
                pkgId: pkgResponse.body.id,
                pkgName: pkg.name,
                pkgVersion: pkg.version,
                prefix: options.prefix,
            });
        }
        if (pkgResponse.body.isInstallable === false || !parentIsInstallable) {
            ctx.skipped.add(pkgResponse.body.id);
        }
        core_loggers_1.progressLogger.debug({
            packageId: pkgResponse.body.id,
            requester: ctx.lockfileDir,
            status: 'resolved',
        });
        // WARN: It is very important to keep this sync
        // Otherwise, deprecation messages for the same package might get written several times
        ctx.resolvedPackagesByDepPath[depPath] = getResolvedPackage({
            allowBuild: ctx.allowBuild,
            dependencyLockfile: currentPkg.dependencyLockfile,
            depPath,
            force: ctx.force,
            hasBin,
            patchFile,
            pkg,
            pkgResponse,
            prepare,
            wantedDependency,
            parentImporterId,
        });
    }
    else {
        ctx.resolvedPackagesByDepPath[depPath].prod = ctx.resolvedPackagesByDepPath[depPath].prod || !wantedDependency.dev && !wantedDependency.optional;
        ctx.resolvedPackagesByDepPath[depPath].dev = ctx.resolvedPackagesByDepPath[depPath].dev || wantedDependency.dev;
        ctx.resolvedPackagesByDepPath[depPath].optional = ctx.resolvedPackagesByDepPath[depPath].optional && wantedDependency.optional;
        if (ctx.autoInstallPeers) {
            resolveChildren = !ctx.missingPeersOfChildrenByPkgId[pkgResponse.body.id].missingPeersOfChildren.resolved &&
                !ctx.resolvedPackagesByDepPath[depPath].parentImporterIds.has(parentImporterId);
            ctx.resolvedPackagesByDepPath[depPath].parentImporterIds.add(parentImporterId);
        }
        if (ctx.resolvedPackagesByDepPath[depPath].fetchingFiles == null && pkgResponse.files != null) {
            ctx.resolvedPackagesByDepPath[depPath].fetchingFiles = pkgResponse.files;
            ctx.resolvedPackagesByDepPath[depPath].filesIndexFile = pkgResponse.filesIndexFile;
            ctx.resolvedPackagesByDepPath[depPath].finishing = pkgResponse.finishing;
            ctx.resolvedPackagesByDepPath[depPath].fetchingBundledManifest = pkgResponse.bundledManifest;
        }
        if (ctx.dependenciesTree.has(nodeId)) {
            ctx.dependenciesTree.get(nodeId).depth = Math.min(ctx.dependenciesTree.get(nodeId).depth, options.currentDepth);
        }
        else {
            ctx.pendingNodes.push({
                alias: wantedDependency.alias || pkg.name,
                depth: options.currentDepth,
                installable,
                nodeId,
                resolvedPackage: ctx.resolvedPackagesByDepPath[depPath],
            });
        }
    }
    const rootDir = pkgResponse.body.resolution.type === 'directory'
        ? path_1.default.resolve(ctx.lockfileDir, pkgResponse.body.resolution.directory)
        : options.prefix;
    let missingPeersOfChildren;
    if (ctx.autoInstallPeers && !(0, nodeIdUtils_1.nodeIdContains)(options.parentPkg.nodeId, depPath)) {
        if (ctx.missingPeersOfChildrenByPkgId[pkgResponse.body.id]) {
            if (!options.parentPkg.nodeId.startsWith(ctx.missingPeersOfChildrenByPkgId[pkgResponse.body.id].parentImporterId)) {
                missingPeersOfChildren = ctx.missingPeersOfChildrenByPkgId[pkgResponse.body.id].missingPeersOfChildren;
            }
        }
        else {
            const p = (0, p_defer_1.default)();
            missingPeersOfChildren = {
                resolve: p.resolve,
                reject: p.reject,
                get: (0, promise_share_1.default)(p.promise),
            };
            ctx.missingPeersOfChildrenByPkgId[pkgResponse.body.id] = {
                parentImporterId,
                missingPeersOfChildren,
            };
        }
    }
    return {
        alias: wantedDependency.alias || pkg.name,
        depIsLinked,
        depPath,
        isNew: isNew || resolveChildren,
        nodeId,
        normalizedPref: options.currentDepth === 0 ? pkgResponse.body.normalizedPref : undefined,
        missingPeersOfChildren,
        pkgId: pkgResponse.body.id,
        rootDir,
        missingPeers: getMissingPeers(pkg),
        // Next fields are actually only needed when isNew = true
        installable,
        isLinkedDependency: undefined,
        pkg,
        updated: pkgResponse.body.updated,
        publishedAt: pkgResponse.body.publishedAt,
    };
}
async function getManifestFromResponse(pkgResponse, wantedDependency) {
    const pkg = pkgResponse.body.manifest ?? await pkgResponse.bundledManifest();
    if (pkg)
        return pkg;
    return {
        name: wantedDependency.pref.split('/').pop(),
        version: '0.0.0',
    };
}
function getMissingPeers(pkg) {
    const missingPeers = {};
    for (const [peerName, peerVersion] of Object.entries(pkg.peerDependencies ?? {})) {
        if (!pkg.peerDependenciesMeta?.[peerName]?.optional) {
            missingPeers[peerName] = peerVersion;
        }
    }
    return missingPeers;
}
function pkgIsLeaf(pkg) {
    return Object.keys(pkg.dependencies ?? {}).length === 0 &&
        Object.keys(pkg.optionalDependencies ?? {}).length === 0 &&
        Object.keys(pkg.peerDependencies ?? {}).length === 0 &&
        // Package manifests can declare peerDependenciesMeta without declaring
        // peerDependencies. peerDependenciesMeta implies the later.
        Object.keys(pkg.peerDependenciesMeta ?? {}).length === 0;
}
function getResolvedPackage(options) {
    const peerDependencies = peerDependenciesWithoutOwn(options.pkg);
    const requiresBuild = (options.allowBuild == null || options.allowBuild(options.pkg.name))
        ? ((options.dependencyLockfile != null) ? Boolean(options.dependencyLockfile.requiresBuild) : (0, safe_promise_defer_1.default)())
        : false;
    return {
        additionalInfo: {
            bundledDependencies: options.pkg.bundledDependencies,
            bundleDependencies: options.pkg.bundleDependencies,
            cpu: options.pkg.cpu,
            deprecated: options.pkg.deprecated,
            engines: options.pkg.engines,
            os: options.pkg.os,
            libc: options.pkg.libc,
        },
        parentImporterIds: new Set([options.parentImporterId]),
        depPath: options.depPath,
        dev: options.wantedDependency.dev,
        fetchingBundledManifest: options.pkgResponse.bundledManifest,
        fetchingFiles: options.pkgResponse.files,
        filesIndexFile: options.pkgResponse.filesIndexFile,
        finishing: options.pkgResponse.finishing,
        hasBin: options.hasBin,
        hasBundledDependencies: !((options.pkg.bundledDependencies ?? options.pkg.bundleDependencies) == null),
        id: options.pkgResponse.body.id,
        name: options.pkg.name,
        optional: options.wantedDependency.optional,
        optionalDependencies: new Set(Object.keys(options.pkg.optionalDependencies ?? {})),
        patchFile: options.patchFile,
        peerDependencies: peerDependencies ?? {},
        peerDependenciesMeta: options.pkg.peerDependenciesMeta,
        prepare: options.prepare,
        prod: !options.wantedDependency.dev && !options.wantedDependency.optional,
        requiresBuild,
        resolution: options.pkgResponse.body.resolution,
        version: options.pkg.version,
    };
}
function peerDependenciesWithoutOwn(pkg) {
    if ((pkg.peerDependencies == null) && (pkg.peerDependenciesMeta == null))
        return pkg.peerDependencies;
    const ownDeps = new Set([
        ...Object.keys(pkg.dependencies ?? {}),
        ...Object.keys(pkg.optionalDependencies ?? {}),
    ]);
    const result = {};
    if (pkg.peerDependencies != null) {
        for (const [peerName, peerRange] of Object.entries(pkg.peerDependencies)) {
            if (ownDeps.has(peerName))
                continue;
            result[peerName] = peerRange;
        }
    }
    if (pkg.peerDependenciesMeta != null) {
        for (const [peerName, peerMeta] of Object.entries(pkg.peerDependenciesMeta)) {
            if (ownDeps.has(peerName) || result[peerName] || peerMeta.optional !== true)
                continue;
            result[peerName] = '*';
        }
    }
    if (Object.keys(result).length === 0)
        return undefined;
    return result;
}
//# sourceMappingURL=resolveDependencies.js.map