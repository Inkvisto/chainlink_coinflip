"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContextForSingleImporter = exports.getContext = exports.UnexpectedVirtualStoreDirError = exports.UnexpectedStoreError = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = require("@pnpm/error");
const logger_1 = require("@pnpm/logger");
const read_projects_context_1 = require("@pnpm/read-projects-context");
const types_1 = require("@pnpm/types");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const ci_info_1 = require("ci-info");
const enquirer_1 = __importDefault(require("enquirer"));
const path_absolute_1 = __importDefault(require("path-absolute"));
const clone_1 = __importDefault(require("ramda/src/clone"));
const equals_1 = __importDefault(require("ramda/src/equals"));
const checkCompatibility_1 = require("./checkCompatibility");
const UnexpectedStoreError_1 = require("./checkCompatibility/UnexpectedStoreError");
Object.defineProperty(exports, "UnexpectedStoreError", { enumerable: true, get: function () { return UnexpectedStoreError_1.UnexpectedStoreError; } });
const UnexpectedVirtualStoreDirError_1 = require("./checkCompatibility/UnexpectedVirtualStoreDirError");
Object.defineProperty(exports, "UnexpectedVirtualStoreDirError", { enumerable: true, get: function () { return UnexpectedVirtualStoreDirError_1.UnexpectedVirtualStoreDirError; } });
const readLockfiles_1 = require("./readLockfiles");
async function getContext(opts) {
    const modulesDir = opts.modulesDir ?? 'node_modules';
    let importersContext = await (0, read_projects_context_1.readProjectsContext)(opts.allProjects, { lockfileDir: opts.lockfileDir, modulesDir });
    const virtualStoreDir = (0, path_absolute_1.default)(opts.virtualStoreDir ?? path_1.default.join(modulesDir, '.pnpm'), opts.lockfileDir);
    if (importersContext.modules != null) {
        const { purged } = await validateModules(importersContext.modules, importersContext.projects, {
            currentHoistPattern: importersContext.currentHoistPattern,
            currentPublicHoistPattern: importersContext.currentPublicHoistPattern,
            forceNewModules: opts.forceNewModules === true,
            include: opts.include,
            lockfileDir: opts.lockfileDir,
            modulesDir,
            registries: opts.registries,
            storeDir: opts.storeDir,
            virtualStoreDir,
            confirmModulesPurge: opts.confirmModulesPurge && !ci_info_1.isCI,
            forceHoistPattern: opts.forceHoistPattern,
            hoistPattern: opts.hoistPattern,
            forcePublicHoistPattern: opts.forcePublicHoistPattern,
            publicHoistPattern: opts.publicHoistPattern,
            global: opts.global,
        });
        if (purged) {
            importersContext = await (0, read_projects_context_1.readProjectsContext)(opts.allProjects, {
                lockfileDir: opts.lockfileDir,
                modulesDir,
            });
        }
    }
    await fs_1.promises.mkdir(opts.storeDir, { recursive: true });
    opts.allProjects.forEach((project) => {
        core_loggers_1.packageManifestLogger.debug({
            initial: project.manifest,
            prefix: project.rootDir,
        });
    });
    if (opts.readPackageHook != null) {
        await Promise.all(importersContext.projects.map(async (project) => {
            project.originalManifest = project.manifest;
            project.manifest = await opts.readPackageHook((0, clone_1.default)(project.manifest), project.rootDir);
        }));
    }
    const extraBinPaths = [
        ...opts.extraBinPaths || [],
    ];
    const hoistedModulesDir = path_1.default.join(virtualStoreDir, 'node_modules');
    if (opts.hoistPattern?.length) {
        extraBinPaths.unshift(path_1.default.join(hoistedModulesDir, '.bin'));
    }
    const hoistPattern = importersContext.currentHoistPattern ?? opts.hoistPattern;
    const ctx = {
        extraBinPaths,
        extraNodePaths: getExtraNodePaths({ extendNodePath: opts.extendNodePath, nodeLinker: opts.nodeLinker, hoistPattern, virtualStoreDir }),
        hoistedDependencies: importersContext.hoistedDependencies,
        hoistedModulesDir,
        hoistPattern,
        include: opts.include ?? importersContext.include,
        lockfileDir: opts.lockfileDir,
        modulesFile: importersContext.modules,
        pendingBuilds: importersContext.pendingBuilds,
        projects: Object.fromEntries(importersContext.projects.map((project) => [project.rootDir, project])),
        publicHoistPattern: importersContext.currentPublicHoistPattern ?? opts.publicHoistPattern,
        registries: {
            ...opts.registries,
            ...importersContext.registries,
        },
        rootModulesDir: importersContext.rootModulesDir,
        skipped: importersContext.skipped,
        storeDir: opts.storeDir,
        virtualStoreDir,
        ...await (0, readLockfiles_1.readLockfiles)({
            autoInstallPeers: opts.autoInstallPeers,
            excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
            force: opts.force,
            forceSharedLockfile: opts.forceSharedLockfile,
            frozenLockfile: opts.frozenLockfile === true,
            lockfileDir: opts.lockfileDir,
            projects: importersContext.projects,
            registry: opts.registries.default,
            useLockfile: opts.useLockfile,
            useGitBranchLockfile: opts.useGitBranchLockfile,
            mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles,
            virtualStoreDir,
        }),
    };
    core_loggers_1.contextLogger.debug({
        currentLockfileExists: ctx.existsCurrentLockfile,
        storeDir: opts.storeDir,
        virtualStoreDir,
    });
    return ctx;
}
exports.getContext = getContext;
async function validateModules(modules, projects, opts) {
    const rootProject = projects.find(({ id }) => id === '.');
    if (opts.forcePublicHoistPattern &&
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        !(0, equals_1.default)(modules.publicHoistPattern, opts.publicHoistPattern || undefined)) {
        if (opts.forceNewModules && (rootProject != null)) {
            await purgeModulesDirsOfImporter(opts, rootProject);
            return { purged: true };
        }
        throw new error_1.PnpmError('PUBLIC_HOIST_PATTERN_DIFF', 'This modules directory was created using a different public-hoist-pattern value.' +
            ' Run "pnpm install" to recreate the modules directory.');
    }
    let purged = false;
    if (opts.forceHoistPattern && (rootProject != null)) {
        try {
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            if (!(0, equals_1.default)(opts.currentHoistPattern, opts.hoistPattern || undefined)) {
                throw new error_1.PnpmError('HOIST_PATTERN_DIFF', 'This modules directory was created using a different hoist-pattern value.' +
                    ' Run "pnpm install" to recreate the modules directory.');
            }
        }
        catch (err) { // eslint-disable-line
            if (!opts.forceNewModules)
                throw err;
            await purgeModulesDirsOfImporter(opts, rootProject);
            purged = true;
        }
    }
    await Promise.all(projects.map(async (project) => {
        try {
            (0, checkCompatibility_1.checkCompatibility)(modules, {
                modulesDir: project.modulesDir,
                storeDir: opts.storeDir,
                virtualStoreDir: opts.virtualStoreDir,
            });
            if (opts.lockfileDir !== project.rootDir && (opts.include != null) && modules.included) {
                for (const depsField of types_1.DEPENDENCIES_FIELDS) {
                    if (opts.include[depsField] !== modules.included[depsField]) {
                        throw new error_1.PnpmError('INCLUDED_DEPS_CONFLICT', `modules directory (at "${opts.lockfileDir}") was installed with ${stringifyIncludedDeps(modules.included)}. ` +
                            `Current install wants ${stringifyIncludedDeps(opts.include)}.`);
                    }
                }
            }
        }
        catch (err) { // eslint-disable-line
            if (!opts.forceNewModules)
                throw err;
            await purgeModulesDirsOfImporter(opts, project);
            purged = true;
        }
    }));
    if ((modules.registries != null) && !(0, equals_1.default)(opts.registries, modules.registries)) {
        if (opts.forceNewModules) {
            await purgeModulesDirsOfImporters(opts, projects);
            return { purged: true };
        }
        throw new error_1.PnpmError('REGISTRIES_MISMATCH', `This modules directory was created using the following registries configuration: ${JSON.stringify(modules.registries)}. The current configuration is ${JSON.stringify(opts.registries)}. To recreate the modules directory using the new settings, run "pnpm install${opts.global ? ' -g' : ''}".`);
    }
    if (purged && (rootProject == null)) {
        await purgeModulesDirsOfImporter(opts, {
            modulesDir: path_1.default.join(opts.lockfileDir, opts.modulesDir),
            rootDir: opts.lockfileDir,
        });
    }
    return { purged };
}
async function purgeModulesDirsOfImporter(opts, importer) {
    return purgeModulesDirsOfImporters(opts, [importer]);
}
async function purgeModulesDirsOfImporters(opts, importers) {
    if (opts.confirmModulesPurge ?? true) {
        const confirmed = await enquirer_1.default.prompt({
            type: 'confirm',
            name: 'question',
            message: importers.length === 1
                ? `The modules directory at "${importers[0].modulesDir}" will be removed and reinstalled from scratch. Proceed?`
                : 'The modules directories will be removed and reinstalled from scratch. Proceed?',
            initial: true,
        });
        if (!confirmed) {
            throw new error_1.PnpmError('ABORTED_REMOVE_MODULES_DIR', 'Aborted removal of modules directory');
        }
    }
    await Promise.all(importers.map(async (importer) => {
        logger_1.logger.info({
            message: `Recreating ${importer.modulesDir}`,
            prefix: importer.rootDir,
        });
        try {
            // We don't remove the actual modules directory, just the contents of it.
            // 1. we will need the directory anyway.
            // 2. in some setups, pnpm won't even have permission to remove the modules directory.
            await removeContentsOfDir(importer.modulesDir, opts.virtualStoreDir);
        }
        catch (err) { // eslint-disable-line
            if (err.code !== 'ENOENT')
                throw err;
        }
    }));
}
async function removeContentsOfDir(dir, virtualStoreDir) {
    const items = await fs_1.promises.readdir(dir);
    await Promise.all(items.map(async (item) => {
        // The non-pnpm related hidden files are kept
        if (item.startsWith('.') &&
            item !== '.bin' &&
            item !== '.modules.yaml' &&
            !dirsAreEqual(path_1.default.join(dir, item), virtualStoreDir)) {
            return;
        }
        await (0, rimraf_1.default)(path_1.default.join(dir, item));
    }));
}
function dirsAreEqual(dir1, dir2) {
    return path_1.default.relative(dir1, dir2) === '';
}
function stringifyIncludedDeps(included) {
    return types_1.DEPENDENCIES_FIELDS.filter((depsField) => included[depsField]).join(', ');
}
async function getContextForSingleImporter(manifest, opts, alreadyPurged = false) {
    const { currentHoistPattern, currentPublicHoistPattern, hoistedDependencies, projects, include, modules, pendingBuilds, registries, skipped, rootModulesDir, } = await (0, read_projects_context_1.readProjectsContext)([
        {
            rootDir: opts.dir,
        },
    ], {
        lockfileDir: opts.lockfileDir,
        modulesDir: opts.modulesDir,
    });
    const storeDir = opts.storeDir;
    const importer = projects[0];
    const modulesDir = importer.modulesDir;
    const importerId = importer.id;
    const virtualStoreDir = (0, path_absolute_1.default)(opts.virtualStoreDir ?? 'node_modules/.pnpm', opts.lockfileDir);
    if ((modules != null) && !alreadyPurged) {
        const { purged } = await validateModules(modules, projects, {
            currentHoistPattern,
            currentPublicHoistPattern,
            forceNewModules: opts.forceNewModules === true,
            include: opts.include,
            lockfileDir: opts.lockfileDir,
            modulesDir: opts.modulesDir ?? 'node_modules',
            registries: opts.registries,
            storeDir: opts.storeDir,
            virtualStoreDir,
            confirmModulesPurge: opts.confirmModulesPurge && !ci_info_1.isCI,
            forceHoistPattern: opts.forceHoistPattern,
            hoistPattern: opts.hoistPattern,
            forcePublicHoistPattern: opts.forcePublicHoistPattern,
            publicHoistPattern: opts.publicHoistPattern,
        });
        if (purged) {
            return getContextForSingleImporter(manifest, opts, true);
        }
    }
    await fs_1.promises.mkdir(storeDir, { recursive: true });
    const extraBinPaths = [
        ...opts.extraBinPaths || [],
    ];
    const hoistedModulesDir = path_1.default.join(virtualStoreDir, 'node_modules');
    if (opts.hoistPattern?.length) {
        extraBinPaths.unshift(path_1.default.join(hoistedModulesDir, '.bin'));
    }
    const hoistPattern = currentHoistPattern ?? opts.hoistPattern;
    const ctx = {
        extraBinPaths,
        extraNodePaths: getExtraNodePaths({ extendNodePath: opts.extendNodePath, nodeLinker: opts.nodeLinker, hoistPattern, virtualStoreDir }),
        hoistedDependencies,
        hoistedModulesDir,
        hoistPattern,
        importerId,
        include: opts.include ?? include,
        lockfileDir: opts.lockfileDir,
        manifest: await opts.readPackageHook?.(manifest) ?? manifest,
        modulesDir,
        modulesFile: modules,
        pendingBuilds,
        prefix: opts.dir,
        publicHoistPattern: currentPublicHoistPattern ?? opts.publicHoistPattern,
        registries: {
            ...opts.registries,
            ...registries,
        },
        rootModulesDir,
        skipped,
        storeDir,
        virtualStoreDir,
        ...await (0, readLockfiles_1.readLockfiles)({
            autoInstallPeers: opts.autoInstallPeers,
            excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
            force: opts.force,
            forceSharedLockfile: opts.forceSharedLockfile,
            frozenLockfile: false,
            lockfileDir: opts.lockfileDir,
            projects: [{ id: importerId, rootDir: opts.dir }],
            registry: opts.registries.default,
            useLockfile: opts.useLockfile,
            useGitBranchLockfile: opts.useGitBranchLockfile,
            mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles,
            virtualStoreDir,
        }),
    };
    core_loggers_1.packageManifestLogger.debug({
        initial: manifest,
        prefix: opts.dir,
    });
    core_loggers_1.contextLogger.debug({
        currentLockfileExists: ctx.existsCurrentLockfile,
        storeDir: opts.storeDir,
        virtualStoreDir,
    });
    return ctx;
}
exports.getContextForSingleImporter = getContextForSingleImporter;
function getExtraNodePaths({ extendNodePath = true, hoistPattern, nodeLinker, virtualStoreDir }) {
    if (extendNodePath && nodeLinker === 'isolated' && hoistPattern?.length) {
        return [path_1.default.join(virtualStoreDir, 'node_modules')];
    }
    return [];
}
//# sourceMappingURL=index.js.map