"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readLockfiles = void 0;
const constants_1 = require("@pnpm/constants");
const lockfile_file_1 = require("@pnpm/lockfile-file");
const logger_1 = require("@pnpm/logger");
const ci_info_1 = require("ci-info");
const clone_1 = __importDefault(require("ramda/src/clone"));
const equals_1 = __importDefault(require("ramda/src/equals"));
async function readLockfiles(opts) {
    const wantedLockfileVersion = constants_1.LOCKFILE_VERSION_V6;
    // ignore `pnpm-lock.yaml` on CI servers
    // a latest pnpm should not break all the builds
    const lockfileOpts = {
        ignoreIncompatible: opts.force || ci_info_1.isCI,
        wantedVersions: [constants_1.LOCKFILE_VERSION.toString(), constants_1.LOCKFILE_VERSION_V6],
        useGitBranchLockfile: opts.useGitBranchLockfile,
        mergeGitBranchLockfiles: opts.mergeGitBranchLockfiles,
    };
    const fileReads = [];
    let lockfileHadConflicts = false;
    if (opts.useLockfile) {
        if (!opts.frozenLockfile) {
            fileReads.push((async () => {
                try {
                    const { lockfile, hadConflicts } = await (0, lockfile_file_1.readWantedLockfileAndAutofixConflicts)(opts.lockfileDir, lockfileOpts);
                    lockfileHadConflicts = hadConflicts;
                    return lockfile;
                }
                catch (err) { // eslint-disable-line
                    logger_1.logger.warn({
                        message: `Ignoring broken lockfile at ${opts.lockfileDir}: ${err.message}`,
                        prefix: opts.lockfileDir,
                    });
                    return undefined;
                }
            })());
        }
        else {
            fileReads.push((0, lockfile_file_1.readWantedLockfile)(opts.lockfileDir, lockfileOpts));
        }
    }
    else {
        if (await (0, lockfile_file_1.existsNonEmptyWantedLockfile)(opts.lockfileDir, lockfileOpts)) {
            logger_1.logger.warn({
                message: `A ${constants_1.WANTED_LOCKFILE} file exists. The current configuration prohibits to read or write a lockfile`,
                prefix: opts.lockfileDir,
            });
        }
        fileReads.push(Promise.resolve(undefined));
    }
    fileReads.push((async () => {
        try {
            return await (0, lockfile_file_1.readCurrentLockfile)(opts.virtualStoreDir, lockfileOpts);
        }
        catch (err) { // eslint-disable-line
            logger_1.logger.warn({
                message: `Ignoring broken lockfile at ${opts.virtualStoreDir}: ${err.message}`,
                prefix: opts.lockfileDir,
            });
            return undefined;
        }
    })());
    const files = await Promise.all(fileReads);
    const sopts = {
        autoInstallPeers: opts.autoInstallPeers,
        excludeLinksFromLockfile: opts.excludeLinksFromLockfile,
        lockfileVersion: wantedLockfileVersion,
    };
    const importerIds = opts.projects.map((importer) => importer.id);
    const currentLockfile = files[1] ?? (0, lockfile_file_1.createLockfileObject)(importerIds, sopts);
    for (const importerId of importerIds) {
        if (!currentLockfile.importers[importerId]) {
            currentLockfile.importers[importerId] = {
                specifiers: {},
            };
        }
    }
    const wantedLockfile = files[0] ??
        (currentLockfile && (0, clone_1.default)(currentLockfile)) ??
        (0, lockfile_file_1.createLockfileObject)(importerIds, sopts);
    let wantedLockfileIsModified = false;
    for (const importerId of importerIds) {
        if (!wantedLockfile.importers[importerId]) {
            wantedLockfileIsModified = true;
            wantedLockfile.importers[importerId] = {
                specifiers: {},
            };
        }
    }
    const existsWantedLockfile = files[0] != null;
    return {
        currentLockfile,
        currentLockfileIsUpToDate: (0, equals_1.default)(currentLockfile, wantedLockfile),
        existsCurrentLockfile: files[1] != null,
        existsWantedLockfile,
        existsNonEmptyWantedLockfile: existsWantedLockfile && !(0, lockfile_file_1.isEmptyLockfile)(wantedLockfile),
        wantedLockfile,
        wantedLockfileIsModified,
        lockfileHadConflicts,
    };
}
exports.readLockfiles = readLockfiles;
//# sourceMappingURL=readLockfiles.js.map