"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickVersionByVersionRange = exports.pickLowestVersionByVersionRange = exports.pickPackageFromMeta = void 0;
const error_1 = require("@pnpm/error");
const semver_1 = __importDefault(require("semver"));
function pickPackageFromMeta(pickVersionByVersionRangeFn, spec, preferredVersionSelectors, meta, publishedBy) {
    if ((!meta.versions || Object.keys(meta.versions).length === 0) && !publishedBy) {
        // Unfortunately, the npm registry doesn't return the time field in the abbreviated metadata.
        // So we won't always know if the package was unpublished.
        if (meta.time?.unpublished?.versions?.length) {
            throw new error_1.PnpmError('UNPUBLISHED_PKG', `No versions available for ${spec.name} because it was unpublished`);
        }
        throw new error_1.PnpmError('NO_VERSIONS', `No versions available for ${spec.name}. The package may be unpublished.`);
    }
    try {
        let version;
        switch (spec.type) {
            case 'version':
                version = spec.fetchSpec;
                break;
            case 'tag':
                version = meta['dist-tags'][spec.fetchSpec];
                break;
            case 'range':
                version = pickVersionByVersionRangeFn(meta, spec.fetchSpec, preferredVersionSelectors, publishedBy);
                break;
        }
        if (!version)
            return null;
        const manifest = meta.versions[version];
        if (manifest && meta['name']) {
            // Packages that are published to the GitHub registry are always published with a scope.
            // However, the name in the package.json for some reason may omit the scope.
            // So the package published to the GitHub registry will be published under @foo/bar
            // but the name in package.json will be just bar.
            // In order to avoid issues, we consider that the real name of the package is the one with the scope.
            manifest.name = meta['name'];
        }
        return manifest;
    }
    catch (err) { // eslint-disable-line
        throw new error_1.PnpmError('MALFORMED_METADATA', `Received malformed metadata for "${spec.name}"`, { hint: 'This might mean that the package was unpublished from the registry' });
    }
}
exports.pickPackageFromMeta = pickPackageFromMeta;
const semverRangeCache = new Map();
// This is a performance optimization; working with string-ish semver
// causes lots of allocations and repeated work, but caching the Range
// and ensuring we give it a SemVer instance greatly speeds things up.
function semverSatisfiesLoose(version, range) {
    let semverRange = semverRangeCache.get(range);
    if (semverRange === undefined) {
        try {
            semverRange = new semver_1.default.Range(range, true);
        }
        catch {
            semverRange = null;
        }
        semverRangeCache.set(range, semverRange);
    }
    if (semverRange) {
        try {
            return semverRange.test(new semver_1.default.SemVer(version, true));
        }
        catch {
            return false;
        }
    }
    return false;
}
function pickLowestVersionByVersionRange(meta, versionRange, preferredVerSels) {
    if (preferredVerSels != null && Object.keys(preferredVerSels).length > 0) {
        const prioritizedPreferredVersions = prioritizePreferredVersions(meta, versionRange, preferredVerSels);
        for (const preferredVersions of prioritizedPreferredVersions) {
            const preferredVersion = semver_1.default.minSatisfying(preferredVersions, versionRange, true);
            if (preferredVersion) {
                return preferredVersion;
            }
        }
    }
    if (versionRange === '*') {
        return Object.keys(meta.versions).sort(semver_1.default.compare)[0];
    }
    return semver_1.default.minSatisfying(Object.keys(meta.versions), versionRange, true);
}
exports.pickLowestVersionByVersionRange = pickLowestVersionByVersionRange;
function pickVersionByVersionRange(meta, versionRange, preferredVerSels, publishedBy) {
    let latest = meta['dist-tags'].latest;
    if (preferredVerSels != null && Object.keys(preferredVerSels).length > 0) {
        const prioritizedPreferredVersions = prioritizePreferredVersions(meta, versionRange, preferredVerSels);
        for (const preferredVersions of prioritizedPreferredVersions) {
            if (preferredVersions.includes(latest) && semverSatisfiesLoose(latest, versionRange)) {
                return latest;
            }
            const preferredVersion = semver_1.default.maxSatisfying(preferredVersions, versionRange, true);
            if (preferredVersion) {
                return preferredVersion;
            }
        }
    }
    let versions = Object.keys(meta.versions);
    if (publishedBy) {
        versions = versions.filter(version => new Date(meta.time[version]) <= publishedBy);
        if (!versions.includes(latest)) {
            latest = undefined;
        }
    }
    if (latest && (versionRange === '*' || semverSatisfiesLoose(latest, versionRange))) {
        // Not using semver.satisfies in case of * because it does not select beta versions.
        // E.g.: 1.0.0-beta.1. See issue: https://github.com/pnpm/pnpm/issues/865
        return latest;
    }
    const maxVersion = semver_1.default.maxSatisfying(versions, versionRange, true);
    // if the selected version is deprecated, try to find a non-deprecated one that satisfies the range
    if (maxVersion && meta.versions[maxVersion].deprecated && versions.length > 1) {
        const nonDeprecatedVersions = versions.map((version) => meta.versions[version])
            .filter((versionMeta) => !versionMeta.deprecated)
            .map((versionMeta) => versionMeta.version);
        const maxNonDeprecatedVersion = semver_1.default.maxSatisfying(nonDeprecatedVersions, versionRange, true);
        if (maxNonDeprecatedVersion)
            return maxNonDeprecatedVersion;
    }
    return maxVersion;
}
exports.pickVersionByVersionRange = pickVersionByVersionRange;
function prioritizePreferredVersions(meta, versionRange, preferredVerSels) {
    const preferredVerSelsArr = Object.entries(preferredVerSels ?? {});
    const versionsPrioritizer = new PreferredVersionsPrioritizer();
    for (const [preferredSelector, preferredSelectorType] of preferredVerSelsArr) {
        const { selectorType, weight } = typeof preferredSelectorType === 'string'
            ? { selectorType: preferredSelectorType, weight: 1 }
            : preferredSelectorType;
        if (preferredSelector === versionRange)
            continue;
        switch (selectorType) {
            case 'tag': {
                versionsPrioritizer.add(meta['dist-tags'][preferredSelector], weight);
                break;
            }
            case 'range': {
                const versions = Object.keys(meta.versions);
                for (const version of versions) {
                    if (semverSatisfiesLoose(version, preferredSelector)) {
                        versionsPrioritizer.add(version, weight);
                    }
                }
                break;
            }
            case 'version': {
                if (meta.versions[preferredSelector]) {
                    versionsPrioritizer.add(preferredSelector, weight);
                }
                break;
            }
        }
    }
    return versionsPrioritizer.versionsByPriority();
}
class PreferredVersionsPrioritizer {
    constructor() {
        this.preferredVersions = {};
    }
    add(version, weight) {
        if (!this.preferredVersions[version]) {
            this.preferredVersions[version] = weight;
        }
        else {
            this.preferredVersions[version] += weight;
        }
    }
    versionsByPriority() {
        const versionsByWeight = Object.entries(this.preferredVersions)
            .reduce((acc, [version, weight]) => {
            acc[weight] = acc[weight] ?? [];
            acc[weight].push(version);
            return acc;
        }, {});
        return Object.keys(versionsByWeight)
            .sort((a, b) => parseInt(b, 10) - parseInt(a, 10))
            .map((weigth) => versionsByWeight[parseInt(weigth, 10)]);
    }
}
//# sourceMappingURL=pickPackageFromMeta.js.map