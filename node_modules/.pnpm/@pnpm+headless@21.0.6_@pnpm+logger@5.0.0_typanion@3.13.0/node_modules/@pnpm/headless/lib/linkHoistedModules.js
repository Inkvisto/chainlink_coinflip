"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkHoistedModules = void 0;
const path_1 = __importDefault(require("path"));
const calc_dep_state_1 = require("@pnpm/calc-dep-state");
const core_loggers_1 = require("@pnpm/core-loggers");
const link_bins_1 = require("@pnpm/link-bins");
const logger_1 = require("@pnpm/logger");
const p_limit_1 = __importDefault(require("p-limit"));
const difference_1 = __importDefault(require("ramda/src/difference"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const limitLinking = (0, p_limit_1.default)(16);
async function linkHoistedModules(storeController, graph, prevGraph, hierarchy, opts) {
    // TODO: remove nested node modules first
    const dirsToRemove = (0, difference_1.default)(Object.keys(prevGraph), Object.keys(graph));
    core_loggers_1.statsLogger.debug({
        prefix: opts.lockfileDir,
        removed: dirsToRemove.length,
    });
    await Promise.all([
        ...dirsToRemove.map((dir) => tryRemoveDir(dir)),
        ...Object.entries(hierarchy)
            .map(([parentDir, depsHierarchy]) => {
            function warn(message) {
                logger_1.logger.info({
                    message,
                    prefix: parentDir,
                });
            }
            return linkAllPkgsInOrder(storeController, graph, prevGraph, depsHierarchy, parentDir, {
                ...opts,
                warn,
            });
        }),
    ]);
}
exports.linkHoistedModules = linkHoistedModules;
async function tryRemoveDir(dir) {
    core_loggers_1.removalLogger.debug(dir);
    try {
        await (0, rimraf_1.default)(dir);
    }
    catch (err) { // eslint-disable-line
        /* Just ignoring for now. Not even logging.
        logger.warn({
          error: err,
          message: `Failed to remove "${pathToRemove}"`,
          prefix: lockfileDir,
        })
        */
    }
}
async function linkAllPkgsInOrder(storeController, graph, prevGraph, hierarchy, parentDir, opts) {
    const _calcDepState = calc_dep_state_1.calcDepState.bind(null, graph, opts.depsStateCache);
    await Promise.all(Object.entries(hierarchy).map(async ([dir, deps]) => {
        const depNode = graph[dir];
        if (depNode.fetchingFiles) {
            let filesResponse;
            try {
                filesResponse = await depNode.fetchingFiles();
            }
            catch (err) { // eslint-disable-line
                if (depNode.optional)
                    return;
                throw err;
            }
            let sideEffectsCacheKey;
            if (opts.sideEffectsCacheRead && filesResponse.sideEffects && !(0, isEmpty_1.default)(filesResponse.sideEffects)) {
                sideEffectsCacheKey = _calcDepState(dir, {
                    isBuilt: !opts.ignoreScripts && depNode.requiresBuild,
                    patchFileHash: depNode.patchFile?.hash,
                });
            }
            // Limiting the concurrency here fixes an out of memory error.
            // It is not clear why it helps as importing is also limited inside fs.indexed-pkg-importer.
            // The out of memory error was reproduced on the teambit/bit repository with the "rootComponents" feature turned on
            await limitLinking(async () => {
                const { importMethod, isBuilt } = await storeController.importPackage(depNode.dir, {
                    filesResponse,
                    force: opts.force || depNode.depPath !== prevGraph[dir]?.depPath,
                    keepModulesDir: true,
                    requiresBuild: depNode.requiresBuild || depNode.patchFile != null,
                    sideEffectsCacheKey,
                });
                if (importMethod) {
                    core_loggers_1.progressLogger.debug({
                        method: importMethod,
                        requester: opts.lockfileDir,
                        status: 'imported',
                        to: depNode.dir,
                    });
                }
                depNode.isBuilt = isBuilt;
            });
        }
        return linkAllPkgsInOrder(storeController, graph, prevGraph, deps, dir, opts);
    }));
    const modulesDir = path_1.default.join(parentDir, 'node_modules');
    const binsDir = path_1.default.join(modulesDir, '.bin');
    await (0, link_bins_1.linkBins)(modulesDir, binsDir, {
        allowExoticManifests: true,
        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
        warn: opts.warn,
    });
}
//# sourceMappingURL=linkHoistedModules.js.map