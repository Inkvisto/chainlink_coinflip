"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.headlessInstall = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const build_modules_1 = require("@pnpm/build-modules");
const calc_dep_state_1 = require("@pnpm/calc-dep-state");
const constants_1 = require("@pnpm/constants");
const core_loggers_1 = require("@pnpm/core-loggers");
const filter_lockfile_1 = require("@pnpm/filter-lockfile");
const hoist_1 = require("@pnpm/hoist");
const lifecycle_1 = require("@pnpm/lifecycle");
const link_bins_1 = require("@pnpm/link-bins");
const lockfile_file_1 = require("@pnpm/lockfile-file");
const lockfile_to_pnp_1 = require("@pnpm/lockfile-to-pnp");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = require("@pnpm/logger");
const modules_cleaner_1 = require("@pnpm/modules-cleaner");
const modules_yaml_1 = require("@pnpm/modules-yaml");
const read_package_json_1 = require("@pnpm/read-package-json");
const read_project_manifest_1 = require("@pnpm/read-project-manifest");
const symlink_dependency_1 = require("@pnpm/symlink-dependency");
const types_1 = require("@pnpm/types");
const dp = __importStar(require("@pnpm/dependency-path"));
const p_limit_1 = __importDefault(require("p-limit"));
const path_absolute_1 = __importDefault(require("path-absolute"));
const equals_1 = __importDefault(require("ramda/src/equals"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const omit_1 = __importDefault(require("ramda/src/omit"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const props_1 = __importDefault(require("ramda/src/props"));
const union_1 = __importDefault(require("ramda/src/union"));
const realpath_missing_1 = __importDefault(require("realpath-missing"));
const linkHoistedModules_1 = require("./linkHoistedModules");
const deps_graph_builder_1 = require("@pnpm/deps.graph-builder");
const lockfileToHoistedDepGraph_1 = require("./lockfileToHoistedDepGraph");
const pkg_manager_direct_dep_linker_1 = require("@pnpm/pkg-manager.direct-dep-linker");
async function headlessInstall(opts) {
    const reporter = opts.reporter;
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const lockfileDir = opts.lockfileDir;
    const wantedLockfile = opts.wantedLockfile ?? await (0, lockfile_file_1.readWantedLockfile)(lockfileDir, {
        ignoreIncompatible: false,
        useGitBranchLockfile: opts.useGitBranchLockfile,
        // mergeGitBranchLockfiles is intentionally not supported in headless
        mergeGitBranchLockfiles: false,
    });
    if (wantedLockfile == null) {
        throw new Error(`Headless installation requires a ${constants_1.WANTED_LOCKFILE} file`);
    }
    const depsStateCache = {};
    const relativeModulesDir = opts.modulesDir ?? 'node_modules';
    const rootModulesDir = await (0, realpath_missing_1.default)(path_1.default.join(lockfileDir, relativeModulesDir));
    const virtualStoreDir = (0, path_absolute_1.default)(opts.virtualStoreDir ?? path_1.default.join(relativeModulesDir, '.pnpm'), lockfileDir);
    const currentLockfile = opts.currentLockfile ?? await (0, lockfile_file_1.readCurrentLockfile)(virtualStoreDir, { ignoreIncompatible: false });
    const hoistedModulesDir = path_1.default.join(virtualStoreDir, 'node_modules');
    const publicHoistedModulesDir = rootModulesDir;
    const selectedProjects = Object.values((0, pick_1.default)(opts.selectedProjectDirs, opts.allProjects));
    const scriptsOpts = {
        optional: false,
        extraBinPaths: opts.extraBinPaths,
        extraNodePaths: opts.extraNodePaths,
        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
        extraEnv: opts.extraEnv,
        rawConfig: opts.rawConfig,
        resolveSymlinksInInjectedDirs: opts.resolveSymlinksInInjectedDirs,
        scriptsPrependNodePath: opts.scriptsPrependNodePath,
        scriptShell: opts.scriptShell,
        shellEmulator: opts.shellEmulator,
        stdio: opts.ownLifecycleHooksStdio ?? 'inherit',
        storeController: opts.storeController,
        unsafePerm: opts.unsafePerm || false,
    };
    const skipped = opts.skipped || new Set();
    let removed = 0;
    if (opts.nodeLinker !== 'hoisted') {
        if (currentLockfile != null && !opts.ignorePackageManifest) {
            const removedDepPaths = await (0, modules_cleaner_1.prune)(selectedProjects, {
                currentLockfile,
                dryRun: false,
                hoistedDependencies: opts.hoistedDependencies,
                hoistedModulesDir: (opts.hoistPattern == null) ? undefined : hoistedModulesDir,
                include: opts.include,
                lockfileDir,
                pruneStore: opts.pruneStore,
                pruneVirtualStore: opts.pruneVirtualStore,
                publicHoistedModulesDir: (opts.publicHoistPattern == null) ? undefined : publicHoistedModulesDir,
                registries: opts.registries,
                skipped,
                storeController: opts.storeController,
                virtualStoreDir,
                wantedLockfile,
            });
            removed = removedDepPaths.size;
        }
        else {
            core_loggers_1.statsLogger.debug({
                prefix: lockfileDir,
                removed: 0,
            });
        }
    }
    core_loggers_1.stageLogger.debug({
        prefix: lockfileDir,
        stage: 'importing_started',
    });
    const filterOpts = {
        include: opts.include,
        registries: opts.registries,
        skipped,
    };
    const initialImporterIds = (opts.ignorePackageManifest === true || opts.nodeLinker === 'hoisted')
        ? Object.keys(wantedLockfile.importers)
        : selectedProjects.map(({ id }) => id);
    const { lockfile: filteredLockfile, selectedImporterIds: importerIds } = (0, filter_lockfile_1.filterLockfileByImportersAndEngine)(wantedLockfile, initialImporterIds, {
        ...filterOpts,
        currentEngine: opts.currentEngine,
        engineStrict: opts.engineStrict,
        failOnMissingDependencies: true,
        includeIncompatiblePackages: opts.force,
        lockfileDir,
    });
    if (opts.excludeLinksFromLockfile) {
        for (const { id, manifest, rootDir } of selectedProjects) {
            if (filteredLockfile.importers[id]) {
                for (const depType of types_1.DEPENDENCIES_FIELDS) {
                    filteredLockfile.importers[id][depType] = {
                        ...filteredLockfile.importers[id][depType],
                        ...Object.entries(manifest[depType] ?? {})
                            .filter(([_, spec]) => spec.startsWith('link:'))
                            .reduce((acc, [depName, spec]) => {
                            const linkPath = spec.substring(5);
                            acc[depName] = path_1.default.isAbsolute(linkPath) ? `link:${path_1.default.relative(rootDir, spec.substring(5))}` : spec;
                            return acc;
                        }, {}),
                    };
                }
            }
        }
    }
    // Update selectedProjects to add missing projects. importerIds will have the updated ids, found from deeply linked workspace projects
    const initialImporterIdSet = new Set(initialImporterIds);
    const missingIds = importerIds.filter((importerId) => !initialImporterIdSet.has(importerId));
    if (missingIds.length > 0) {
        for (const project of Object.values(opts.allProjects)) {
            if (missingIds.includes(project.id)) {
                selectedProjects.push(project);
            }
        }
    }
    const lockfileToDepGraphOpts = {
        ...opts,
        importerIds,
        lockfileDir,
        skipped,
        virtualStoreDir,
        nodeVersion: opts.currentEngine.nodeVersion,
        pnpmVersion: opts.currentEngine.pnpmVersion,
    };
    const { directDependenciesByImporterId, graph, hierarchy, hoistedLocations, pkgLocationsByDepPath, prevGraph, symlinkedDirectDependenciesByImporterId, } = await (opts.nodeLinker === 'hoisted'
        ? (0, lockfileToHoistedDepGraph_1.lockfileToHoistedDepGraph)(filteredLockfile, currentLockfile, lockfileToDepGraphOpts)
        : (0, deps_graph_builder_1.lockfileToDepGraph)(filteredLockfile, opts.force ? null : currentLockfile, lockfileToDepGraphOpts));
    if (opts.enablePnp) {
        const importerNames = Object.fromEntries(selectedProjects.map(({ manifest, id }) => [id, manifest.name ?? id]));
        await (0, lockfile_to_pnp_1.writePnpFile)(filteredLockfile, {
            importerNames,
            lockfileDir,
            virtualStoreDir,
            registries: opts.registries,
        });
    }
    const depNodes = Object.values(graph);
    const added = depNodes.length;
    core_loggers_1.statsLogger.debug({
        added,
        prefix: lockfileDir,
    });
    function warn(message) {
        logger_1.logger.info({
            message,
            prefix: lockfileDir,
        });
    }
    let newHoistedDependencies;
    let linkedToRoot = 0;
    if (opts.nodeLinker === 'hoisted' && hierarchy && prevGraph) {
        await (0, linkHoistedModules_1.linkHoistedModules)(opts.storeController, graph, prevGraph, hierarchy, {
            depsStateCache,
            force: opts.force,
            ignoreScripts: opts.ignoreScripts,
            lockfileDir: opts.lockfileDir,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            sideEffectsCacheRead: opts.sideEffectsCacheRead,
        });
        core_loggers_1.stageLogger.debug({
            prefix: lockfileDir,
            stage: 'importing_done',
        });
        linkedToRoot = await symlinkDirectDependencies({
            directDependenciesByImporterId: symlinkedDirectDependenciesByImporterId,
            dedupe: Boolean(opts.dedupeDirectDeps),
            filteredLockfile,
            lockfileDir,
            projects: selectedProjects,
            registries: opts.registries,
            symlink: opts.symlink,
        });
    }
    else if (opts.enableModulesDir !== false) {
        await Promise.all(depNodes.map(async (depNode) => fs_1.promises.mkdir(depNode.modules, { recursive: true })));
        await Promise.all([
            opts.symlink === false
                ? Promise.resolve()
                : linkAllModules(depNodes, {
                    lockfileDir,
                    optional: opts.include.optionalDependencies,
                }),
            linkAllPkgs(opts.storeController, depNodes, {
                force: opts.force,
                depGraph: graph,
                depsStateCache,
                ignoreScripts: opts.ignoreScripts,
                lockfileDir: opts.lockfileDir,
                sideEffectsCacheRead: opts.sideEffectsCacheRead,
            }),
        ]);
        core_loggers_1.stageLogger.debug({
            prefix: lockfileDir,
            stage: 'importing_done',
        });
        if (opts.ignorePackageManifest !== true && (opts.hoistPattern != null || opts.publicHoistPattern != null)) {
            // It is important to keep the skipped packages in the lockfile which will be saved as the "current lockfile".
            // pnpm is comparing the current lockfile to the wanted one and they should match.
            // But for hoisting, we need a version of the lockfile w/o the skipped packages, so we're making a copy.
            const hoistLockfile = {
                ...filteredLockfile,
                packages: (0, omit_1.default)(Array.from(skipped), filteredLockfile.packages),
            };
            newHoistedDependencies = await (0, hoist_1.hoist)({
                extraNodePath: opts.extraNodePaths,
                lockfile: hoistLockfile,
                importerIds,
                preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                privateHoistedModulesDir: hoistedModulesDir,
                privateHoistPattern: opts.hoistPattern ?? [],
                publicHoistedModulesDir,
                publicHoistPattern: opts.publicHoistPattern ?? [],
                virtualStoreDir,
            });
        }
        else {
            newHoistedDependencies = {};
        }
        await linkAllBins(graph, {
            extraNodePaths: opts.extraNodePaths,
            optional: opts.include.optionalDependencies,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            warn,
        });
        if ((currentLockfile != null) && !(0, equals_1.default)(importerIds.sort(), Object.keys(filteredLockfile.importers).sort())) {
            Object.assign(filteredLockfile.packages, currentLockfile.packages);
        }
        /** Skip linking and due to no project manifest */
        if (!opts.ignorePackageManifest) {
            linkedToRoot = await symlinkDirectDependencies({
                dedupe: Boolean(opts.dedupeDirectDeps),
                directDependenciesByImporterId,
                filteredLockfile,
                lockfileDir,
                projects: selectedProjects,
                registries: opts.registries,
                symlink: opts.symlink,
            });
        }
    }
    if (opts.ignoreScripts) {
        for (const { id, manifest } of selectedProjects) {
            if (opts.ignoreScripts && ((manifest?.scripts) != null) &&
                (manifest.scripts.preinstall ?? manifest.scripts.prepublish ??
                    manifest.scripts.install ??
                    manifest.scripts.postinstall ??
                    manifest.scripts.prepare)) {
                opts.pendingBuilds.push(id);
            }
        }
        // we can use concat here because we always only append new packages, which are guaranteed to not be there by definition
        opts.pendingBuilds = opts.pendingBuilds
            .concat(depNodes
            .filter(({ requiresBuild }) => requiresBuild)
            .map(({ depPath }) => depPath));
    }
    if (!opts.ignoreScripts || Object.keys(opts.patchedDependencies ?? {}).length > 0) {
        const directNodes = new Set();
        for (const id of (0, union_1.default)(importerIds, ['.'])) {
            Object
                .values(directDependenciesByImporterId[id] ?? {})
                .filter((loc) => graph[loc])
                .forEach((loc) => {
                directNodes.add(loc);
            });
        }
        const extraBinPaths = [...opts.extraBinPaths ?? []];
        if (opts.hoistPattern != null) {
            extraBinPaths.unshift(path_1.default.join(virtualStoreDir, 'node_modules/.bin'));
        }
        let extraEnv = opts.extraEnv;
        if (opts.enablePnp) {
            extraEnv = {
                ...extraEnv,
                ...(0, lifecycle_1.makeNodeRequireOption)(path_1.default.join(opts.lockfileDir, '.pnp.cjs')),
            };
        }
        await (0, build_modules_1.buildModules)(graph, Array.from(directNodes), {
            childConcurrency: opts.childConcurrency,
            extraBinPaths,
            extraEnv,
            depsStateCache,
            ignoreScripts: opts.ignoreScripts || opts.ignoreDepScripts,
            hoistedLocations,
            lockfileDir,
            optional: opts.include.optionalDependencies,
            preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            rawConfig: opts.rawConfig,
            rootModulesDir: virtualStoreDir,
            scriptsPrependNodePath: opts.scriptsPrependNodePath,
            scriptShell: opts.scriptShell,
            shellEmulator: opts.shellEmulator,
            sideEffectsCacheWrite: opts.sideEffectsCacheWrite,
            storeController: opts.storeController,
            unsafePerm: opts.unsafePerm,
            userAgent: opts.userAgent,
        });
    }
    const projectsToBeBuilt = (0, lockfile_utils_1.extendProjectsWithTargetDirs)(selectedProjects, wantedLockfile, {
        pkgLocationsByDepPath,
        virtualStoreDir,
    });
    if (opts.enableModulesDir !== false) {
        /** Skip linking and due to no project manifest */
        if (!opts.ignorePackageManifest) {
            await Promise.all(selectedProjects.map(async (project) => {
                if (opts.nodeLinker === 'hoisted' || opts.publicHoistPattern?.length && path_1.default.relative(opts.lockfileDir, project.rootDir) === '') {
                    await linkBinsOfImporter(project, {
                        extraNodePaths: opts.extraNodePaths,
                        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                    });
                }
                else {
                    const directPkgDirs = Object.values(directDependenciesByImporterId[project.id]);
                    await (0, link_bins_1.linkBinsOfPackages)((await Promise.all(directPkgDirs.map(async (dir) => ({
                        location: dir,
                        manifest: await (0, read_project_manifest_1.safeReadProjectManifestOnly)(dir),
                    }))))
                        .filter(({ manifest }) => manifest != null), project.binsDir, {
                        extraNodePaths: opts.extraNodePaths,
                        preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                    });
                }
            }));
        }
        const injectedDeps = {};
        for (const project of projectsToBeBuilt) {
            if (project.targetDirs.length > 0) {
                injectedDeps[project.id] = project.targetDirs.map((targetDir) => path_1.default.relative(opts.lockfileDir, targetDir));
            }
        }
        await (0, modules_yaml_1.writeModulesManifest)(rootModulesDir, {
            hoistedDependencies: newHoistedDependencies,
            hoistPattern: opts.hoistPattern,
            included: opts.include,
            injectedDeps,
            layoutVersion: constants_1.LAYOUT_VERSION,
            hoistedLocations,
            nodeLinker: opts.nodeLinker,
            packageManager: `${opts.packageManager.name}@${opts.packageManager.version}`,
            pendingBuilds: opts.pendingBuilds,
            publicHoistPattern: opts.publicHoistPattern,
            prunedAt: opts.pruneVirtualStore === true || opts.prunedAt == null
                ? new Date().toUTCString()
                : opts.prunedAt,
            registries: opts.registries,
            skipped: Array.from(skipped),
            storeDir: opts.storeDir,
            virtualStoreDir,
        }, {
            makeModulesDir: Object.keys(filteredLockfile.packages ?? {}).length > 0,
        });
        if (opts.useLockfile) {
            // We need to write the wanted lockfile as well.
            // Even though it will only be changed if the workspace will have new projects with no dependencies.
            await (0, lockfile_file_1.writeLockfiles)({
                wantedLockfileDir: opts.lockfileDir,
                currentLockfileDir: virtualStoreDir,
                wantedLockfile,
                currentLockfile: filteredLockfile,
            });
        }
        else {
            await (0, lockfile_file_1.writeCurrentLockfile)(virtualStoreDir, filteredLockfile);
        }
    }
    // waiting till package requests are finished
    await Promise.all(depNodes.map(({ finishing }) => finishing));
    core_loggers_1.summaryLogger.debug({ prefix: lockfileDir });
    await opts.storeController.close();
    if (!opts.ignoreScripts && !opts.ignorePackageManifest) {
        await (0, lifecycle_1.runLifecycleHooksConcurrently)(['preinstall', 'install', 'postinstall', 'prepare'], projectsToBeBuilt, opts.childConcurrency ?? 5, scriptsOpts);
    }
    if ((reporter != null) && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return {
        stats: {
            added,
            removed,
            linkedToRoot,
        },
    };
}
exports.headlessInstall = headlessInstall;
async function symlinkDirectDependencies({ filteredLockfile, dedupe, directDependenciesByImporterId, lockfileDir, projects, registries, symlink, }) {
    projects.forEach(({ rootDir, manifest }) => {
        // Even though headless installation will never update the package.json
        // this needs to be logged because otherwise install summary won't be printed
        core_loggers_1.packageManifestLogger.debug({
            prefix: rootDir,
            updated: manifest,
        });
    });
    if (symlink === false)
        return 0;
    const importerManifestsByImporterId = {};
    for (const { id, manifest } of projects) {
        importerManifestsByImporterId[id] = manifest;
    }
    const projectsToLink = Object.fromEntries(await Promise.all(projects.map(async ({ rootDir, id, modulesDir }) => ([id, {
            dir: rootDir,
            modulesDir,
            dependencies: await getRootPackagesToLink(filteredLockfile, {
                importerId: id,
                importerModulesDir: modulesDir,
                lockfileDir,
                projectDir: rootDir,
                importerManifestsByImporterId,
                registries,
                rootDependencies: directDependenciesByImporterId[id],
            }),
        }]))));
    return (0, pkg_manager_direct_dep_linker_1.linkDirectDeps)(projectsToLink, { dedupe: Boolean(dedupe) });
}
async function linkBinsOfImporter({ manifest, modulesDir, binsDir, rootDir }, { extraNodePaths, preferSymlinkedExecutables } = {}) {
    const warn = (message) => {
        logger_1.logger.info({ message, prefix: rootDir });
    };
    return (0, link_bins_1.linkBins)(modulesDir, binsDir, {
        extraNodePaths,
        allowExoticManifests: true,
        preferSymlinkedExecutables,
        projectManifest: manifest,
        warn,
    });
}
async function getRootPackagesToLink(lockfile, opts) {
    const projectSnapshot = lockfile.importers[opts.importerId];
    const allDeps = {
        ...projectSnapshot.devDependencies,
        ...projectSnapshot.dependencies,
        ...projectSnapshot.optionalDependencies,
    };
    return (await Promise.all(Object.entries(allDeps)
        .map(async ([alias, ref]) => {
        if (ref.startsWith('link:')) {
            const isDev = Boolean(projectSnapshot.devDependencies?.[alias]);
            const isOptional = Boolean(projectSnapshot.optionalDependencies?.[alias]);
            const packageDir = path_1.default.join(opts.projectDir, ref.slice(5));
            const linkedPackage = await (async () => {
                const importerId = (0, lockfile_file_1.getLockfileImporterId)(opts.lockfileDir, packageDir);
                if (opts.importerManifestsByImporterId[importerId]) {
                    return opts.importerManifestsByImporterId[importerId];
                }
                try {
                    // TODO: cover this case with a test
                    return await (0, read_project_manifest_1.readProjectManifestOnly)(packageDir);
                }
                catch (err) { // eslint-disable-line
                    if (err['code'] !== 'ERR_PNPM_NO_IMPORTER_MANIFEST_FOUND')
                        throw err;
                    return { name: alias, version: '0.0.0' };
                }
            })();
            return {
                alias,
                name: linkedPackage.name,
                version: linkedPackage.version,
                dir: packageDir,
                id: ref,
                isExternalLink: true,
                dependencyType: isDev && 'dev' ||
                    isOptional && 'optional' ||
                    'prod',
            };
        }
        const dir = opts.rootDependencies[alias];
        // Skipping linked packages
        if (!dir) {
            return;
        }
        const isDev = Boolean(projectSnapshot.devDependencies?.[alias]);
        const isOptional = Boolean(projectSnapshot.optionalDependencies?.[alias]);
        const depPath = dp.refToRelative(ref, alias);
        if (depPath === null)
            return;
        const pkgSnapshot = lockfile.packages?.[depPath];
        if (pkgSnapshot == null)
            return; // this won't ever happen. Just making typescript happy
        const pkgId = pkgSnapshot.id ?? dp.refToAbsolute(ref, alias, opts.registries) ?? undefined;
        const pkgInfo = (0, lockfile_utils_1.nameVerFromPkgSnapshot)(depPath, pkgSnapshot);
        return {
            alias,
            isExternalLink: false,
            name: pkgInfo.name,
            version: pkgInfo.version,
            dependencyType: isDev && 'dev' || isOptional && 'optional' || 'prod',
            dir,
            id: pkgId,
        };
    })))
        .filter(Boolean);
}
const limitLinking = (0, p_limit_1.default)(16);
async function linkAllPkgs(storeController, depNodes, opts) {
    return Promise.all(depNodes.map(async (depNode) => {
        let filesResponse;
        try {
            filesResponse = await depNode.fetchingFiles();
        }
        catch (err) { // eslint-disable-line
            if (depNode.optional)
                return;
            throw err;
        }
        let sideEffectsCacheKey;
        if (opts.sideEffectsCacheRead && filesResponse.sideEffects && !(0, isEmpty_1.default)(filesResponse.sideEffects)) {
            sideEffectsCacheKey = (0, calc_dep_state_1.calcDepState)(opts.depGraph, opts.depsStateCache, depNode.dir, {
                isBuilt: !opts.ignoreScripts && depNode.requiresBuild,
                patchFileHash: depNode.patchFile?.hash,
            });
        }
        const { importMethod, isBuilt } = await storeController.importPackage(depNode.dir, {
            filesResponse,
            force: opts.force,
            requiresBuild: depNode.requiresBuild || depNode.patchFile != null,
            sideEffectsCacheKey,
        });
        if (importMethod) {
            core_loggers_1.progressLogger.debug({
                method: importMethod,
                requester: opts.lockfileDir,
                status: 'imported',
                to: depNode.dir,
            });
        }
        depNode.isBuilt = isBuilt;
        const selfDep = depNode.children[depNode.name];
        if (selfDep) {
            const pkg = opts.depGraph[selfDep];
            if (!pkg)
                return;
            const targetModulesDir = path_1.default.join(depNode.modules, depNode.name, 'node_modules');
            await limitLinking(async () => (0, symlink_dependency_1.symlinkDependency)(pkg.dir, targetModulesDir, depNode.name));
        }
    }));
}
async function linkAllBins(depGraph, opts) {
    return Promise.all(Object.values(depGraph)
        .map(async (depNode) => limitLinking(async () => {
        const childrenToLink = opts.optional
            ? depNode.children
            : (0, pickBy_1.default)((_, childAlias) => !depNode.optionalDependencies.has(childAlias), depNode.children);
        const binPath = path_1.default.join(depNode.dir, 'node_modules/.bin');
        const pkgSnapshots = (0, props_1.default)(Object.values(childrenToLink), depGraph);
        if (pkgSnapshots.includes(undefined)) { // eslint-disable-line
            await (0, link_bins_1.linkBins)(depNode.modules, binPath, {
                extraNodePaths: opts.extraNodePaths,
                preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                warn: opts.warn,
            });
        }
        else {
            const pkgs = await Promise.all(pkgSnapshots
                .filter(({ hasBin }) => hasBin)
                .map(async ({ dir }) => ({
                location: dir,
                manifest: await (0, read_package_json_1.readPackageJsonFromDir)(dir),
            })));
            await (0, link_bins_1.linkBinsOfPackages)(pkgs, binPath, {
                extraNodePaths: opts.extraNodePaths,
                preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
            });
        }
        // link also the bundled dependencies` bins
        if (depNode.hasBundledDependencies) {
            const bundledModules = path_1.default.join(depNode.dir, 'node_modules');
            await (0, link_bins_1.linkBins)(bundledModules, binPath, {
                extraNodePaths: opts.extraNodePaths,
                preferSymlinkedExecutables: opts.preferSymlinkedExecutables,
                warn: opts.warn,
            });
        }
    })));
}
async function linkAllModules(depNodes, opts) {
    await Promise.all(depNodes
        .map(async (depNode) => {
        const childrenToLink = opts.optional
            ? depNode.children
            : (0, pickBy_1.default)((_, childAlias) => !depNode.optionalDependencies.has(childAlias), depNode.children);
        await Promise.all(Object.entries(childrenToLink)
            .map(async ([alias, pkgDir]) => {
            // if (!pkg.installable && pkg.optional) return
            if (alias === depNode.name) {
                return;
            }
            await limitLinking(() => (0, symlink_dependency_1.symlinkDependency)(pkgDir, depNode.modules, alias));
        }));
    }));
}
//# sourceMappingURL=index.js.map