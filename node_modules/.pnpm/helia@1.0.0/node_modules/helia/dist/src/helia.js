var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HeliaImpl_bitswap;
import { identity } from 'multiformats/hashes/identity';
import { sha256, sha512 } from 'multiformats/hashes/sha2';
import { createBitswap } from 'ipfs-bitswap';
import { BlockStorage } from './storage.js';
import { PinsImpl } from './pins.js';
import { assertDatastoreVersionIsCurrent } from './utils/datastore-version.js';
import drain from 'it-drain';
import { CustomProgressEvent } from 'progress-events';
import { MemoryDatastore } from 'datastore-core';
import { MemoryBlockstore } from 'blockstore-core';
import { logger } from '@libp2p/logger';
const log = logger('helia');
export class HeliaImpl {
    constructor(init) {
        _HeliaImpl_bitswap.set(this, void 0);
        const hashers = [
            sha256,
            sha512,
            identity,
            ...(init.hashers ?? [])
        ];
        const datastore = init.datastore ?? new MemoryDatastore();
        const blockstore = init.blockstore ?? new MemoryBlockstore();
        // @ts-expect-error incomplete libp2p implementation
        const libp2p = init.libp2p ?? new Proxy({}, {
            get(_, prop) {
                const noop = () => { };
                const noops = ['start', 'stop'];
                if (noops.includes(prop.toString())) {
                    return noop;
                }
                if (prop === 'isProxy') {
                    return true;
                }
                throw new Error('Please configure Helia with a libp2p instance');
            },
            set() {
                throw new Error('Please configure Helia with a libp2p instance');
            }
        });
        if (init.libp2p != null) {
            __classPrivateFieldSet(this, _HeliaImpl_bitswap, createBitswap(libp2p, blockstore, {
                hashLoader: {
                    getHasher: async (codecOrName) => {
                        const hasher = hashers.find(hasher => {
                            return hasher.code === codecOrName || hasher.name === codecOrName;
                        });
                        if (hasher != null) {
                            return await Promise.resolve(hasher);
                        }
                        throw new Error(`Could not load hasher for code/name "${codecOrName}"`);
                    }
                }
            }), "f");
        }
        this.pins = new PinsImpl(datastore, blockstore, init.dagWalkers ?? []);
        this.libp2p = libp2p;
        this.blockstore = new BlockStorage(blockstore, this.pins, {
            bitswap: __classPrivateFieldGet(this, _HeliaImpl_bitswap, "f"),
            holdGcLock: init.holdGcLock
        });
        this.datastore = datastore;
    }
    async start() {
        await assertDatastoreVersionIsCurrent(this.datastore);
        await __classPrivateFieldGet(this, _HeliaImpl_bitswap, "f")?.start();
        await this.libp2p.start();
    }
    async stop() {
        await this.libp2p.stop();
        await __classPrivateFieldGet(this, _HeliaImpl_bitswap, "f")?.stop();
    }
    async gc(options = {}) {
        const releaseLock = await this.blockstore.lock.writeLock();
        try {
            const helia = this;
            const blockstore = this.blockstore.unwrap();
            log('gc start');
            await drain(blockstore.deleteMany((async function* () {
                for await (const { cid } of blockstore.getAll()) {
                    try {
                        if (await helia.pins.isPinned(cid, options)) {
                            continue;
                        }
                        yield cid;
                        options.onProgress?.(new CustomProgressEvent('helia:gc:deleted', cid));
                    }
                    catch (err) {
                        log.error('Error during gc', err);
                        options.onProgress?.(new CustomProgressEvent('helia:gc:error', err));
                    }
                }
            }())));
        }
        finally {
            releaseLock();
        }
        log('gc finished');
    }
}
_HeliaImpl_bitswap = new WeakMap();
//# sourceMappingURL=helia.js.map