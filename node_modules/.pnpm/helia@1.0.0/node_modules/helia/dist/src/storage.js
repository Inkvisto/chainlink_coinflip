import filter from 'it-filter';
import createMortice from 'mortice';
import forEach from 'it-foreach';
import { CustomProgressEvent } from 'progress-events';
/**
 * BlockStorage is a hybrid blockstore that puts/gets blocks from a configured
 * blockstore (that may be on disk, s3, or something else). If the blocks are
 * not present Bitswap will be used to fetch them from network peers.
 */
export class BlockStorage {
    /**
     * Create a new BlockStorage
     */
    constructor(blockstore, pins, options = {}) {
        this.child = blockstore;
        this.bitswap = options.bitswap;
        this.pins = pins;
        this.lock = createMortice({
            singleProcess: options.holdGcLock
        });
    }
    unwrap() {
        return this.child;
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            if (await this.child.has(cid)) {
                options.onProgress?.(new CustomProgressEvent('blocks:put:duplicate', cid));
                return cid;
            }
            if (this.bitswap?.isStarted() === true) {
                options.onProgress?.(new CustomProgressEvent('blocks:put:bitswap:notify', cid));
                this.bitswap.notify(cid, block, options);
            }
            options.onProgress?.(new CustomProgressEvent('blocks:put:blockstore:put', cid));
            return await this.child.put(cid, block, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            const missingBlocks = filter(blocks, async ({ cid }) => {
                const has = await this.child.has(cid);
                if (has) {
                    options.onProgress?.(new CustomProgressEvent('blocks:put-many:duplicate', cid));
                }
                return !has;
            });
            const notifyEach = forEach(missingBlocks, ({ cid, block }) => {
                options.onProgress?.(new CustomProgressEvent('blocks:put-many:bitswap:notify', cid));
                this.bitswap?.notify(cid, block, options);
            });
            options.onProgress?.(new CustomProgressEvent('blocks:put-many:blockstore:put-many'));
            yield* this.child.putMany(notifyEach, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Get a block by cid
     */
    async get(cid, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            if (this.bitswap?.isStarted() != null && !(await this.child.has(cid))) {
                options.onProgress?.(new CustomProgressEvent('blocks:get:bitswap:get', cid));
                const block = await this.bitswap.want(cid, options);
                options.onProgress?.(new CustomProgressEvent('blocks:get:blockstore:put', cid));
                await this.child.put(cid, block, options);
                return block;
            }
            options.onProgress?.(new CustomProgressEvent('blocks:get:blockstore:get', cid));
            return await this.child.get(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            options.onProgress?.(new CustomProgressEvent('blocks:get-many:blockstore:get-many'));
            yield* this.child.getMany(forEach(cids, async (cid) => {
                if (this.bitswap?.isStarted() === true && !(await this.child.has(cid))) {
                    options.onProgress?.(new CustomProgressEvent('blocks:get-many:bitswap:get', cid));
                    const block = await this.bitswap.want(cid, options);
                    options.onProgress?.(new CustomProgressEvent('blocks:get-many:blockstore:put', cid));
                    await this.child.put(cid, block, options);
                }
            }));
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options = {}) {
        const releaseLock = await this.lock.writeLock();
        try {
            if (await this.pins.isPinned(cid)) {
                throw new Error('CID was pinned');
            }
            options.onProgress?.(new CustomProgressEvent('blocks:delete:blockstore:delete', cid));
            await this.child.delete(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options = {}) {
        const releaseLock = await this.lock.writeLock();
        try {
            const storage = this;
            options.onProgress?.(new CustomProgressEvent('blocks:delete-many:blockstore:delete-many'));
            yield* this.child.deleteMany((async function* () {
                for await (const cid of cids) {
                    if (await storage.pins.isPinned(cid)) {
                        throw new Error('CID was pinned');
                    }
                    yield cid;
                }
            }()), options);
        }
        finally {
            releaseLock();
        }
    }
    async has(cid, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            return await this.child.has(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    async *getAll(options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            options.onProgress?.(new CustomProgressEvent('blocks:get-all:blockstore:get-many'));
            yield* this.child.getAll(options);
        }
        finally {
            releaseLock();
        }
    }
}
//# sourceMappingURL=storage.js.map