"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryLoadServerJson = exports.createOrConnectStoreController = exports.createOrConnectStoreControllerCached = exports.serverConnectionInfoDir = exports.createNewStoreController = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const cli_meta_1 = require("@pnpm/cli-meta");
const error_1 = require("@pnpm/error");
const logger_1 = require("@pnpm/logger");
const server_1 = require("@pnpm/server");
const store_path_1 = require("@pnpm/store-path");
const delay_1 = __importDefault(require("delay"));
const createNewStoreController_1 = require("./createNewStoreController");
Object.defineProperty(exports, "createNewStoreController", { enumerable: true, get: function () { return createNewStoreController_1.createNewStoreController; } });
const runServerInBackground_1 = require("./runServerInBackground");
const serverConnectionInfoDir_1 = require("./serverConnectionInfoDir");
Object.defineProperty(exports, "serverConnectionInfoDir", { enumerable: true, get: function () { return serverConnectionInfoDir_1.serverConnectionInfoDir; } });
async function createOrConnectStoreControllerCached(storeControllerCache, opts) {
    const storeDir = await (0, store_path_1.getStorePath)({
        pkgRoot: opts.dir,
        storePath: opts.storeDir,
        pnpmHomeDir: opts.pnpmHomeDir,
    });
    if (!storeControllerCache.has(storeDir)) {
        storeControllerCache.set(storeDir, createOrConnectStoreController(opts));
    }
    return await storeControllerCache.get(storeDir);
}
exports.createOrConnectStoreControllerCached = createOrConnectStoreControllerCached;
async function createOrConnectStoreController(opts) {
    const storeDir = await (0, store_path_1.getStorePath)({
        pkgRoot: opts.workspaceDir ?? opts.dir,
        storePath: opts.storeDir,
        pnpmHomeDir: opts.pnpmHomeDir,
    });
    const connectionInfoDir = (0, serverConnectionInfoDir_1.serverConnectionInfoDir)(storeDir);
    const serverJsonPath = path_1.default.join(connectionInfoDir, 'server.json');
    let serverJson = await tryLoadServerJson({ serverJsonPath, shouldRetryOnNoent: false });
    if (serverJson !== null) {
        if (serverJson.pnpmVersion !== cli_meta_1.packageManager.version) {
            logger_1.logger.warn({
                message: `The store server runs on pnpm v${serverJson.pnpmVersion}. It is recommended to connect with the same version (current is v${cli_meta_1.packageManager.version})`,
                prefix: opts.dir,
            });
        }
        logger_1.logger.info({
            message: 'A store server is running. All store manipulations are delegated to it.',
            prefix: opts.dir,
        });
        return {
            ctrl: await (0, server_1.connectStoreController)(serverJson.connectionOptions),
            dir: storeDir,
        };
    }
    if (opts.useRunningStoreServer) {
        throw new error_1.PnpmError('NO_STORE_SERVER', 'No store server is running.');
    }
    if (opts.useStoreServer) {
        (0, runServerInBackground_1.runServerInBackground)(storeDir);
        serverJson = await tryLoadServerJson({ serverJsonPath, shouldRetryOnNoent: true });
        logger_1.logger.info({
            message: 'A store server has been started. To stop it, use `pnpm server stop`',
            prefix: opts.dir,
        });
        return {
            ctrl: await (0, server_1.connectStoreController)(serverJson.connectionOptions),
            dir: storeDir,
        };
    }
    return (0, createNewStoreController_1.createNewStoreController)(Object.assign(opts, {
        storeDir,
    }));
}
exports.createOrConnectStoreController = createOrConnectStoreController;
async function tryLoadServerJson(options) {
    let beforeFirstAttempt = true;
    const startHRTime = process.hrtime();
    /* eslint-disable no-await-in-loop */
    while (true) {
        if (!beforeFirstAttempt) {
            const elapsedHRTime = process.hrtime(startHRTime);
            // Time out after 10 seconds of waiting for the server to start, assuming something went wrong.
            // E.g. server got a SIGTERM or was otherwise abruptly terminated, server has a bug or a third
            // party is interfering.
            if (elapsedHRTime[0] >= 10) {
                // Delete the file in an attempt to recover from this bad state.
                try {
                    await fs_1.promises.unlink(options.serverJsonPath);
                }
                catch (error) { // eslint-disable-line
                    if (error.code !== 'ENOENT') {
                        throw error;
                    }
                    // Either the server.json was manually removed or another process already removed it.
                }
                return null;
            }
            // Poll for server startup every 200 milliseconds.
            await (0, delay_1.default)(200);
        }
        beforeFirstAttempt = false;
        let serverJsonStr;
        try {
            serverJsonStr = await fs_1.promises.readFile(options.serverJsonPath, 'utf8');
        }
        catch (error) { // eslint-disable-line
            if (error.code !== 'ENOENT') {
                throw error;
            }
            if (!options.shouldRetryOnNoent) {
                return null;
            }
            continue;
        }
        let serverJson;
        try {
            serverJson = JSON.parse(serverJsonStr);
        }
        catch (error) { // eslint-disable-line
            // Server is starting or server.json was modified by a third party.
            // We assume the best case and retry.
            continue;
        }
        if (serverJson === null) {
            // Our server should never write null to server.json, even though it is valid json.
            throw new Error('server.json was modified by a third party');
        }
        return serverJson;
    }
    /* eslint-enable no-await-in-loop */
}
exports.tryLoadServerJson = tryLoadServerJson;
//# sourceMappingURL=index.js.map